const e=JSON.parse('{"key":"v-abd3b546","path":"/docs/05-distribution/api.html","title":"API（接口）","lang":"zh-CN","frontmatter":{"description":"1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC [ ] TODO ： API架构风格; Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC (https://www.altexsoft.com/blog/soap-vs-rest-v...","head":[["meta",{"property":"og:url","content":"https://zeanzai.github.io/cs-tips/cs-tips/docs/05-distribution/api.html"}],["meta",{"property":"og:site_name","content":"cs-tips"}],["meta",{"property":"og:title","content":"API（接口）"}],["meta",{"property":"og:description","content":"1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC [ ] TODO ： API架构风格; Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC (https://www.altexsoft.com/blog/soap-vs-rest-v..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://zeanzai.github.io/cs-tips/cs-tips/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"API（接口）"}],["meta",{"property":"article:author","content":"zeanzai"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"API（接口）\\",\\"image\\":[\\"https://zeanzai.github.io/cs-tips/cs-tips/\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"zeanzai\\",\\"url\\":\\"https://github.com/zeanzai\\"}]}"]]},"headers":[{"level":2,"title":"1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC","slug":"_1-api架构风格对比-soap-vs-rest-vs-graphql-vs-rpc","link":"#_1-api架构风格对比-soap-vs-rest-vs-graphql-vs-rpc","children":[{"level":3,"title":"1.1. Remote Procedure Call (RPC):唤醒另一个系统的功能","slug":"_1-1-remote-procedure-call-rpc-唤醒另一个系统的功能","link":"#_1-1-remote-procedure-call-rpc-唤醒另一个系统的功能","children":[{"level":4,"title":"1.1.1. RPC如何工作","slug":"_1-1-1-rpc如何工作","link":"#_1-1-1-rpc如何工作","children":[]},{"level":4,"title":"1.1.2. RPC的优点","slug":"_1-1-2-rpc的优点","link":"#_1-1-2-rpc的优点","children":[]},{"level":4,"title":"1.1.3. RPC的缺点","slug":"_1-1-3-rpc的缺点","link":"#_1-1-3-rpc的缺点","children":[]},{"level":4,"title":"1.1.4. RPC使用场景","slug":"_1-1-4-rpc使用场景","link":"#_1-1-4-rpc使用场景","children":[]}]},{"level":3,"title":"1.2. Simple Objects Access Protocol (SOAP): 让数据作为服务","slug":"_1-2-simple-objects-access-protocol-soap-让数据作为服务","link":"#_1-2-simple-objects-access-protocol-soap-让数据作为服务","children":[{"level":4,"title":"1.2.1. SOAP如何工作","slug":"_1-2-1-soap如何工作","link":"#_1-2-1-soap如何工作","children":[]},{"level":4,"title":"1.2.2. SOAP的优点","slug":"_1-2-2-soap的优点","link":"#_1-2-2-soap的优点","children":[]},{"level":4,"title":"1.2.3. SOAP的缺点","slug":"_1-2-3-soap的缺点","link":"#_1-2-3-soap的缺点","children":[]},{"level":4,"title":"1.2.4. SOAP的使用场景","slug":"_1-2-4-soap的使用场景","link":"#_1-2-4-soap的使用场景","children":[]}]},{"level":3,"title":"1.3. Representational state transfer (REST): 将数据作为资源","slug":"_1-3-representational-state-transfer-rest-将数据作为资源","link":"#_1-3-representational-state-transfer-rest-将数据作为资源","children":[{"level":4,"title":"1.3.1. REST如何工作","slug":"_1-3-1-rest如何工作","link":"#_1-3-1-rest如何工作","children":[]},{"level":4,"title":"1.3.2. REST的优点","slug":"_1-3-2-rest的优点","link":"#_1-3-2-rest的优点","children":[]},{"level":4,"title":"1.3.3. REST的缺点","slug":"_1-3-3-rest的缺点","link":"#_1-3-3-rest的缺点","children":[]},{"level":4,"title":"1.3.4. REST的使用场景","slug":"_1-3-4-rest的使用场景","link":"#_1-3-4-rest的使用场景","children":[]}]},{"level":3,"title":"1.4. GraphQL：仅请求需要的数据","slug":"_1-4-graphql-仅请求需要的数据","link":"#_1-4-graphql-仅请求需要的数据","children":[{"level":4,"title":"1.4.1. GraphQL如何工作","slug":"_1-4-1-graphql如何工作","link":"#_1-4-1-graphql如何工作","children":[]},{"level":4,"title":"1.4.2. GraphQL 的优点","slug":"_1-4-2-graphql-的优点","link":"#_1-4-2-graphql-的优点","children":[]},{"level":4,"title":"1.4.3. GraphQL 的缺点","slug":"_1-4-3-graphql-的缺点","link":"#_1-4-3-graphql-的缺点","children":[]},{"level":4,"title":"1.4.4. GraphQL的使用场景","slug":"_1-4-4-graphql的使用场景","link":"#_1-4-4-graphql的使用场景","children":[]}]},{"level":3,"title":"1.5. 如何选择API模式","slug":"_1-5-如何选择api模式","link":"#_1-5-如何选择api模式","children":[]}]},{"level":2,"title":"2. 接口攻防","slug":"_2-接口攻防","link":"#_2-接口攻防","children":[{"level":3,"title":"2.1. 接口攻击","slug":"_2-1-接口攻击","link":"#_2-1-接口攻击","children":[]},{"level":3,"title":"2.2. 接口防御","slug":"_2-2-接口防御","link":"#_2-2-接口防御","children":[]},{"level":3,"title":"2.3. 接口防御之最佳实践","slug":"_2-3-接口防御之最佳实践","link":"#_2-3-接口防御之最佳实践","children":[]}]},{"level":2,"title":"3. 接口的其他问题","slug":"_3-接口的其他问题","link":"#_3-接口的其他问题","children":[{"level":3,"title":"3.1. 接口重试","slug":"_3-1-接口重试","link":"#_3-1-接口重试","children":[{"level":4,"title":"3.1.1. 实际场景","slug":"_3-1-1-实际场景","link":"#_3-1-1-实际场景","children":[]},{"level":4,"title":"3.1.2. 原因分析","slug":"_3-1-2-原因分析","link":"#_3-1-2-原因分析","children":[]},{"level":4,"title":"3.1.3. 常见实现方案","slug":"_3-1-3-常见实现方案","link":"#_3-1-3-常见实现方案","children":[{"level":5,"title":"3.1.3.1. 手动实现重试逻辑","slug":"_3-1-3-1-手动实现重试逻辑","link":"#_3-1-3-1-手动实现重试逻辑","children":[]},{"level":5,"title":"3.1.3.2. 使用Spring Retry","slug":"_3-1-3-2-使用spring-retry","link":"#_3-1-3-2-使用spring-retry","children":[]},{"level":5,"title":"3.1.3.3. Resilience4j","slug":"_3-1-3-3-resilience4j","link":"#_3-1-3-3-resilience4j","children":[]},{"level":5,"title":"3.1.3.4. Hystrix（已进入维护模式）","slug":"_3-1-3-4-hystrix-已进入维护模式","link":"#_3-1-3-4-hystrix-已进入维护模式","children":[]},{"level":5,"title":"3.1.3.5. Guava Retryer","slug":"_3-1-3-5-guava-retryer","link":"#_3-1-3-5-guava-retryer","children":[]},{"level":5,"title":"3.1.3.6. 总结","slug":"_3-1-3-6-总结","link":"#_3-1-3-6-总结","children":[]}]},{"level":4,"title":"3.1.4. 最佳实践","slug":"_3-1-4-最佳实践","link":"#_3-1-4-最佳实践","children":[]}]},{"level":3,"title":"3.2. 防刷","slug":"_3-2-防刷","link":"#_3-2-防刷","children":[{"level":4,"title":"3.2.1. 基于令牌桶算法的限流","slug":"_3-2-1-基于令牌桶算法的限流","link":"#_3-2-1-基于令牌桶算法的限流","children":[]},{"level":4,"title":"3.2.2. 基于计数器的限流","slug":"_3-2-2-基于计数器的限流","link":"#_3-2-2-基于计数器的限流","children":[]},{"level":4,"title":"3.2.3. 基于Redis的分布式限流","slug":"_3-2-3-基于redis的分布式限流","link":"#_3-2-3-基于redis的分布式限流","children":[]},{"level":4,"title":"3.2.4. 基于熔断器的限流","slug":"_3-2-4-基于熔断器的限流","link":"#_3-2-4-基于熔断器的限流","children":[]},{"level":4,"title":"3.2.5. 基于Nginx的限流","slug":"_3-2-5-基于nginx的限流","link":"#_3-2-5-基于nginx的限流","children":[]},{"level":4,"title":"3.2.6. 基于网关的限流（如Spring Cloud Gateway）","slug":"_3-2-6-基于网关的限流-如spring-cloud-gateway","link":"#_3-2-6-基于网关的限流-如spring-cloud-gateway","children":[]},{"level":4,"title":"3.2.7. 总结","slug":"_3-2-7-总结","link":"#_3-2-7-总结","children":[]}]},{"level":3,"title":"3.3. 调优","slug":"_3-3-调优","link":"#_3-3-调优","children":[]}]},{"level":2,"title":"4. TODO","slug":"_4-todo","link":"#_4-todo","children":[]},{"level":2,"title":"5. 参考","slug":"_5-参考","link":"#_5-参考","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":32.59,"words":9776},"filePathRelative":"docs/05-distribution/api.md","autoDesc":true,"excerpt":""}');export{e as data};
