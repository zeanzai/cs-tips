import{_ as p,W as l,X as o,Y as n,Z as s,$ as e,a0 as t,C as i}from"./framework-16b96b76.js";const c="/cs-tips/assets/1699851737223-6fa130c1.png",u="/cs-tips/assets/1699853073103-b76d4f7c.jpeg",r="/cs-tips/assets/1699851181809-7a4f4158.png",d="/cs-tips/assets/1699851187149-11ca33eb.png",k="/cs-tips/assets/1699919718658-cc00236a.png",m="/cs-tips/assets/1699919744691-b0e746e4.png",v="/cs-tips/assets/1699919780889-f04ff698.png",h="/cs-tips/assets/1699919789276-97ec8688.png",b="/cs-tips/assets/1699919845623-a0b93c16.png",g="/cs-tips/assets/1699919853936-240c592a.png",y="/cs-tips/assets/1699919900637-d7cee2ef.png",f="/cs-tips/assets/1699919968155-d4e6524e.png",w="/cs-tips/assets/1699919994506-71c1d206.png",_="/cs-tips/assets/1699920021416-7991e564.png",x="/cs-tips/assets/1699920048773-62be2aa3.png",T="/cs-tips/assets/1699920100257-469a4bde.png",L={},S=t('<h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础" aria-hidden="true">#</a> Java基础</h1><h2 id="_1-基础概念" tabindex="-1"><a class="header-anchor" href="#_1-基础概念" aria-hidden="true">#</a> 1. 基础概念</h2><hr><p>order: 2 author: zeanzai title: 基础概念 category:</p><ul><li>Java编程语言</li></ul><hr><h3 id="类-、-实例-instance-、-对象-object-、实例化" tabindex="-1"><a class="header-anchor" href="#类-、-实例-instance-、-对象-object-、实例化" aria-hidden="true">#</a> 类 、 实例（instance） 、 对象（object） 、实例化</h3><p>面向对象的程序设计中，</p><ul><li>用类创建对象的过程称为<code>实例化</code>；</li><li>类实例化后的一个<code>对象</code>叫做<code>类</code>的一个<code>实例</code>；</li><li><code>对象</code> = <code>实例</code></li></ul><p>如 Date today=new Date()， today变量是由Date类new出来的，这个new的过程称为：类的实例化过程， today变量成为Date类的一个实例。</p><p>关系由强到弱可以划分为： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 。这几种关系大概可以分为： 横向关系和纵向关系。也可以划分为实体之间的关系和类之间的关系。纵向关系包括泛化和实现，这两种关系就也称为类之间的关系，这里我们不做讨论。我们只讨论实体之间的关系，或者说我们只讨论横向关系。</p><p>依赖（Dependency）：语义“a uses b”，a依赖于b，但不持有b的引用。 关联（Association）：语义“a has b”，a拥有b的引用，但a和b无从属关系，二者是一种松散的关联关系，可以随时解除或建立。 聚合（Aggregation）：语义“a owns b”，a拥有b的引用，且有从属关系，二者的耦合比关联更强，但a并不负责b的生命周期。 组合（Composition）：语义“b is a part of a”，a不仅拥有b的引用，还应该全权负责b的整个生命周期，在程序中b通常是a的内部实现细节，不暴露给外部。</p><p>我们注意这四种关系中有一个关键的概念“对象生命周期”，在建模时辨别清楚对象生命周期就不难选择采用DI还是创建对象。DI意味着使用者不负责依赖对象的生命周期，创建对象则相反。对应到上面的4种横向关系，我们一般可以这样处理：第1种依赖关系不需要DI也不需要创建对象；第2，3种关联和聚合关系适合采用DI方式，最后一种组合关系适合采用创建对象方式。</p><p>类与类之间由强到弱关系是: 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖，其中关联，聚合，组合，这三种都是关联关系，并且代码表现都是整体的某个部分，即成员变量。他们只是有强弱关系区分。</p><h3 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h3><h4 id="类变量" tabindex="-1"><a class="header-anchor" href="#类变量" aria-hidden="true">#</a> 类变量</h4><ul><li>也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；</li><li>一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间；</li><li>一个对象修改了变量，则所有对象中这个变量的值都会发生改变；</li></ul><h4 id="实例变量" tabindex="-1"><a class="header-anchor" href="#实例变量" aria-hidden="true">#</a> 实例变量</h4><ul><li>也叫对象变量、成员变量；</li><li>从属于类，由类生成对象时，才分配存储空间，各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量；</li><li>但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题；</li></ul><h4 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量" aria-hidden="true">#</a> 局部变量</h4><ul><li>方法中或者某局部块中声明定义的变量或方法的参数被称为局部变量，</li><li>他们只存在于创建他们的block里（{}之间）无法在block外进行任何操作，如读取、赋值；</li><li>在Java多线程中，每个线程都复制一份局部变量，可防止某些同步问题发生；</li></ul><figure><img src="'+c+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量" aria-hidden="true">#</a> 全局变量</h4><p>包括类变量和成员变量。</p><h4 id="静态变量" tabindex="-1"><a class="header-anchor" href="#静态变量" aria-hidden="true">#</a> 静态变量</h4><p>用static关键字修饰的变量。</p><ul><li>用法上，static是Java的保留关键字，主要是用来限定被修饰对象的使用范围的；</li><li>可以被用来修饰变量和方法，被修饰的变量成为类变量或静态变量，被修饰的方法被称为类方法或静态方法；区别于成员变量和成员方法；</li><li>被static修饰的变量和方法可以被类直接使用，而成员变量和成员方法只能被类生成的对象来调用；</li><li>成员变量和成员方法不能使用由static修饰的变量和方法，即成员变量和成员方法不能调用类变量和类方法；</li><li>从JVM角度讲，static修饰的代码编译后就确定下来了，而成员变量和成员方法是在运行期动态确定的，所以</li></ul><h3 id="final-作用" tabindex="-1"><a class="header-anchor" href="#final-作用" aria-hidden="true">#</a> final 作用</h3><ol><li>修饰类 <ol><li>表明这个类不能被继承；</li><li>类中的所有成员方法都会被隐式地指定为final方法；</li><li>类中属性的访问权限可以随意设置；</li></ol></li><li>修饰方法 <ol><li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。</li><li>类的private方法会隐式地被指定为final方法。</li></ol></li><li>修饰变量 <ol><li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。</li><li>static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变</li></ol></li></ol><h3 id="类的加载机制" tabindex="-1"><a class="header-anchor" href="#类的加载机制" aria-hidden="true">#</a> 类的加载机制</h3><ol><li>类中所有属性的默认值（一举而成）</li><li>父类静态属性初始化，静态块，静态方法的声明（按出现顺序执行）</li><li>子类静态属性初始化，静态块，静态方法的声明 （按出现顺序执行）</li><li>调用父类的构造方法，首先父类的非静态成员初始化，构造块，普通方法的声明（按出现顺序执行）然后父类构造方法。</li><li>调用子类的构造方法，首先子类的非静态成员初始化，构造块，普通方法的声明（按出现顺序执行）然后子类构造方法。</li></ol><p>内部静态类不会自动初始化，只有调用静态内部类的方法，静态域，或者构造方法的时候才会加载静态内部类。</p><p>java遵循“使用时，才加载”的原则。 注意：类的加载过程只发生一次。</p><p>1.对于不含静态方法的非抽象类而言，如果你只是创建了一个类的空引用，并没有执行new操作，该类是不会被加载的。也就是说，一个不含静态方法的非抽象类要被加载的话，肯定是在第一次实例化对象时，才会发生类的加载，同时生成实例化对象。但是之后再实例化对象，类的加载过程不会再发生，类的加载过程只发生一次。</p><p>2.对于含静态方法的非抽象类而言，第一次执行new操作进行实例化或者调用类方法（即该类的静态方法）时，该类才会被加载的。</p><p>3.对于不含静态方法的抽象类而言，只有继承了该类的非抽象子类要被加载时，该不含静态方法的抽象类才会被加载。且抽象父类先加载，非抽象子类后加载。至于非抽象子类什么时候会被加载，见1、2两点。</p><p>4.对于含静态方法的抽象类而言，继承了该类的非抽象子类要被加载时或者调用该含静态方法的抽象类的类方法（即该类的静态方法）时，该含静态方法的抽象类才会被加载。</p><p>5.接口和不含静态方法的抽象类情况类似，都是只有继承了该接口的非抽象子类要被加载时，该接口才会被加载。应该是父接口先加载，非抽象子类后加载。</p><p>上面列了五段话说的绕来绕去的（感觉基础不好的真的会被绕晕，我自己都觉得绕），其实就是为了说明开头的那一段话“java遵循“使用时，才加载”的原则”。通俗点说就是只有用得着某个类或接口的时候，这个类或接口才会被加载，否则就是哪凉快哪待着去。</p><h3 id="环境常用名词" tabindex="-1"><a class="header-anchor" href="#环境常用名词" aria-hidden="true">#</a> 环境常用名词</h3><ul><li>DEV(Development environment)</li><li>FAT(Feature Acceptance Test environment)</li><li>UAT(User Acceptance Test environment)</li><li>PRO(Production environment)</li></ul><h3 id="oltp和olap区别" tabindex="-1"><a class="header-anchor" href="#oltp和olap区别" aria-hidden="true">#</a> OLTP和OLAP区别</h3><p><strong>1、当今的数据处理大致可以分成两大类</strong>：<br> 联机事务处理On-Line Transaction Processing 联机分析处理On-Line Analytical Processing <strong>2、二者特性的不同，决定了对资源需求的偏重</strong></p><hr>',44),A=n("strong",null,"01-1 OLTP(实时交易库大量短事务对IO要求高)",-1),j=n("strong",null,"一、面向交易的实时处理系统OLTP",-1),I={href:"https://cloud.tencent.com/product/cdb-overview?from_column=20065&from=20065",target:"_blank",rel:"noopener noreferrer"},O=n("strong",null,"二、OLTP特点",-1),E={href:"https://cloud.tencent.com/solution/database?from_column=20065&from=20065",target:"_blank",rel:"noopener noreferrer"},M=n("hr",null,null,-1),q=n("strong",null,"01-2 OLAP（数据仓库读取分析对CPU要求高）",-1),H=n("strong",null,"一、OLAP简介",-1),P={href:"https://cloud.tencent.com/product/bi?from_column=20065&from=20065",target:"_blank",rel:"noopener noreferrer"},C=n("strong",null,"二、OLAP的特点一般有",-1),V=n("strong",null,"三、主要OLAP厂商产品介绍",-1),J=n("hr",null,null,-1),D=n("p",null,[n("strong",null,"01-3 OLTP与OLAP总结一、OLTP与OLAP之间的比较")],-1),R=n("figure",null,[n("img",{src:u,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),z=n("p",null,[n("strong",null,"二、特性的不同决定了对资源需求的偏重"),s(" OLTP和OLAP的不同，主要通过以下五点区分开来。 1、用户和系统的面向性: OLTP是面向顾客的,用于事务和查询处理 OLAP是面向市场的,用于数据分析 2、数据内容: OLTP系统管理当前数据 OLAP系统管理大量历史数据,提供汇总和聚集机制 3、访问模式: OLTP系统的访问主要由短的原子事务组成，这种系统需要并行和回滚恢复机制 OLAP系统的访问大部分是只读操作 4、视图: OLTP组织内部的当前数据,不涉及历史数据或不同组织的数据 OLAP则相反. 5、数据库设计: OLTP采用实体-联系ER模型和面向应用的数据库设计. OLAP采用星型或雪花模型和面向主题的数据库设计.")],-1),N={href:"https://cloud.tencent.com/developer/article/1496132",target:"_blank",rel:"noopener noreferrer"},K=t(`<h3 id="_1-导引" tabindex="-1"><a class="header-anchor" href="#_1-导引" aria-hidden="true">#</a> 1. 导引</h3><h4 id="_1-1-问题引入" tabindex="-1"><a class="header-anchor" href="#_1-1-问题引入" aria-hidden="true">#</a> 1.1 问题引入</h4><p>我们知道，Java中int变量存在于jvm的静态区中，在系统之中它的存在形式很简单，就是一个简单的内存块，里面放了一个具体的数字，而Integer则是一个具体的对象，里面不光有具体的数字，还有一些具体的操作方法。早期的Java版本中，要想对int的数据进行对象化操作时，就必须要先把int转化为Integer对象才能够进行操作。例如：在Java1.5中，集合（Collections）不能直接放入int类型的数据，因为集合中要求存放的必须是对象。所以，为了节省由原始类型转化为对象类型的人工成本，也为了迎合Java中一切都是对象的思想，Java后续的版本中就引入了自动拆箱和自动装箱的机制。</p><h2 id="_2-概念" tabindex="-1"><a class="header-anchor" href="#_2-概念" aria-hidden="true">#</a> 2. 概念</h2><h3 id="_2-1-基本数据类型和封装数据类型" tabindex="-1"><a class="header-anchor" href="#_2-1-基本数据类型和封装数据类型" aria-hidden="true">#</a> 2.1 基本数据类型和封装数据类型</h3><p>基本数据类型主要有8种，他们分别是：</p><table><thead><tr><th><strong>基本数据类型(primitive)</strong></th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th><th>char</th><th>boolean</th></tr></thead><tbody><tr><td><strong>占用内存大小</strong></td><td>1字节</td><td>2字节</td><td>4字节</td><td>8字节</td><td>4字节</td><td>8字节</td><td>1 字节</td><td>未知</td></tr><tr><td><strong>默认值</strong></td><td>(byte)0</td><td>(short)0</td><td>0</td><td>0L</td><td>0.0f</td><td>0.0d</td><td>\\u000</td><td>false</td></tr><tr><td><strong>封装数据类型(wrapper)</strong></td><td>Byte</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Character</td><td>Boolean</td></tr></tbody></table><p>二者之间的区别：</p><table><thead><tr><th>基本数据类型</th><th>封装数据类型</th></tr></thead><tbody><tr><td>1. 基本类型</td><td></td></tr></tbody></table><ol start="2"><li>是面向机器底层的数据结构，不需要实例化</li><li>在内存中就是一个简单的变量，没有具体的操作方法 | 1. 引用类型</li><li>是Java对象，<strong>可能</strong>需要进行实例化</li><li>有具体的操作方法 |</li></ol><h3 id="_2-2-拆箱和装箱" tabindex="-1"><a class="header-anchor" href="#_2-2-拆箱和装箱" aria-hidden="true">#</a> 2.2 拆箱和装箱</h3><p>装箱就是将基本数据类型转化为封装数据类型的过程，其主要使用了valueOf()函数将对象的值转化为封装类型的对象；同时，拆箱过程中，就使用intValue()、doubleValue()等函数，将对象的值转化为基本数据类型的值。</p><hr><h2 id="_3-适用场景与不适用场景" tabindex="-1"><a class="header-anchor" href="#_3-适用场景与不适用场景" aria-hidden="true">#</a> 3. 适用场景与不适用场景</h2><h3 id="_3-1-适用场景" tabindex="-1"><a class="header-anchor" href="#_3-1-适用场景" aria-hidden="true">#</a> 3.1 适用场景</h3><p>在Java1.5之前都需要手动的进行基本数据类型到封装类型之间的转化，Java1.5之后就可以实现自动的拆箱和装箱操作了。</p><h3 id="_3-1-1-赋值" tabindex="-1"><a class="header-anchor" href="#_3-1-1-赋值" aria-hidden="true">#</a> 3.1.1 赋值</h3><p>自动拆箱和自动装箱的一个应用场景就是赋值操作。</p><p>如下面代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//before autoboxing</span>
<span class="token class-name">Integer</span> iObject <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Int</span> iPrimitive <span class="token operator">=</span> iObject<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//after java5</span>
<span class="token class-name">Integer</span> iObject <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//autobxing - primitive to wrapper conversion</span>
<span class="token keyword">int</span> iPrimitive <span class="token operator">=</span> iObject<span class="token punctuation">;</span> <span class="token comment">//unboxing - object to primitive conversion</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java编译器帮我们自动完成装箱和拆箱操作。</p><h3 id="_3-1-2-方法调用" tabindex="-1"><a class="header-anchor" href="#_3-1-2-方法调用" aria-hidden="true">#</a> 3.1.2 方法调用</h3><p>另外一个应用场景就是方法调用，在方法调用的过程中，方法会根据具体的参数类型来进行拆箱和装箱操作。如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> iParam<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;autoboxing example - method invocation i: &quot;</span> <span class="token operator">+</span> iParam<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> iParam<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//autoboxing and unboxing in method invocation</span>
<span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//autoboxing</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//unboxing because return type of method is Integer</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-2-不适用场景" tabindex="-1"><a class="header-anchor" href="#_3-2-不适用场景" aria-hidden="true">#</a> 3.2 不适用场景</h2><h3 id="_3-2-1-重载" tabindex="-1"><a class="header-anchor" href="#_3-2-1-重载" aria-hidden="true">#</a> 3.2.1 重载</h3><p>什么情况下不适用，就是重载场景中。先看一个场景：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;method with primitive argument&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;method with wrapper argument&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">//calling overloaded method</span>
<span class="token class-name">AutoboxingTest</span> autoTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoboxingTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
autoTest<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//no autoboxing</span>
<span class="token class-name">Integer</span> iValue <span class="token operator">=</span> value<span class="token punctuation">;</span>
autoTest<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>iValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//no autoboxing</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在重载的过程中，如果多个同名函数中，一个使用基本数据类型作为参数，一个使用封装数据类型作为参数，那么在使用过程中不会发生重载，传递什么类型的参数，就使用什么类型的函数。</p><h3 id="_3-2-2-对象之间的比较" tabindex="-1"><a class="header-anchor" href="#_3-2-2-对象之间的比较" aria-hidden="true">#</a> 3.2.2 对象之间的比较</h3><p>这是一个比较容易出错的地方，”“可以用于原始值进行比较，也可以用于对象进行比较，当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中没有自动装箱发生。进行对象值比较不应该使用”“，而应该使用对象对应的equals方法。看一个能说明问题的例子。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoboxingTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// Example 1: == comparison pure primitive – no autoboxing</span>
        <span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i1==i2 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token comment">// Example 2: equality operator mixing object and primitive</span>
        <span class="token class-name">Integer</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// autoboxing</span>
        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;num1 == num2 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token comment">// Example 3: special case - arises due to autoboxing in Java</span>
        <span class="token class-name">Integer</span> obj1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// autoboxing will call Integer.valueOf()</span>
        <span class="token class-name">Integer</span> obj2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// same call to Integer.valueOf() will return same</span>
                            <span class="token comment">// cached Object</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;obj1 == obj2 : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>obj1 <span class="token operator">==</span> obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token comment">// Example 4: equality operator - pure object comparison</span>
        <span class="token class-name">Integer</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no autoboxing</span>
        <span class="token class-name">Integer</span> anotherOne <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;one == anotherOne : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> anotherOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>值得注意的是第三个小例子，这是一种极端情况。obj1和obj2的初始化都发生了自动装箱操作。但是处于节省内存的考虑，JVM会缓存-128到127的Integer对象。因为obj1和obj2实际上是同一个对象。所以使用”==“比较返回true。</p><hr><h2 id="_4-使用中需要注意的问题" tabindex="-1"><a class="header-anchor" href="#_4-使用中需要注意的问题" aria-hidden="true">#</a> 4. 使用中需要注意的问题</h2><ol><li>在程序中，如果写了需要不断拆箱和装箱的操作代码，会造成额外的系统开销，增加垃圾回收的压力</li><li>在自动拆箱和自动装箱过程中要注意默认值的问题（在拆箱过程中，如果使用了未初始化的对象，执行obj.xxxValue就会报NullPointerException异常）</li></ol><hr><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><p>Java中的拆箱和装箱机制便利了程序开发人员，减少了程序开发人员的工作量，使得基本数据类型和封装数据类型之间有一个高效快捷的桥梁。但是凡事都有两面性，在使用过程中一定要注意初始值问题和适用场景问题，切不可以随意任意使用。</p><h2 id="_2-泛型" tabindex="-1"><a class="header-anchor" href="#_2-泛型" aria-hidden="true">#</a> 2. 泛型</h2><hr><p>order: 1 author: zeanzai title: 泛型 category:</p><ul><li>Java编程语言</li></ul><hr><ol><li>这种技术出现的背景</li><li>泛型的使用方式</li><li>泛型的上下限</li><li>泛型的基本原理</li></ol><h2 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景" aria-hidden="true">#</a> 1. 背景</h2><p>早期 Java 语言规范中要求我们在使用 Java 时只能使用某一个具体类型，也就是说无法让类型作为参数，但事实上，某些业务场景中，确实需要类型作为参数，因此就产生了泛型。</p><p>比如说，某一个我们要实现一个两数之和相加的需求，Java 早期版本中我们只能这样实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">&quot;+&quot;</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">&quot;+&quot;</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">&quot;+&quot;</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候就发现，我们的代码是冗余的，其实核心代码就一句： a+b，但是早期 Java 语言规范中要求对 a 和 b 的类型必须是具体的，所以就只能在定义方法时就规定好 a 和 b 的类型，即 int、float、double。</p><p>JDK5 之后，Java 中引入了泛型的特性，完美解决了这一个问题。<strong>也就是说 JDK5 之后，类型也可以作为参数进行传递了</strong>。如上面求两数之和的需求就变成了这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">&quot;+&quot;</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码简要说明：</p><ol><li><strong><code>&lt;T extends Number&gt;</code></strong> 表示这个方法持有一个抽象类型 T，这个抽象类型 T 有一个限制：只能继承自 Number 类型；</li><li><strong><code>double</code></strong> 表示这个泛型方法的返回值为 double 类型；</li><li><strong><code>(T a, T b)</code></strong> 表示这个泛型方法有两个参数，这两个参数的类型都是抽象类型 T；</li></ol><h2 id="_2-应用" tabindex="-1"><a class="header-anchor" href="#_2-应用" aria-hidden="true">#</a> 2. 应用</h2><p>泛型特性可以应用于<strong>类</strong>、<strong>接口</strong>和<strong>方法</strong>上。但是具体的应用方式上有别于普通的类、接口和方法，具体体现在两个地方，<strong>定义</strong>和<strong>使用</strong>。 泛型的特征就一个<strong>尖括号：&lt;&gt;</strong>。尖括号内部，在<strong>定义时</strong>持有一个表示<strong>抽象类型的占位符</strong>；在<strong>使用时</strong>需要在尖括号内部<strong>传入具体的类型，表示使用时传入的具体的类型</strong>。如果有多个类型参数，则使用“,”分开。</p><ul><li>定义时： 在类名后面添加尖括号，尖括号内部是抽象类型占位符；</li><li>使用时： 构造类的某个具体实例时，在类名后面添加尖括号，尖括号内部是具体的类型；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 例1 //////////////////////////////////////////////////////</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span> <span class="token comment">// 定义时： 此处表示Point类为泛型类，类中持有一个抽象类型T，T是type的简称  </span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>     <span class="token comment">// var的类型由T指定，即：由外部指定  </span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 返回值的类型由外部决定  </span>
        <span class="token keyword">return</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setVar</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 设置的类型也由外部决定  </span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token operator">=</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericsDemo06</span><span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token class-name">Point</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用时：传入的是String，表示具体使用时用String类型，而不是其它类型</span>
        p<span class="token punctuation">.</span><span class="token function">setVar</span><span class="token punctuation">(</span><span class="token string">&quot;it&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>


<span class="token comment">// 例2 //////////////////////////////////////////////////////</span>
<span class="token keyword">class</span> <span class="token class-name">Notepad</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span> <span class="token comment">// 定义时： 此处表示Notepad类为泛型，类中持有两个抽象类型K和V，K表示Key，V表示value </span>
    <span class="token keyword">private</span> <span class="token class-name">K</span> key <span class="token punctuation">;</span> 
    <span class="token keyword">private</span> <span class="token class-name">V</span> value <span class="token punctuation">;</span> 
    <span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setKey</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericsDemo09</span><span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token class-name">Notepad</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Notepad</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用时：传入的两个类型具体为String和Integer</span>
        t<span class="token punctuation">.</span><span class="token function">setKey</span><span class="token punctuation">(</span><span class="token string">&quot;汤姆&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;姓名；&quot;</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;，年龄；&quot;</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span> <span class="token comment">// 定义时： 表示Info接口为泛型接口，持有一个抽象类型T</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>  
<span class="token keyword">class</span> <span class="token class-name">InfoImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span> <span class="token comment">// 定义时： 表示InfoImpl接口为泛型接口，也持有一个抽象类型T，并且实现了Info&lt;T&gt;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">InfoImpl</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setVar</span><span class="token punctuation">(</span><span class="token keyword">var</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setVar</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token operator">=</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericsDemo24</span><span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> arsg<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InfoImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;汤姆&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token comment">// 使用时： 传入的具体类为String，而不是其它类型</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;内容：&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">.</span><span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">&quot;+&quot;</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.0d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 说明：泛型方法与泛型类和泛型接口有些区别</span>
<span class="token number">1.</span>  <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> 表示这个方法持有一个抽象类型 <span class="token class-name">T</span>，这个抽象类型 <span class="token class-name">T</span> 有一个限制：只能继承自 <span class="token class-name">Number</span> 类型；
<span class="token number">2.</span> <span class="token keyword">double</span> 表示这个泛型方法的返回值为 <span class="token keyword">double</span> 类型；
<span class="token number">3.</span> <span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span> 表示这个泛型方法有两个参数，这两个参数的类型都是抽象类型 <span class="token class-name">T</span>；

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-1-抽象类型占位符" tabindex="-1"><a class="header-anchor" href="#_2-1-抽象类型占位符" aria-hidden="true">#</a> 2.1. 抽象类型占位符</h3><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的占位符，比如 T，E，K，V 等等，这些占位符又都是什么意思呢？ <strong>本质上这些个都是占位符，没啥区别，只不过是编码时的一种约定俗成的东西</strong>。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？是这样约定的</strong>：</p><ul><li>？表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h2 id="_3-类型擦除" tabindex="-1"><a class="header-anchor" href="#_3-类型擦除" aria-hidden="true">#</a> 3. 类型擦除</h2><p>Java 泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java 泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。</p><p>一句话：Java 源代码中使用泛型，但是编译阶段会把源代码中的泛型抽象类型转化成具体的原生数据类型，这个转化过程是自动和隐式的，这就是<strong>类型擦除</strong>。这样做的好处在于把对具体类型的感知延迟到编译阶段，使编码更加灵活。</p><p><strong>类型擦除原则</strong>：</p><ul><li>消除类型参数声明，即删除&lt;&gt;及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><h2 id="_4-泛型的限制" tabindex="-1"><a class="header-anchor" href="#_4-泛型的限制" aria-hidden="true">#</a> 4. 泛型的限制</h2><p>有了泛型之后，意味着我们可以传入一个抽象类型的占位符，然后在使用时再传入具体的某一个类型。这是不是也意味着我们在使用时，可以使用任意的某个具体类型？当然不是。那如果我们要求，使用时只能传入某一类的类型呢，该怎么实现呢？例如，上面“求两数之和”的需求，抽象类型就只能是数字类型的，不能是字符串类型的，因为字符串相加没有意义。这个需求中就要对抽象类型进行限制，并且限制为 Number 类型。由此看来，我们在某些业务场景下，也不得不限制泛型的范围，这就是<strong>泛型的限制</strong>。</p><p>限制的范围主要包括分为两部分：一个是<strong>上限</strong>，即限制泛型传入的抽象类型只能是某一具体类型子类；一个是<strong>下限</strong>，即限制泛型传入的抽象类型只能是某一类型的父类。</p><ul><li>**&lt;?&gt;：**无限制通配符</li><li><strong>&lt;? extends E&gt;：</strong> extends 关键字声明了类型的上限，表示参数化的类型可能是所指定的类型，或者是此类型的子类</li><li><strong>&lt;? super E&gt;：</strong> super 关键字声明了类型的下限，表示参数化的类型可能是指定的类型，或者是此类型的父类</li></ul><p>《Effictive Java》中的使用原则：为了获得最大限度的灵活性，要<strong>在表示 生产者或者消费者 的输入参数上使用占用符</strong>，使用的规则就是**： 生产者有上限、消费者有下限**</p><ol><li>如果抽象类型表示一个 T 的生产者，使用 &lt;? extends T&gt;;</li><li>如果它表示一个 T 的消费者，就使用 &lt;? super T&gt;；</li><li>如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token comment">// 此处泛型只能是数字类型</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>        <span class="token comment">// 定义泛型变量</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setVar</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token operator">=</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 直接打印</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> i1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token comment">// 声明Integer的泛型对象</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>        <span class="token comment">// 定义泛型变量</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setVar</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token operator">=</span> <span class="token keyword">var</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 直接打印</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">var</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericsDemo21</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> i1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token comment">// 声明String的泛型对象</span>
        <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> i2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token comment">// 声明Object的泛型对象</span>
        i1<span class="token punctuation">.</span><span class="token function">setVar</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        i2<span class="token punctuation">.</span><span class="token function">setVar</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token function">fun</span><span class="token punctuation">(</span>i1<span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token function">fun</span><span class="token punctuation">(</span>i2<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">Info</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> temp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>temp <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Staff</span> <span class="token operator">&amp;</span> <span class="token class-name">Passenger</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//工资低于2500元的上斑族并且站立的乘客车票打8折</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span> <span class="token number">2500</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span><span class="token function">isStanding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;恭喜你！您的车票打八折！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">discount</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Me</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>泛型的限制<strong>除了在定义时进行限制</strong>，使用时也要遵循一定的规则。</p><ol><li><p>泛型类中的静态变量和静态方法，不能使用泛型类声明的抽象类型占位符进行定义；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">T</span> one<span class="token punctuation">;</span>   <span class="token comment">//编译错误，不能使用抽象类型T定义静态变量one的类型，因为one的类型到使用时才确定下来；</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">T</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> one<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//编译错误，不能使用抽象类型T定义show()方法的范围值类型为T，因为T的类型要等到使用时才确定下来；</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> one<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//这是正确的，这个方法是泛型方法</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>抽象类型只能通过反射进行实例化，并且也只能通过反射来获取抽象类型的所属类型：</p></li><li><p>基本数据类型不能作为泛型，只能使用包装类型作为泛型的实参；</p></li></ol><h3 id="_4-1-和-t-的区别" tabindex="-1"><a class="header-anchor" href="#_4-1-和-t-的区别" aria-hidden="true">#</a> 4.1. ? 和 T 的区别</h3><p>既然 ？和 T 都可以表示不确定的类型，那它俩的区别在哪里？具体区别如下：</p><ol><li><p>T 可以确保泛型参数传入的抽象类型是一致的，？无法保证传入的抽象类型的一致性；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 通过 T 来 确保 泛型参数的一致性</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> dest<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span>

<span class="token comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> dest<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>T 可以进行多重限制，使 T 类型具有所有限定的方法和属性，但 ？ 不能进行多重限定；</p></li><li><p>T 只能限制上限或下限中的一种，？则既可以有上限也可以有下限；</p></li></ol><p>总结来说，最佳实践经验是： <strong>通常把 T 用在泛型类和泛型方法的定义上，而 ？用到调用和形参上，不用到定义上。</strong></p><h2 id="_5-实际的应用场景" tabindex="-1"><a class="header-anchor" href="#_5-实际的应用场景" aria-hidden="true">#</a> 5. 实际的应用场景</h2><ol><li>Java 中的 List 接口</li><li>接口的统一响应体</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 公用的响应对象
 * <span class="token keyword">@author</span> yaolh
 * <span class="token keyword">@version</span> 创建时间：2017/11/18 14:57
 */</span>
<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeResponse</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochMilli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span> <span class="token class-name">Integer</span> statusCode <span class="token operator">=</span> <span class="token class-name">StatusCode</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span> <span class="token class-name">Page</span> page<span class="token punctuation">;</span>
 <span class="token keyword">private</span> <span class="token class-name">Object</span> content<span class="token punctuation">;</span>
 
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">DeResponse</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DeResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">DeResponse</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">StatusCode</span> statusCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">DeResponse</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  response<span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span>statusCode<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">DeResponse</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> statusCode<span class="token punctuation">,</span><span class="token class-name">Object</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">DeResponse</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  response<span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span>statusCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  response<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">DeResponse</span> <span class="token function">createEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DeResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addContent</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token constant">EMPTY_LIST</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;WeakerAccess&quot;</span><span class="token punctuation">)</span>
 <span class="token keyword">public</span> <span class="token class-name">DeResponse</span> <span class="token function">addContent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">public</span> <span class="token class-name">DeResponse</span> <span class="token function">addPage</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> pageId<span class="token punctuation">,</span> <span class="token class-name">Integer</span> pageSize<span class="token punctuation">,</span> <span class="token class-name">Long</span> totalRecords<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token punctuation">(</span>pageId<span class="token punctuation">,</span> pageSize<span class="token punctuation">,</span> totalRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token annotation punctuation">@Data</span>
 <span class="token annotation punctuation">@AllArgsConstructor</span>
 <span class="token annotation punctuation">@NoArgsConstructor</span>
 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Page</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">Integer</span> pageId<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">Integer</span> pageSize<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">Long</span> totalRecords<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

<span class="token punctuation">}</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>@Data
@NoArgsConstructor
@AllArgsConstructor
public class KvPair&lt;K<span class="token punctuation">,</span> V&gt; <span class="token punctuation">{</span>
    private K k;
    private V v;

    public static List&lt;KvPair&gt; fromJson(String json) <span class="token punctuation">{</span>
        try <span class="token punctuation">{</span>
            return JSON.parseArray(json<span class="token punctuation">,</span> KvPair.class);
        <span class="token punctuation">}</span> catch (Exception e) <span class="token punctuation">{</span>

        <span class="token punctuation">}</span>
        return new ArrayList&lt;KvPair&gt;();
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-参考" tabindex="-1"><a class="header-anchor" href="#_6-参考" aria-hidden="true">#</a> 6. 参考</h2>`,88),B={href:"https://zhuanlan.zhihu.com/p/82457476",target:"_blank",rel:"noopener noreferrer"},F={href:"https://pdai.tech/md/java/basic/java-basic-x-generic.html",target:"_blank",rel:"noopener noreferrer"},W=t(`<h2 id="_3-注解" tabindex="-1"><a class="header-anchor" href="#_3-注解" aria-hidden="true">#</a> 3. 注解</h2><hr><p>order: 2 author: zeanzai title: 注解 category:</p><ul><li>Java编程语言</li></ul><hr><h2 id="_1-背景-1" tabindex="-1"><a class="header-anchor" href="#_1-背景-1" aria-hidden="true">#</a> 1. 背景</h2><p>JDK 提供了一套完整的代码运行的规范和实现【比如，jvm 中方法区中完成字节码的准备工作，之后在堆中完成引用的链接等，最后在栈上进行运行】，但是有些复杂的业务场景下需要自行控制代码的运行，比如想要完成子类对父类方法的重写，那么就需要在子类的重写方法上做标记，标记“这是对父类方法的重写”，不是别的什么方法，只有这样 jvm 才知道“哦，这是子类的实际应该运行的方法，而不是调用父类的方法”。</p><p>针对这种场景，最开始的解决方案是 XML 方式，即在项目中引入 xml 配置文件，在配置文件中做一下标识，然后就可以达到上面说的这种效果。</p><p>但随着项目越来越庞大，xml 配置文件变得越来越复杂，维护成本也越来越高，于是，人们又提出注解的配置方式。</p><h2 id="_2-注解-vs-xml" tabindex="-1"><a class="header-anchor" href="#_2-注解-vs-xml" aria-hidden="true">#</a> 2. 注解 vs XML</h2><ul><li>XML 会随着项目的膨胀，导致维护成本越来越高，效率较低；但这种方式耦合度较低；</li><li>注解方式耦合度较高，但是效率很高；</li></ul><h2 id="_3-注解的基本原理" tabindex="-1"><a class="header-anchor" href="#_3-注解的基本原理" aria-hidden="true">#</a> 3. 注解的基本原理</h2><blockquote><p>补充： .java 元代码文件需要通过编译之后生成 .class 字节码文件，之后 .class 字节码通过加载过程申请运行时的内存空间。 .java 元代码文件 编译 成 .class 字节码文件的过程，称为编译期； .class 字节码加载到内存空间的过程，称为加载期； 最终内存上的运行过程，称为运行期（runtime）；</p></blockquote><ul><li>我们可以把注解理解为： 注解只是一种标识代码实际意义的特殊代码，它强依赖于解析它的代码，如果没有解析它的代码，它可能连自然语言的注释还不如，因此理解注解关键点在于注解的解析代码。</li><li>解析注解的代码的实现方式有两种，一种是编译期直接扫描，另一种是运行期反射。 <ul><li>二者的不同在于解析逻辑作用的时机不同。</li><li>编译期直接扫描可以理解为，解析代码作用在编译期，即 jdk 会根据注解的实际内容生成实际可运行的 .class 字节码文件；</li><li>运行期反射可以理解为，解析代码作用在运行期，利用的是 Java 的反射机制，在运行期调用实际的代码逻辑时，通过生成一个目标注解的代理类，来执行注解代码的解析逻辑；</li></ul></li></ul><h2 id="_4-元注解" tabindex="-1"><a class="header-anchor" href="#_4-元注解" aria-hidden="true">#</a> 4. 元注解</h2><blockquote><p>元注解： 描述注解的注解。</p></blockquote><ul><li>@Target：注解的作用目标，方法上/类上/变量上 <ul><li>使用：@Target(value = {ElementType.FIELD})</li><li>ElementType 是一个枚举值： <ul><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ul></li></ul></li><li>@Retention：注解的生命周期，决定使用那种解析方式 <ul><li>使用： @Retention(value = RetentionPolicy.RUNTIME)</li><li>RetentionPolicy 是一个枚举值： <ul><li>RetentionPolicy.SOURCE：当前注解编译期可见，解析逻辑不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，解析逻辑会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，解析逻辑可以反射获取</li></ul></li></ul></li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><h3 id="_4-1-jdk-内建注解" tabindex="-1"><a class="header-anchor" href="#_4-1-jdk-内建注解" aria-hidden="true">#</a> 4.1. JDK 内建注解</h3><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><h3 id="_4-2-示例" tabindex="-1"><a class="header-anchor" href="#_4-2-示例" aria-hidden="true">#</a> 4.2. 示例</h3><blockquote><p>「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。 The common interface extended by all annotation types 所有的注解类型都继承自这个普通的接口（Annotation）。</p></blockquote><p>所以注解的本质就是一个继承了 Annotation 接口的接口。</p><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>// 这是注解 @Override 的定义，
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}


// 其实它本质上就是：
public interface Override extends Annotation{
    
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+r+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+d+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><blockquote><p>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</p></blockquote><p>最后我们再总结一下整个反射注解的工作原理：</p><ol><li>首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = &quot;hello&quot;）。</li><li>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</li><li>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</li><li>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。</li></ol><p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，通过方法名返回注解属性值。</p><h2 id="自定义注解" tabindex="-1"><a class="header-anchor" href="#自定义注解" aria-hidden="true">#</a> 自定义注解</h2><p>比如 设置一个 分布式锁 的注解，参考：</p>',32),U={href:"https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/java/annotation/%E6%83%B3%E8%87%AA%E5%B7%B1%E5%86%99%E6%A1%86%E6%9E%B6%E4%B8%8D%E4%BC%9A%E5%86%99Java%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%B8%8D%E8%A1%8C.md",target:"_blank",rel:"noopener noreferrer"},G=n("h2",{id:"_5-参考",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_5-参考","aria-hidden":"true"},"#"),s(" 5. 参考")],-1),X={href:"https://juejin.cn/post/6844903636733001741",target:"_blank",rel:"noopener noreferrer"},Q=t('<h2 id="_4-异常" tabindex="-1"><a class="header-anchor" href="#_4-异常" aria-hidden="true">#</a> 4. 异常</h2><h2 id="_5-集合" tabindex="-1"><a class="header-anchor" href="#_5-集合" aria-hidden="true">#</a> 5. 集合</h2><blockquote><p>集合相关的内容多从数据结构的角度进行面试。而数据结构包括两部分的内容，存储和算法。存储上又分为逻辑结构和物理结构。算法就是操作存储在硬盘或内存中的数据的过程或步骤。</p><p><code>因此我们在回答集合方面的面试题时，要从数据结构的角度来回答。</code></p></blockquote><p>分成单列集合和双列集合，分别对应两个顶级接口： Collection 和 Map。</p><p>Collection中有两个重要接口：</p><ul><li>List： 允许元素重复，允许保存多个Null元素，并且有序（存入顺序与实际存储顺序一致），具体实现有 ArrayList 、 LinkedList 、 Vector ；</li><li>Set： 不允许元素重复，只允许保存一个Null，并且是无序的（存入顺序与实际存储顺序不一致），具体实现有 HashSet 、 LinkedHashset 、 TreeSet ；</li></ul><p>Map下面主要有HashMap、Hashtable、TreeMap、LinkedHashMap等实现；</p><p>还有两个遍历器。</p><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><p>允许元素重复。</p><h3 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h3><ol><li>数组组成，内存规整，可以快速读取和修改，增加和删除需要进行复制，速度较慢；</li><li>默认10，可以指定容量（初始化容量+另一个list进行初始化）；</li><li>缩扩容原理（扩容为原来的1.5倍，使用复制的方式进行缩容或者扩容）；</li><li>不支持同步，但是可以Collections.synchronizedList(aList)变成同步；</li><li>Fast-Fail机制，使用modNum标识版本，避免读写过程中的并发问题；</li><li>实现了Random接口，可以实现随机访问；</li><li>适合随机读写和遍历；</li></ol><h3 id="vector" tabindex="-1"><a class="header-anchor" href="#vector" aria-hidden="true">#</a> Vector</h3><ol><li>也是数组实现，但是支持同步，同步机制是通过重量级锁Synchronize实现的，性能较差，目前已经被jdk废弃；</li><li>扩容为原来的2倍；</li></ol><h3 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist" aria-hidden="true">#</a> LinkedList</h3><ol><li>双向链表，内存不规整，增删快，查改慢；</li><li>缩扩容只需要修改链表的指向即可；</li><li>不支持同步；</li><li>不支持快速随机读写；</li></ol><h2 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h2><p>不允许元素重复。</p><h3 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset" aria-hidden="true">#</a> HashSet</h3><ol><li>保存的内容为不重复的内容；本质上是数组+链表的方式进行存储的；</li><li>在添加元素时，会先计算元素的hashcode值，然后去数组上找到hash桶的位置，之后再使用元素的值一一比对同一个hash桶上的其他元素，如果相等就不做任何操作，如果没有相等的，就顺延插入；</li><li>由于添加元素的操作的限制，因此HashSet的泛型参数要进行相等判断，即需要实现自定义的判断对象相等的hashcode方法和equals方法；并且由于添加元素的操作原理可知，添加的顺序与实际保存到内存中的顺序并不一致；</li></ol><h3 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset" aria-hidden="true">#</a> TreeSet</h3><ol><li>数据结构为二叉树，可以对每一个添加的元素进行排序；</li><li>保存的内容为有序的内容，因此自定义的泛型参数需要实现Comparable接口，并覆写compareTo()方法，并且要返回负数、零或正整数；</li></ol><h3 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset" aria-hidden="true">#</a> LinkedHashset</h3><ol><li>是基于HashSet和LinkedHashMap实现的；保存数据的方式与LinkedHashMap一致，操作数据的方式与HashSet一致；</li></ol><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><h3 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h3><ol><li>三点变化</li></ol><ul><li>数据结构发生变化，原来的数组+链表，变成数组+链表或红黑树；</li><li>entry变成node，头插法变成尾插法，解决并发写时的循环链表问题；</li><li>put方法发生变化，多了一个判断链表长度的条件，链表长度&gt;8，就转化为红黑树，node个数&lt;6就退化为链表；</li></ul><ol start="2"><li>构造方法中的三个参数：初始化容量（默认16），负载因子（默认0.75），扩容阈值（初始化容量*负载因子，默认12）</li><li>put方法： 先判断是否需要执行扩容，如果不需要就计算key的hashcode，然后找到hash桶的坐标，也就是数组的索引，之后再把元素插到链表或者红黑树的节点上；</li><li>get方法： 先计算hash桶坐标，之后再遍历链表或红黑树来判断值是否相等；</li><li>扩容机制： 扩容为原来的两倍；</li><li>同步机制： 不支持同步，但是可以使用Collections.synchronizedMap(hashMap)进行同步；</li></ol><h3 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable" aria-hidden="true">#</a> Hashtable</h3><ol><li>存储上，既不支持null-key，又不支持null-value；扩容时，扩容为2n+1；</li><li>迭代器是Enumerator，不支持fast-failed机制；</li><li>继承自Dictionary类；</li><li>是线程安全的，但是同步效率很低，同步时多用ConcurrentHashMap，而不是Hashtable</li></ol><h3 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap" aria-hidden="true">#</a> TreeMap</h3><ol><li>通过红黑树实现的有序键值对集合，是通过实现了SortedMap接口，来使其具有根据key进行排序的能力；</li><li>在使用时，传入的key要实现Comparable接口或构造时传入自定义的Comparator；</li></ol><h3 id="linkedhashmap" tabindex="-1"><a class="header-anchor" href="#linkedhashmap" aria-hidden="true">#</a> LinkedHashMap</h3><ol><li>是根据插入顺序排序的键值对集合，即内存中的排列顺序就是插入的顺序；</li><li>也可以在构造时传入参数，使其按照访问次数排序；</li><li>是HashMap的一个子类，具有和HashMap一样的查询效率；</li></ol><h3 id="weakhashmap" tabindex="-1"><a class="header-anchor" href="#weakhashmap" aria-hidden="true">#</a> WeakHashMap</h3><ol><li>其中的Entry继承自弱引用WeakReference，用来实现类似缓存的功能；</li></ol><p>集合，有些人也称容器，研究这块内容的时候，可以类比研究某一个框架的方法来研究之。</p><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h2><p>先来看一下jdk中集合的类图：</p><p><img src="'+k+'" alt="image.png" loading="lazy">先根据集合大图来看下集合中都包括哪些内容：</p><ul><li>集合有两个顶级接口 <ul><li>Collection <ul><li>保存单列元素数据</li><li>包含两个子接口 <ul><li>List： 保存的元素顺序为<code>有序</code></li><li>Set： 保存的元素顺序为<code>无序</code></li></ul></li><li>具体实现类 <ul><li>List接口有： <code>ArrayList</code>、 <code>LinkedList</code>、 <code>Vector</code>（以及Vector的子类 <code>Stack</code>）</li><li>Set接口有： <code>HashSet</code>、 <code>TreeSet</code></li></ul></li></ul></li><li>Map <ul><li>保存双列元素数据， 即保存(key, value)键值对形式的数据元素</li><li>具体实现类： <code>HashMap</code> 、 <code>TreeMap</code> 、 <code>WeakHashMap</code> 、 <code>Hashtable</code></li></ul></li></ul></li></ul><h2 id="_2-基本原理" tabindex="-1"><a class="header-anchor" href="#_2-基本原理" aria-hidden="true">#</a> 2. 基本原理</h2><h3 id="_2-1-list" tabindex="-1"><a class="header-anchor" href="#_2-1-list" aria-hidden="true">#</a> 2.1. List</h3><figure><img src="'+m+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><strong>list具有有序性（存入的顺序与存储的顺序一致），不具备唯一性，元素可以重复，可以插入多个 null 元素，并且每一元素都有索引下标。它包含了 ArrayList 、 Vector 、 LinkedList 三个最重要的实现类。</strong></p><h4 id="_2-1-1-arraylist" tabindex="-1"><a class="header-anchor" href="#_2-1-1-arraylist" aria-hidden="true">#</a> 2.1.1. ArrayList</h4><ul><li><code>底层数据结构</code><ul><li>Object[] 数组（Java中的数组是引用数据类型，它指向jvm的堆内存中的存放数组元素的开始位置）；</li></ul></li><li><code>默认容量</code><ul><li>ArrayList默认最小容量是10，默认最大容量是 MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</li></ul></li><li><code>初始化原理</code><ul><li>如果使用无参构造方法，就初始化为 Object[10] ，数组内元素为空，即初始化为 长度为10的空对象数组</li><li>如果初始化时一开始指定了容量，则容量为指定的大小 bList = new ArrayList&lt;&gt;(25)， 则 bList 的大小为25</li><li>如果通过集合初始化，则容量为集合的大小，如 bList = new ArrayList&lt;&gt;(aList)，其中 aList 的大小为16，则 bList 的大小为16</li></ul></li><li><code>扩容原理</code><ul><li>每次扩容为原来的1.5倍，如果新增后超过这个容量，则容量为新增后所需的最小容量，如 预计本次扩容后容量为30，但是新增的数据容量加上之前的数据容量为45，超过预计扩容后的30，则扩容后的实际容量45</li><li>如果增加0.5倍后的新容量超过限制的容量 （也称默认最大容量，即 Integer.MAX_VALUE - 8），则用所需的最小容量与限制的容量进行判断，超过则指定为Integer的最大值，否则指定为限制容量大小</li><li>最后通过数组的复制将原数据复制到一个更大(新的容量大小)的数组</li></ul></li><li><code>扩容效率</code>： 还是很高的 <ul><li>1千需要分配 11次</li><li>1万一级需要分配17次</li><li>10万 需要分配23次</li><li>100万需要分配28次</li></ul></li><li><code>缩容原理</code><ul><li>使用System.copyArrays()方法</li></ul></li><li><code>常用方法</code><ul><li>方法大图</li></ul></li></ul><figure><img src="'+v+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+h+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li>增 <ul><li>add(E)： 添加一个元素</li><li>add(int, E)： 在int位置添加一个元素</li><li>addAll(Collection&lt;?&gt;)： 往list中插入集合</li><li>addAll(int, Collection&lt;?&gt;)： 在int位置插入一个集合</li><li>删 <ul><li>clear()： 删除全部， 底层是把使用for遍历数组，把每一个元素都置为空</li><li>remove(int)： 删除某下标元素</li><li>remove(Object)： 删除某元素</li><li>removeRange(int, int)： 删除连续的一组元素</li><li>removeAll(Collection&lt;?&gt;)： 传入一个List中包含的集合，删除它</li></ul></li><li>改 <ul><li>set(int, E)： 把int位置上的元素设置为E</li></ul></li><li>查 <ul><li>get(int)： 根据下标获取元素</li></ul></li><li>遍历 <ul><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>Iterator 迭代器遍历。 Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li><li>ListIterator 遍历。 list 和 set 都实现了 Iterator 接口，但是 list 又实现了 ListIterator 接口。</li></ul></li></ul></li><li><code>由源码得出的其它特点</code><ul><li><code>内存特点</code>： 内存规整</li><li><code>操作方法特点</code>： 增删需要数组拷贝，效率低；修改和查询较快，效率高；</li><li><code>同步特点</code>： 不支持线程同步，即属于非线程安全的类。但是可以使用 <code>**Collections.synchronizedList(aList)**</code> 把ArrayList变成线程安全类，或者直接使用 <code>**CopyOnWriteArrayList**</code> 进行线程同步</li><li><code>Fail-Fast机制</code>：使用modNum来来控制，假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制；这种机制是早期为了平衡集合性能和线程同步而引入的，目的就是为了弥补集合中不支持线程同步的问题</li></ul></li><li><code>最佳实践</code>： <ul><li>如果知道集合元素个数，建议使用带参构造方法【ArrayList(int)】进行初始化，这样避免多次扩容缩容影响性能；</li><li>因为实现了 RandomAccess 接口，所以建议优先使用 for 遍历元素， 时间复杂度为 O(1)</li><li>适合随机查询或遍历，插入和删除较慢；</li></ul></li></ul><h4 id="_2-1-2-linkedlist" tabindex="-1"><a class="header-anchor" href="#_2-1-2-linkedlist" aria-hidden="true">#</a> 2.1.2. LinkedList</h4><p>这里通过类比来学习， LinkedList 与 ArrayList 的区别：</p><ul><li><code>存储结构</code>： ArrayList 是对象数组， LinkedList 是双向列表（1.7之前是双向循环链表，1.7取消了循环），存储同样元素下， LinkedList 空间占用比 ArrayList 多，因为 LinkedList 还要保存指针元素；</li><li><code>同步特性</code>： 二者都不支持线程同步，即非线程安全的</li><li><code>插入和删除是否受存储位置影响</code><ul><li>ArrayList 受存储位置影响 <ul><li>以 O(1) 的时间复杂度在列表末尾追加（或删除）元素</li><li>以 O(n-i) 的时间复杂度在列表第i个位置插入（或删除）数据，因为需要移动i之后的所有数据</li></ul></li><li>LinkedList 不受存储位置的影响 <ul><li>以 O(1) 的时间复杂度在列表末尾追加（或删除）元素</li><li>以 O(n) 的时间复杂度在列表第i个位置插入（或删除）数据，因为要遍历到第i个位置，然后执行操作</li></ul></li></ul></li><li><code>是否支持快速随机访问</code>： ArrayList 支持快速随机访问， LinkedList 不支持，但二者都实现了 ListIterator 接口，而 Set 没有实现</li></ul><figure><img src="'+b+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+g+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="_2-1-3-vector" tabindex="-1"><a class="header-anchor" href="#_2-1-3-vector" aria-hidden="true">#</a> 2.1.3. Vector</h4><p>还是通过类比的方式来学习， Vector 与 ArrayList 的区别：</p><ul><li>存储结构： 二者都是对象数组</li><li>同步机制： ArrayList 不支持同步， Vector 支持同步（是Java的古早类，比 ArrayList 多了个 synchronized ，官方已经不建议使用）</li><li>扩容机制： ArrayList 扩容为原来的1.5倍， Vector 扩容为原来的2倍；</li><li>迭代器不同： ArrayList 是 Iterator ， Vector 是 Enumerator；</li></ul><h3 id="_2-2-map" tabindex="-1"><a class="header-anchor" href="#_2-2-map" aria-hidden="true">#</a> 2.2. Map</h3><figure><img src="'+y+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>map用来存放键值对。包含了 <code>HashMap</code> 、 <code>Hashtable</code> 、 <code>TreeMap</code> 、 <code>LinkedHashMap</code> 、 <code>WeakHashMap</code> 几个重要的实现类。键均不可重复，但是值可以重复；</p><h4 id="_2-2-1-hashmap" tabindex="-1"><a class="header-anchor" href="#_2-2-1-hashmap" aria-hidden="true">#</a> 2.2.1. HashMap</h4><ul><li>Java7实现 <ul><li><code>基本数据结构</code>是： Entry 的数组，而 Entry 中又有一个next引用，指向下一个Entry，整体看起来是一个 数组 + 链表 的数据结构，其实本质上是一个数组；</li><li></li></ul></li></ul><figure><img src="'+f+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li><code>相关属性及默认值</code></li><li>初始化容量 DEFAULT_INITIAL_CAPACITY ： 16</li><li>装载因子 DEFAULT_LOAD_FACTOR ： 0.75</li><li>扩容的阈值 threshold ： capacity * load factor</li><li><code>构造方法</code>： 有四个初始化构造方法，主要都是给 loadFactor 和 initialCapacity 两个属性的赋值，而底层的数据结构的初始化则是在put值时才进行的初始化；</li><li><code>数据结构</code>： 数组 + 单向链表</li><li><code>put(pKey, pValue)原理</code>： <ul><li>先对key进行hashcode操作，找到对应的数组位置，将该key对应的Entry（链表节点的数据结构为Entry）放进去数组，具有相同hashcode值得Entry为同一个位置，不同的值以单向链表的方式存放，存放时以插头法存放，多线程条件下，有可能会出现循环链表的情况（我们知道只要put，就有可能扩容，只要扩容，就有大概率需要重新hash，重新hash时，假设线程A在rehash时算出来有一个EntryA指向了EntryB，而线程B在rehash时算出来EntryB指向EntryA，这就导致了一个循环链表），这种情况会导致多线程并发读时出现死锁的情况</li></ul></li><li><code>get原理</code>： 先比对hashcode是否相同，相同后使用equals方法判断值是否相同，相同的话就可以获取指定元素，查找的时间复杂度为O(n)</li><li><code>扩容机制</code>： 扩容为原来的2倍，扩容后会重新计算hashcode的值。</li><li><code>同步特性</code>： 不支持线程同步，即非线程安全</li><li>Java8实现 <ul><li><code>相关属性及默认值</code><ul><li>树化最小值： 默认为64， 表示数组在转化成红黑树的过程中，如果数组中长度小于64，会先扩容数组；</li></ul></li><li><code>hash函数发生变化</code>：相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动），分布更加均匀，性能更好 <ul><li>在1.8中，是调用了key的父类Object的hashcode方法获取hashcode，然后用hashcode进行1次位运算和1次异或运算</li><li></li></ul></li></ul></li></ul><p><img src="'+w+'" alt="image.png" loading="lazy"> - <code>put方法发生变化</code>：</p><ul><li>1.8会多了链表长度的判断，如果链表长度超过8，就会自动转化为红黑树； 如果hash槽的元素个数小于6时，会退化为链表；</li><li></li></ul><figure><img src="'+_+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li><code>数据结构发生变化</code>：</li><li>数组中的元素由1.7的 entry 变成了1.8的 node</li><li>头插法变成尾插法：解决了循环链表的问题</li><li>1.7时数组+单向链表，变成了1.8中的数组 + 单向链表 + 红黑树，优化了hash冲突后的查询效率，单向链表的查询效率是O(n)，而1.8链表长度超过8，就会自动转化为红黑树，红黑树是一种二叉查找树，查询效率为O(logn)，查询效率更高</li><li></li></ul><figure><img src="'+x+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li><code>遍历方法</code>： 都是调用底层的Itrator迭代器</li><li><code>同步特性</code>： 同样不支持线程同步，同样支持 fast-fail 机制</li><li>实际应用 <ul><li><code>初始化可以指定初始化容量，也可以指定负载因子</code><ul><li>指定初始化容量： 如果知道业务的数据量，最好是使用带一个参数的构造函数来初始化hashmap，即制定初始化hashmap的容量，并且这个容量最好是2的幂次方；如果自定义容量不是2的幂次方，程序会通过 tableSizeFor(int cap) 方法初始化容量为2的幂次方（如，初始化容量为7，不是2的幂次方，tableSizeFor(7)方法会找到大于这个初始化容量值最小的2的幂次方8；再如，初始化容量为15，不是2的幂次方，tableSizeFor(15)就会找到大于这个初始化容量值最小的2的幂次方16，再如：tableSizeFor(30)=tableSizeFor(31)=tableSizeFor(32)=32）</li><li>指定负载因子： 两个参数的构造函数，除了指定初始化容量外，还指定了负载因子，但是实际中，负载因子默认即可，如果真的有必要，我们可以通过调节负载因子的大小来影响hashmap的行为： <ul><li>当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键与键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间</li><li>相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间</li></ul></li></ul></li><li><code>使用任何对象作为key</code><ul><li>是可以使用任何对象作为key的，但是前提是这些对象要实现重写object的hashcode()方法和equals()方法</li></ul></li></ul></li><li>面试题 <ul><li>为什么初始化容量为16？ <ul><li>这应该是一个经验值，可以是8，也可以是32，如果是16且负载因子为0.75的话，根据泊松分布，7是分界岭，小于7（即小于等于6）应该使用链表；大于7（即大于等于8）应该变成红黑树；</li></ul></li><li>HashMap 中几个关键属性为什么都用 transient 关键字修饰？ <ul><li>这是为了在序列化时，为了节省空间，只需要把不为空的Node元素序列化即可。</li></ul></li><li>能否使用任何类作为HashMap的key？应该注意什么？ <ul><li>可以，但是这些类要重写hashcode()方法和equals()方法</li></ul></li><li>1.8中为什么HashMap中数组长度要是2的幂次方？ <ul><li>因为put操作时，是用 hashcode 和 （数组长度-1） 做 “与” 运算的出数组下标的，而实际上在计算数组下标位置时，只需要用hashcode对数组长度做除留余数法就可以得到数组下标，而当数组长度为2的幂次方时，用hashcode对数组长度做除留余数法就等价于 hashcode 和 （数组长度-1） 做 “与” 运算，并且“与”运算的性能更好，因此数组长度为2的幂次方。</li></ul></li></ul></li></ul><ol><li>散列算法： 把一串数据变成固定长度的一种算法</li><li>负载因子： 数组中实际的元素个数 / 数组所能容纳的元素个数 ， 负载因子大于0，负载因子越大代表数组元素越多，冲突也就越多，put和get的性能也就越差，但是节省存储空间；负载因子越小代表数组中元素越少，冲突也就越少，put和get的性能也就越好，但是浪费存储空间</li></ol><h4 id="_2-2-2-hashtable" tabindex="-1"><a class="header-anchor" href="#_2-2-2-hashtable" aria-hidden="true">#</a> 2.2.2. Hashtable</h4><p>这里类比 HashMap 来学习，二者的区别主要有：</p><ul><li>默认值不一样： Hashtable 默认初始化容量为 11， 扩容为2n+1； HashMap 默认初始化容量为16， 扩容为2n；</li><li>对Null的支持不一样： Hashtable 既不允许null的key，也不允许null的value； HashMap 只允许一个null的key，允许多个null的value；</li><li>同步特性不一样： Hashtable 支持线程同步，即线程安全，但是效率很低； HashMap 不支持线程同步，效率略高</li><li>基类不同： Hashtable 继承至 Dictionary 类， HashMap 继承至 AbstractMap 类，</li><li>迭代器不同： Hashtable 的迭代器是 Enumerator ，它不是 fail-fast 的； HashMap 的迭代器是 Iterator ，支持 fail-fast 机制；</li></ul><h4 id="_2-2-3-treemap" tabindex="-1"><a class="header-anchor" href="#_2-2-3-treemap" aria-hidden="true">#</a> 2.2.3. TreeMap</h4><ul><li>保存内容： 有序的K-V键值对集合，通过红黑树实现</li><li>实现： 实现了SortedMap接口和NavigableMap接口 <ul><li>实现 SortedMap 接口让 TreeMap 具有了根据键排序的能力，默认根据key的升序顺序进行排序，也可以根据构造时传入的 Comparator 进行排序； 使用 Iterator 遍历时，得到的记录是排过序的；</li><li>实现 NavigableMap 接口让 TreeMap 具有了对集合内元素搜索的能力</li></ul></li><li>同步特性： 不支持线程同步，即线程不安全的；</li></ul><h4 id="_2-2-4-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#_2-2-4-linkedhashmap" aria-hidden="true">#</a> 2.2.4. LinkedHashMap</h4><ul><li>保存了记录的插入顺序，新得到的肯定是先插入的，继承自HashMap，因此具有和HashMap一样的查询效率。</li><li>内部维护了一个双向链表，用来维护插入顺序</li></ul><h4 id="_2-2-5-weakhashmap" tabindex="-1"><a class="header-anchor" href="#_2-2-5-weakhashmap" aria-hidden="true">#</a> 2.2.5. WeakHashMap</h4><ul><li>WeakHashMap的Entry继承自WeakReference（弱引用类，会在下一次垃圾回收时被回收），主要用来实现缓存。</li><li>Tomcat中的ConcurrentCache使用了WeakHashMap来实现缓存；</li></ul><h3 id="_2-3-set" tabindex="-1"><a class="header-anchor" href="#_2-3-set" aria-hidden="true">#</a> 2.3. Set</h3><p><img src="'+T+'" alt="image.png" loading="lazy"><strong>set具有无序性（存入的顺序与实际存储的顺序不一致），具有唯一性，元素不能重复，只允许插入一个 null 元素。它包含了 HashSet 、 LinkedHashSet 、 TreeSet 三个重要的实现类。</strong></p><p>每个 Set 的底层实现其实就是对应的 Map：数值放在 map 中的 key 上，value 上放了个 PRESENT，是一个静态的 Object，相当于 place holder，每个 key 都指向这个 object。</p><h4 id="_2-3-1-hashset" tabindex="-1"><a class="header-anchor" href="#_2-3-1-hashset" aria-hidden="true">#</a> 2.3.1. HashSet</h4><ul><li><code>底层实现</code>： 基于 HashMap 实现， 值放到 HashMap 的key上面， HashMap 的值同一为present； 实现较为简单，基本上都是调用底层 HashMap 的相关方法完成的；不允许存放重复元素；</li><li>使用add添加元素，存储元素的位置并不是按照存入时的位置，而是按照散列算法求取的的哈希值来存放的，即元素的hashcode方法；hashcode值相等的元素会放到同一个位置上，再使用equals方法判断值是否一致，如果一致就不再存储，如果不一致会在同样的哈希值下顺延；</li><li><code>其它特点</code>：存放位置无序；</li><li>判断重复性： 先判断hashcode是否相等，如果相等就判断值是否相等，如果两个都相等，那就是重复了</li></ul><h4 id="_2-3-2-linkedhashset" tabindex="-1"><a class="header-anchor" href="#_2-3-2-linkedhashset" aria-hidden="true">#</a> 2.3.2. LinkedHashSet</h4><ul><li><code>底层实现</code>：继承于 HashSet ，基于 LinkedHashMap 实现，底层使用 LinkedHashMap 保存所有元素，类似于 HashSet 使用 HashMap 保存元素一样，同样可以可以直接调用 HashSet 的方法；</li><li>可以直接调用 HashSet 的方法，具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序；</li></ul><h4 id="_2-3-3-treeset" tabindex="-1"><a class="header-anchor" href="#_2-3-3-treeset" aria-hidden="true">#</a> 2.3.3. TreeSet</h4><ul><li><code>底层原理</code>：红黑树实现；查找的时间复杂度为O(logN)；每次新增一个元素时，都会进行排序；</li><li><code>其它特点</code>：有序性</li><li><code>备注</code>：为保证有序性，Integer和String对象使用默认的排序规则，自定义的类则需要实现Comparable接口，并重写compareTo()函数；</li></ul><h3 id="_2-4-queue" tabindex="-1"><a class="header-anchor" href="#_2-4-queue" aria-hidden="true">#</a> 2.4. queue</h3><p>queue 作为顶级接口，表示队列。</p><ul><li>ArrayDeque： 用来实现栈，可以先进后出；也可以用来实现队列，先进先出；</li><li>LinkedList： 用来实现双向队列，可以先进先出；</li><li>PriorityQueue： 基于堆结构实现，可以用它来实现优先队列；</li></ul><h2 id="_3-其他" tabindex="-1"><a class="header-anchor" href="#_3-其他" aria-hidden="true">#</a> 3. 其他</h2><ul><li>Lists工具类： 主要是针对List接口实现的类而提供的工具类。常用的有： Lists.asLists()</li><li>Collections工具类： 主要提供一些通用的方法； <ul><li>Collections.unmodifiableCollection()</li><li>Collections.synchronizedList()</li></ul></li><li>Iterator迭代器： 迭代器</li></ul><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4. 总结</h2><ul><li>集合与数组的区别 <ul><li>存放的内容不同 <ul><li>数组中可以存放基本数据类型，也可以存放引用类型；但集合中就只能存放引用类型；</li></ul></li><li>长度不同 <ul><li>数组长度确定下来之后不可以改变，集合长度可以动态改变；</li></ul></li></ul></li><li>学习集合容器的方法 <ul><li>DSA（数据结构与算法） <ul><li>在内存空间的存储结构</li><li>操作方法及时间复杂度 <ul><li>常规操作： 增、删、改、查</li><li>特殊操作： 遍历、排序、替换、分割</li></ul></li></ul></li><li>线程特性： 是否是线程安全的，如果不是线程安全的，如何保证线程安全？</li><li>使用场景（各个实现子类有什么区别，分别适用于哪些业务场景）</li></ul></li><li>集合容器： 存放的内容本质上都是引用类型 <ul><li>实现大图 <ul><li>单列集合 Collection <ul><li>接口，存放元素为单一元素，存放的内容为引用类型；</li><li>子接口及各自实现类 <ul><li>List <ul><li>ArrayList</li><li>LinkedList</li><li>CopyOnWriteArrayList</li></ul></li><li>Set <ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li><li>Queue <ul><li>PriorityQueue</li><li>ArrayDeque</li><li>PriorityQueue</li></ul></li></ul></li></ul></li><li>双列集合 Map <ul><li>接口，存放元素为类似于key-value类型的元素，对象引用类型</li><li>实现类 <ul><li>HashMap</li><li>ConcurrentHashMap</li><li>HashTable</li><li>TreeMap</li></ul></li></ul></li></ul></li><li>容器工具类 <ul><li>Collections <ul><li>同步方法</li></ul></li><li>Iterator</li><li>排序</li><li>序列化</li></ul></li></ul></li></ul><h2 id="_5-参考-1" tabindex="-1"><a class="header-anchor" href="#_5-参考-1" aria-hidden="true">#</a> 5. 参考</h2>',99),Y={href:"https://blog.csdn.net/zymx14/article/details/78324464",target:"_blank",rel:"noopener noreferrer"},Z=n("li",null,"字节大神的Java笔记.pdf",-1),$=n("li",null,"Java集合框架常见面试题.pdf",-1),nn=n("li",null,"Java集合面试题52道.pdf",-1),sn={href:"https://tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/",target:"_blank",rel:"noopener noreferrer"},an={href:"https://mp.weixin.qq.com/s/0Gf2DzuzgEx0i3mHVvhKNQ",target:"_blank",rel:"noopener noreferrer"},en={href:"https://mp.weixin.qq.com/s/bVOSat47L0Hskfx9akAN6Q",target:"_blank",rel:"noopener noreferrer"},tn={href:"https://mp.weixin.qq.com/s/ktre8-C-cP_2HZxVW5fomQ",target:"_blank",rel:"noopener noreferrer"},pn={href:"https://mp.weixin.qq.com/s/My4P_BBXDnAGX1gh630ZKw",target:"_blank",rel:"noopener noreferrer"},ln={href:"https://github.com/AobingJava/JavaFamily",target:"_blank",rel:"noopener noreferrer"},on=n("h2",{id:"_6-io",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_6-io","aria-hidden":"true"},"#"),s(" 6. IO")],-1),cn=n("hr",null,null,-1),un=n("p",null,"order: 2 author: zeanzai title: IO category:",-1),rn=n("ul",null,[n("li",null,"Java编程语言")],-1),dn=n("hr",null,null,-1),kn=n("p",null,"测试修改logo后",-1);function mn(vn,hn){const a=i("ExternalLinkIcon");return l(),o("div",null,[S,n("p",null,[A,j,s(" OLTP是传统的"),n("a",I,[s("关系型数据库"),e(a)]),s("的主要应用，主要是基本的、日常的事务处理，记录即时的增、删、改、查，比如在银行存取一笔款，就是一个事务交易。 也称为实时系统(Real time System)。衡量联机事务处理系统的一个重要性能指标是系统性能，具体体现为实时响应时间(Response Time)，即用户在终端上送入数据之后，到计算机对这个请求给出答复所需要的时间。 "),O,s(" 1、实时性要求高； OLTP "),n("a",E,[s("数据库"),e(a)]),s("旨在使事务应用程序仅写入所需的数据，以便尽快处理单个事务。 2、数据量不是很大； 3、交易一般是确定的，所以OLTP是对确定性的数据进行存取(比如存取款都有一个特定的金额)； 4、支持大量并发用户定期添加和修改数据。 并发性要求高并且严格的要求事务的完整、安全性 (比如这种情况：有可能你和你的家人同时在不同银行取同一个帐号的款)。")]),M,n("p",null,[q,s(" 所谓数据仓库是对于大量已经由OLTP形成的历史数据加工与分析，读取较多，更新较少的一种分析型的数据库，用于处理商业智能、决策支持等重要的决策信息。 "),H,s(" OLAP即联机分析处理，是数据仓库的核心部心，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。典型的应用就是复杂的动态"),n("a",P,[s("报表"),e(a)]),s("系统。 有兴趣的朋友不妨到科研、教育、文化和卫生系统去看一看，他们那里一般都有一个叫做SPSS(世界上最早的统计分析软件)的统计分析软件，其菜单上有一个“分析”项目，其下拉的第一个项目就是OLAP。 "),C,s("： 1、实时性要求不是很高，很多应用顶多是每天更新一下数据； 2、数据量大，因为OLAP支持的是动态查询，所以用户也许要通过将很多数据的统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大； 3、因为重点在于决策支持，所以查询一般是动态的，也就是说允许用户随时提出查询的要求。于是在OLAP中通过一个重要概念“维”来搭建一个动态查询的平台（或技术），供用户自己去决定需要知道什么信息。 "),V,s(" 1、Hyperion(已被Oracle收购)EssbaseOLAPServer 2、Cognos(已被Oracle收购) PowerPlay为商务效率评价BPM（BusinessPerformanceMeasurement）提供全面的报告和分析环境。向决策者提供企业运行效率的各种关键数据，进行各种各样的分析。 3、BusinessObjects是易用的BI工具，允许用户存取、分析和共享数据。")]),J,D,R,z,n("ul",null,[n("li",null,[n("a",N,[s("OLTP与OLAP的区别精简总结"),e(a)])])]),K,n("ol",null,[n("li",null,[n("a",B,[s("Java 泛型中的通配符 T，E，K，V，？,你确定都了解吗？ - 知乎"),e(a)])]),n("li",null,[n("a",F,[s("Java 基础 - 泛型机制详解 | Java 全栈知识体系"),e(a)])])]),W,n("p",null,[n("a",U,[s("java-eight-part/docs/java/annotation/想自己写框架不会写Java注解可不行.md at master · CoderLeixiaoshuai/java-eight-part"),e(a)])]),G,n("p",null,[n("a",X,[s("JAVA 注解的基本原理"),e(a)])]),Q,n("ul",null,[n("li",null,[n("a",Y,[s("浅谈ArrayList动态扩容"),e(a)])]),Z,$,nn,n("li",null,[n("a",sn,[s("HashMap 源码详细分析(JDK1.8)"),e(a)])]),n("li",null,[n("a",an,[s("《吊打面试官》系列-HashMap"),e(a)])]),n("li",null,[n("a",en,[s("Java 集合框架看这一篇就够了"),e(a)])]),n("li",null,[n("a",tn,[s("原创 | 万万没想到，HashMap默认容量的选择，竟然背后有这么多思考！？"),e(a)])]),n("li",null,[n("a",pn,[s("我就知道面试官接下来要问我 ConcurrentHashMap 底层原理了"),e(a)])]),n("li",null,[n("a",ln,[s("JavaFamily"),e(a)])])]),on,cn,un,rn,dn,kn])}const gn=p(L,[["render",mn],["__file","javabasic.html.vue"]]);export{gn as default};
