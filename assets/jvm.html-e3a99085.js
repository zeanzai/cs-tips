import{_ as v,W as p,X as m,Y as l,Z as i,$ as n,a2 as e,a0 as t,C as r}from"./framework-16b96b76.js";const b="/cs-tips/assets/1726239781408-fc807e26.png",h="/cs-tips/assets/1726239782868-fcec98a0.png",g="/cs-tips/assets/1726239784303-78f1da49.png",f="/cs-tips/assets/1726240236741-aefa40e4.png",x="/cs-tips/assets/1726239782868-fcec98a0.png",_="/cs-tips/assets/1700017434901-8ccc0fc7.png",k="/cs-tips/assets/1681524639011-7bbf5e9c.png",C="/cs-tips/assets/1726197928105-736ccde5.png",M="/cs-tips/assets/1700364612715-dcc712bc.png",S="/cs-tips/assets/1700109303392-c5a0bc4f.png",j="/cs-tips/assets/1700551032585-4ae19fe9.png",J="/cs-tips/assets/1700551047962-d009de72.png",G="/cs-tips/assets/1700551063645-71439741.png",y="/cs-tips/assets/1700531705766-c3ea28bb.png",E="/cs-tips/assets/1700551190438-2f399037.png",X="/cs-tips/assets/1700110126796-bc255f29.png",T="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhEAAABMCAMAAADkzxUgAAADAFBMVEX///8AAADjbAoBzP9/f4C1tLQ6Ojrv7+AhFRXD/v8zAHTaiktkr/FtaHL/35ygSgH/v3QAbroAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADvAjjTAAAGVUlEQVR42u1ci1bbOhDUmARDeQT+/yNvKdCQxOleYsvWriQ7fsgmcHYOJY6To/FKo31IosYoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFN8RYNfXh4mNrffdn1+lffZj98d328R9dftuFmNs5Zo8SENGDSnlNb8izrWWpe66zCzHmM02SOdaTN5tim8OVYRCFaFQRShUEYrEivjMP1HBvbdJaXmTfbRgnYwZWoF/xV+Q7tlbc/sJPSmGqGxXWgP3xn0TZ+xaxW8TyJD5/OXftL8pWXeVbdZEn69Vq3X7BPtGfH247sncvYlBoaY91iIYxen+OLJqaeKvZDSBzshe0ITOIy7h+g21frNXB2YdXKWyWpqZKoenX7dM6TURnYaKyLKVr0TCEsIoMtq835dUlfcjct3IL6uf5pnM6On7CNr8u5U+tTKp5CCytlEjjPFOgk0m1H0H8Fbd8Fmz+hrGXQ5slIBzQdztxH14/xWqJ1hFgFM4ch6p0JginOTAFarsXvCBUTGDXEdixNqN+EL+cCsaQsTVozX69lqh4j0HuEFjgUKmAIA0OjZqq5agIb5btUGhzx2N348FU7bXcBNDuCdHGcXG+/Hbo9lk/3lmURUeUc1UmhCXIvG42JqG0p+vtcebQscmUxnHa3OcmwehvuAxuZuyNY9goa4aCNaPVouT+26T/QY3omy4tM3UuYq1ZvIo5bvCvFTdQSK2VhmTaR6D0qRHOf4+mW1FGSoZIqyP7EcyItVBlfmAwoQBJpIPDlQEeM5CoVgoSSb+YnuEsZBHjiQu6dPOrKjzLpbPwXkm2bvu30junXncriKDANFw/Y6muQmb9FVZmHV4taHWwQpxdEpi1VEDyGQ7SMpTeNfyYemkbBm/yXnUJF78Dls7rViWb0SQ4mGJJk3eCn+yVWS22gGjpk+nREI7Qs1olJGDGkMJCGb0+UR21ZG+hPVXPXsThVrLIRIi4j6iFEoCuqfizaxX29CJuqBleSlVGmHyqyPrNIq5WwMy0yjB4kTpIaT8ys+7atHeOW0TonhUba7T6cGUZSAZMk2N2dSi1FSfFAtlgzzEyzuQbzfPNSkxfmpKABuIU+SXd8AVnTLL567umpa6AKJ4LhMkSEGETQ+rp+EFKACyNOStxZoeUn2eys/Nc1Mfy5owrD5dzTSy+nQP7VV8ouytORCzZ9z5CMjugrt2lxhXfdohAWJ03tprdQfyCc6N2pecmEGz3hAsJ/OlHQP4QtQTM4kCd8/McinYoEBhlJP3KXnEUiwzkWJYL2vTeulOzJdgXOc/SBG4WdQVFdcLa+LfEoy0f1hEE8sM1c7cFMVyI3Qw13QI1z2ClTViBS/67w72ZDTeevxkxjfzsN8NLO3P3JhZEfl+1eqI5tDEusW+YzVCx7YSvGPdC13rbw9tJ+Zv3mKMtjCicYyBcdmx1MSbt5hD8RFnxRJhUAqWUhG7M3lwXnRZkzocHtvmBu8sf7+os9tesyHT87Q+AJrG2LNWiB32kDNgwOpv2qhRtPqIvKCiuDpT/gz0qYf2cio/frAUCW6Nn+TSNVsIFg6ehphnPso5veeMYr9iDOMhNlL3+1exRQGyi++1meR7CbeD01d5y+QRpR5aI9pYL95Od/zwIgaCbXa2iQXyvjvceZ30EDCyrZEkjJ96CK0SeyZcEnxesSlxGYogas0hmmdN6FNXH+eWdYj1EWygbWbRcEFkq300qWN+Yjojrl+7HKw87DHWkqUUcWi3Y5IX70sHf3kfRmwVk+NrnNIQxl3EPpR7Ju60wmTGQ3Q+xQ97eO0O8npfs2bp7Sel9+Kmrc4IfASFPilB0rsEY8dhDyPalfnFZSqCvKFP7MXPdiUMPwNG4dEYSkBCPHzMwNh12EO0O6zpL9zXAD+5mdSL99BjXGXJtAd5hHJGxuhhjzgNXbYiwPfuZ/fiRvw5i5fJdmehY0UH90ctczISrzNBcaEN6b4vUwTxYmN2L07hLqp4x3ZgKaWBNCNj5AyH5yPgCQIXrYhlvfhPBEWmCnmqM9HXi1WE+KuQeb244uKjxuw+VTES+r8FKFQRClWEQhWhUEUoVBEKVYRCFaFQRShUEYpLAl/FzncTG8s/znzh6oerfQHGyYM0fNQUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCofju+B+d3cqRx27zwwAAAABJRU5ErkJggg==",K="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhEAAABMCAMAAADkzxUgAAADAFBMVEX///8AAADjbAoBzP9/f4C1tLQ6Ojrv7+AhFRXD/v8zAHTaiktkr/FtaHL/35ygSgH/v3QAbroAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADvAjjTAAAGVUlEQVR42u1ci1bbOhDUmARDeQT+/yNvKdCQxOleYsvWriQ7fsgmcHYOJY6To/FKo31IosYoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFN8RYNfXh4mNrffdn1+lffZj98d328R9dftuFmNs5Zo8SENGDSnlNb8izrWWpe66zCzHmM02SOdaTN5tim8OVYRCFaFQRShUEYrEivjMP1HBvbdJaXmTfbRgnYwZWoF/xV+Q7tlbc/sJPSmGqGxXWgP3xn0TZ+xaxW8TyJD5/OXftL8pWXeVbdZEn69Vq3X7BPtGfH247sncvYlBoaY91iIYxen+OLJqaeKvZDSBzshe0ITOIy7h+g21frNXB2YdXKWyWpqZKoenX7dM6TURnYaKyLKVr0TCEsIoMtq835dUlfcjct3IL6uf5pnM6On7CNr8u5U+tTKp5CCytlEjjPFOgk0m1H0H8Fbd8Fmz+hrGXQ5slIBzQdztxH14/xWqJ1hFgFM4ch6p0JginOTAFarsXvCBUTGDXEdixNqN+EL+cCsaQsTVozX69lqh4j0HuEFjgUKmAIA0OjZqq5agIb5btUGhzx2N348FU7bXcBNDuCdHGcXG+/Hbo9lk/3lmURUeUc1UmhCXIvG42JqG0p+vtcebQscmUxnHa3OcmwehvuAxuZuyNY9goa4aCNaPVouT+26T/QY3omy4tM3UuYq1ZvIo5bvCvFTdQSK2VhmTaR6D0qRHOf4+mW1FGSoZIqyP7EcyItVBlfmAwoQBJpIPDlQEeM5CoVgoSSb+YnuEsZBHjiQu6dPOrKjzLpbPwXkm2bvu30junXncriKDANFw/Y6muQmb9FVZmHV4taHWwQpxdEpi1VEDyGQ7SMpTeNfyYemkbBm/yXnUJF78Dls7rViWb0SQ4mGJJk3eCn+yVWS22gGjpk+nREI7Qs1olJGDGkMJCGb0+UR21ZG+hPVXPXsThVrLIRIi4j6iFEoCuqfizaxX29CJuqBleSlVGmHyqyPrNIq5WwMy0yjB4kTpIaT8ys+7atHeOW0TonhUba7T6cGUZSAZMk2N2dSi1FSfFAtlgzzEyzuQbzfPNSkxfmpKABuIU+SXd8AVnTLL567umpa6AKJ4LhMkSEGETQ+rp+EFKACyNOStxZoeUn2eys/Nc1Mfy5owrD5dzTSy+nQP7VV8ouytORCzZ9z5CMjugrt2lxhXfdohAWJ03tprdQfyCc6N2pecmEGz3hAsJ/OlHQP4QtQTM4kCd8/McinYoEBhlJP3KXnEUiwzkWJYL2vTeulOzJdgXOc/SBG4WdQVFdcLa+LfEoy0f1hEE8sM1c7cFMVyI3Qw13QI1z2ClTViBS/67w72ZDTeevxkxjfzsN8NLO3P3JhZEfl+1eqI5tDEusW+YzVCx7YSvGPdC13rbw9tJ+Zv3mKMtjCicYyBcdmx1MSbt5hD8RFnxRJhUAqWUhG7M3lwXnRZkzocHtvmBu8sf7+os9tesyHT87Q+AJrG2LNWiB32kDNgwOpv2qhRtPqIvKCiuDpT/gz0qYf2cio/frAUCW6Nn+TSNVsIFg6ehphnPso5veeMYr9iDOMhNlL3+1exRQGyi++1meR7CbeD01d5y+QRpR5aI9pYL95Od/zwIgaCbXa2iQXyvjvceZ30EDCyrZEkjJ96CK0SeyZcEnxesSlxGYogas0hmmdN6FNXH+eWdYj1EWygbWbRcEFkq300qWN+Yjojrl+7HKw87DHWkqUUcWi3Y5IX70sHf3kfRmwVk+NrnNIQxl3EPpR7Ju60wmTGQ3Q+xQ97eO0O8npfs2bp7Sel9+Kmrc4IfASFPilB0rsEY8dhDyPalfnFZSqCvKFP7MXPdiUMPwNG4dEYSkBCPHzMwNh12EO0O6zpL9zXAD+5mdSL99BjXGXJtAd5hHJGxuhhjzgNXbYiwPfuZ/fiRvw5i5fJdmehY0UH90ctczISrzNBcaEN6b4vUwTxYmN2L07hLqp4x3ZgKaWBNCNj5AyH5yPgCQIXrYhlvfhPBEWmCnmqM9HXi1WE+KuQeb244uKjxuw+VTES+r8FKFQRClWEQhWhUEUoVBEKVYRCFaFQRShUEYpLAl/FzncTG8s/znzh6oerfQHGyYM0fNQUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCofju+B+d3cqRx27zwwAAAABJRU5ErkJggg==",O="/cs-tips/assets/1700535441065-d820c83f.png",V="/cs-tips/assets/1699847556605-4bf48bb2.png",P="/cs-tips/assets/1700534369170-bfa99250.png",z="/cs-tips/assets/1700533994216-0387d766.png",F="/cs-tips/assets/1700039595077-a2388b4d.jpeg",N="/cs-tips/assets/1676958568566-2e93c826.png",R="/cs-tips/assets/1677128747576-69744364.png",D="/cs-tips/assets/1677128764103-0c439a64.png",U="/cs-tips/assets/1688216923999-0b37d4f3.png",w="/cs-tips/assets/1681442185837-0874d26e.png",B="/cs-tips/assets/1677130373532-b0f879e4.png",H="/cs-tips/assets/1677130394867-440fbb91.png",L="/cs-tips/assets/1677128252065-f6e463ec.png",I="/cs-tips/assets/1677128187486-6d07d1a9.png",Y="/cs-tips/assets/1677128206738-60376106.png",q="/cs-tips/assets/1677230462782-9bf62217.png",Q="/cs-tips/assets/1677230478715-2b4c8e81.png",W="/cs-tips/assets/1700724873378-6cad9f5e.png",Z="/cs-tips/assets/1677241921712-7aebd7d3.png",$="/cs-tips/assets/1681523254393-4ea8e9c7.png",ll="/cs-tips/assets/1681523278823-e6f3cd62.png",il="/cs-tips/assets/1681523298158-4a7128db.png",nl="/cs-tips/assets/1726200002579-27408dfb.png",al="/cs-tips/assets/1726197928105-736ccde5.png",el="/cs-tips/assets/1700537535532-43c372ec.png",tl="/cs-tips/assets/1700547653000-89547729.png",sl="/cs-tips/assets/1677382522133-2272611f.png",dl="/cs-tips/assets/1677382997226-d1150be8.png",o="/cs-tips/assets/1677394999462-598221d9.png",ul="/cs-tips/assets/1677470190520-be4ddd5c.png",rl="/cs-tips/assets/1677470237387-46e7dab9.png",ol="/cs-tips/assets/1688216077816-9af29d20.png",c="/cs-tips/assets/1688214075720-eb6e617a.png",cl="/cs-tips/assets/1677470265347-49dc4147.png",Al="/cs-tips/assets/1677470347309-949b433e.png",vl="/cs-tips/assets/1677470382018-d70f3385.png",pl="/cs-tips/assets/1677470423655-e14baddf.png",ml="/cs-tips/assets/1677461815506-be19814e.png",bl="/cs-tips/assets/1677311728992-4aa6cecb.png",hl="/cs-tips/assets/1700722465604-01c8867c.png",gl="/cs-tips/assets/1677471275980-f45fa570.png",fl="/cs-tips/assets/1688213904945-c736fba9.png",xl="/cs-tips/assets/1688213942983-8b6b1506.png",_l="/cs-tips/assets/1688214017850-aee5c128.png",kl="/cs-tips/assets/1677383394171-3ef4651c.png",Cl="/cs-tips/assets/1677483047515-14727d61.png",Ml="/cs-tips/assets/1677483070594-5e2fa7be.png",Sl="/cs-tips/assets/1680448811163-640e4d08.png",jl="/cs-tips/assets/1680448938831-876403eb.png",Jl="/cs-tips/assets/1680439140349-5d728161.png",Gl="/cs-tips/assets/1680439220617-8bf8edc7.png",yl="/cs-tips/assets/1680439460507-db4b32e5.png",El="/cs-tips/assets/1680441120803-df285ea0.png",Xl="/cs-tips/assets/1680441169809-512638a6.png",Tl="/cs-tips/assets/1680441284422-f8d7c850.png",Kl="/cs-tips/assets/1680441340180-6b396847.png",Ol="/cs-tips/assets/1680441355631-7bcad4be.png",Vl="/cs-tips/assets/1680441663228-84ac742b.png",Pl="/cs-tips/assets/1680776690652-ec655990.png",zl="/cs-tips/assets/1677230194766-3bd436b2.png",Fl="/cs-tips/assets/1726199438377-b5e5eed0.png",Nl="/cs-tips/assets/1700721226640-e9452259.png",Rl="/cs-tips/assets/1700834420359-bdd94326.png",Dl={},Ul=t('<h1 id="java虚拟机" tabindex="-1"><a class="header-anchor" href="#java虚拟机" aria-hidden="true">#</a> Java虚拟机</h1><table><thead><tr><th><strong>日期</strong></th><th><strong>迭代内容</strong></th></tr></thead><tbody><tr><td>23-11-24</td><td>1. 导学指引。确定一种学习和记忆 JVM 相关知识点的逻辑树。</td></tr><tr><td>23-11-26</td><td>1. 调整整个文档结构，并加以完善。</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">导学指引</p><p>人们想<strong>要实现一种跨平台的编程语言</strong>，于是人们开始设计：</p><ol><li>常见语言的运行方式主要有解释运行、编译运行两种方式，但是不管如何都要经过高级语言到低级语言的转变过程（如机器语言）。那如何解决跨平台的问题？ <ol><li>高级语言不直接转化为机器语言，高级语言转化成一种中间的语言，即字节码文件；</li><li>加一台虚拟机，区别于物理机。虚拟机运行在物理机之上，不同的物理机设计实现不同的虚拟机程序；</li><li>这样以来，完美解决跨平台的问题。Java 语言编写 Java 源代码，然后通过编译器生成字节码，字节码再在虚拟机上运行。不同的虚拟机解析字节码文件时，会根据自身实现以及操作系统指令集把同一条命令解析成不同的实现。完美解决跨平台问题。</li></ol></li><li>好吧，愿景已经有了，下面就是实现。 <ol><li>高级语言得有一种格式吧，得规定 Java 源代码的规范吧，于是有了**《Java 语言规范》**。</li><li>虚拟机反正是运行字节码，那可不可以解耦？啥意思呢？就是我一定使用 Java 语言生成字节码嘛？有没有一种可能，我使用另外一种高级语言也生成同样的字节码文件？于是有了**《Java 虚拟机规范》**。</li></ol></li><li>于是，我们的学习内容有了——Java 虚拟机规范。下面我们开始学习： <ol><li>如何学呢？按照一个顺序，那就是高级语言的执行过程。这个执行过程一定是先要把高级语言转化成低级语言，然后低级语言通过调用底层的操作系统指令集，完成对计算机硬件的调用，最终完成程序的执行。那我们就按照这个过程来学习。</li><li>由于第二点说了，不一定是 Java 语言，只要能生成被虚拟机识别的字节码文件就行，因此要先学习<strong>字节码的相关内容</strong>。</li><li>好了字节码文件有了，下一步就应该是把字节码文件加载到内存中运行吧。 <ol><li>怎么加载呢，<strong>类加载子系统</strong>。</li><li>运行呢？运行过程要解决这么几个问题： <ol><li>怎么运行呢？总要有一个载体吧，这个载体就是** Java 的线程模型**。</li><li>运行时总要用到数据的计算吧，那数据怎么分配呢？这个分配过程有个逻辑模型，这个模型就是<strong>运行期内存结构</strong>。</li><li>载体和数据都分配完了，那该指令了吧，指令是怎么执行的呢？这就是<strong>执行引擎</strong>。</li></ol></li></ol></li><li>好了，能够完成基本运行功能的虚拟机已经实现了。但是还有一个重要的问题没有解决，内存的回收怎么处理呢？于是，<strong>垃圾回收理论</strong>登场。到此为止，基本的 Java 虚拟机算是学完了。</li></ol></li><li>上面我们大概了解了《Java 虚拟机规范》，那该找一个具体的虚拟机练练手吧，找哪一个呢？找市场上最流行的。——<strong>HotSpot</strong> 荣耀登场。 <ol><li>HotSpot 的<strong>内存模型</strong>；</li><li>HotSpot 的<strong>垃圾回收器</strong>；</li><li>HotSpot 有哪些<strong>配置参数</strong>呢？</li><li>HotSpot 提供了哪些<strong>工具包</strong>？有哪些好用的第三方的工具包呢？</li></ol></li><li>好了，理论部分我们已经学完了，并且我们还找了一个最常用的虚拟机实现进行学习。下个阶段就应该是压榨服务器运算能力了。这个过程我们称为<strong>调优</strong>。 <ol><li>要想压榨运算能力，首先得<strong>保证不能出错</strong>吧。于是，你得知道如何虚拟机会出现哪些错误信息，你还要知道怎么解决这些错误信息吧。</li><li>其次才是压榨运算能力，要想压榨，就得保证可用。什么意思呢？如果虚拟机一天总有 30s 的停顿时间，那放到一年中，那得有多少不可用的时间呐，那两年三年呢？于是确定我们压榨的目标——<strong>减少停顿</strong>。</li><li>目标有了——减少停顿，这个动作代表一个过程，多少算减少？所以要知道正常的停顿应该是怎样的，也就是说要知道正常指标是怎样的。最后才是在此基础上进行调优。</li></ol></li></ol></div><p>下面的知识体系也是按照上面的导学指引完成的。</p><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h2><blockquote><ol><li>Java 语言规范与 JVM 规范的区别</li><li>Java 语言的跨平台性</li><li>JDK、JRE、JVM 关系</li><li>发展历程简述</li></ol></blockquote><h3 id="_1-区别" tabindex="-1"><a class="header-anchor" href="#_1-区别" aria-hidden="true">#</a> 1. 区别</h3><figure><img src="'+b+'" alt="1726239781408.png" tabindex="0" loading="lazy"><figcaption>1726239781408.png</figcaption></figure>',8),wl={href:"https://docs.oracle.com/javase/specs/index.html",target:"_blank",rel:"noopener noreferrer"},Bl=t('<p>Java 语言从一开始就是针对跨平台而实现的。为此，它把编程语言的规范与虚拟机的规范分隔开。目的就在于实现虚拟机的跨平台性。比如下面的例子：</p><blockquote><p>Java 语言规范应该包括 Java 源代码的编写规范以及 Javac 编译器的实现规范。</p></blockquote><figure><img src="'+h+'" alt="1726239782868" tabindex="0" loading="lazy"><figcaption>1726239782868</figcaption></figure><figure><img src="'+g+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>Java 语言规范与 Java 虚拟机规范可以这样去理解：</p><ol><li>Java 语言规范规定了程序员如何使用 Java 语言写代码，这里的代码特质 Java 源代码；</li><li>而 Java 虚拟机规范则规定了 JVM 如何理解 字节码 文件，并通过调用操作系统相关指令集来完成字节码文件中的相关指令。</li></ol><p>字节码的执行可以看作是： jvm 读取到其中某一条指令后，然后把这条指令转化成操作系统能够理解的底层指令，最后操作硬件完成具体的功能。这里要注意的是：字节码中的指令，全部都是操控 jvm 的，而 jvm 是运行于操作系统之上的，因此 jvm 会把指令转化为操作系统能够理解的底层指令。</p><h2 id="_2-前端编译阶段及字节码文件" tabindex="-1"><a class="header-anchor" href="#_2-前端编译阶段及字节码文件" aria-hidden="true">#</a> 2. 前端编译阶段及字节码文件</h2><blockquote><ol><li>前端编译介绍</li><li>字节码文件解析</li><li>相关命令</li><li>特殊应用【如字节码增强技术、热部署等】</li></ol></blockquote><figure><img src="'+f+'" alt="1726240236741" tabindex="0" loading="lazy"><figcaption>1726240236741</figcaption></figure>',10),Hl={href:"https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html",target:"_blank",rel:"noopener noreferrer"},Ll=t('<h3 id="_1-作用" tabindex="-1"><a class="header-anchor" href="#_1-作用" aria-hidden="true">#</a> 1. 作用</h3><p>字节码文件<strong>本质上是一个以8位字节为基础单位的二进制流文件</strong>，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>从更高层次上抽象的话，如果 jvm 就是一个计算机操作系统，而字节码文件就是操作系统的指令集。高级语言通过各种各样的编译器生成字节码文件，然后<strong>通过字节码文件操纵 jvm 完成实际的程序功能</strong>。</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>字节码增强技术 和 运行时类重载技术：</p><p>因为已经了解到字节码指令了，因此，我们就可以对字节码文件进行编辑，让字节码文件操作 jvm 完成某项功能。这就是所谓的字节码增强技术。</p><p>由于字节码增强技术只能用于操作字节码文件，对于已经加载到 jvm 中的 class 类对象，并没有办法进行操作，因此 jvm 对外提供了一整套的 api，可以用来专门解决这个问题。这一套 API 就是运行时类重载技术。</p><p>为什么要了解字节码？</p><ol><li>有利于编写更加高效，性能更高的程序；</li><li>通过修改字节码来调整程序行为；</li><li>对于了解一些利用字节码相关技术完成软件功能的实现原理有帮助，如了解 AOP 的实现原理、Profiler 的实现原理、Mock 框架的实现原理等；</li><li>热部署、性能诊断工具等；</li></ol><h3 id="_2-查看-class-文件的方法" tabindex="-1"><a class="header-anchor" href="#_2-查看-class-文件的方法" aria-hidden="true">#</a> 2. 查看 class 文件的方法</h3><ol><li>javap 进行反编译；</li><li>idea 中的 show bytecode；</li><li>idea 插件中的 jclasslib 插件包；</li><li>arths</li></ol><h3 id="_3-appendix-指令集" tabindex="-1"><a class="header-anchor" href="#_3-appendix-指令集" aria-hidden="true">#</a> 3. Appendix：指令集</h3><p>字节码指令根据功能、属性不同，可以分为11大类。下面附上字节码指令的分类，用于简单、临时查看，字节码指令的详细介绍，还需要查看官网的介绍。</p>',13),Il=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"00"),l("td",null,"0x00"),l("td",null,"nop"),l("td",null,"什么都不做")]),l("tr",null,[l("td",null,"01"),l("td",null,"0x01"),l("td",null,"aconst_null"),l("td",null,"把 null 推到操作数栈")]),l("tr",null,[l("td",null,"02"),l("td",null,"0x02"),l("td",null,"iconst_m1"),l("td",null,"把 int 常量 –1 推到操作数栈")]),l("tr",null,[l("td",null,"03"),l("td",null,"0x03"),l("td",null,"iconst_0"),l("td",null,"把 int 常量 0 推到操作数栈")]),l("tr",null,[l("td",null,"04"),l("td",null,"0x04"),l("td",null,"iconst_1"),l("td",null,"把 int 常量 1 推到操作数栈")]),l("tr",null,[l("td",null,"05"),l("td",null,"0x05"),l("td",null,"iconst_2"),l("td",null,"把 int 常量 2 推到操作数栈")]),l("tr",null,[l("td",null,"06"),l("td",null,"0x06"),l("td",null,"iconst_3"),l("td",null,"把 int 常量 3 推到操作数栈")]),l("tr",null,[l("td",null,"07"),l("td",null,"0x07"),l("td",null,"iconst_4"),l("td",null,"把 int 常量 4 推到操作数栈")]),l("tr",null,[l("td",null,"08"),l("td",null,"0x08"),l("td",null,"iconst_5"),l("td",null,"把 int 常量 5 推到操作数栈")]),l("tr",null,[l("td",null,"09"),l("td",null,"0x09"),l("td",null,"lconst_0"),l("td",null,"把 long 常量 0 推到操作数栈")]),l("tr",null,[l("td",null,"10"),l("td",null,"0x0A"),l("td",null,"lconst_1"),l("td",null,"把 long 常量 1 推到操作数栈")]),l("tr",null,[l("td",null,"11"),l("td",null,"0x0B"),l("td",null,"fconst_0"),l("td",null,"把 float 常量 0 推到操作数栈")]),l("tr",null,[l("td",null,"12"),l("td",null,"0x0C"),l("td",null,"fconst_1"),l("td",null,"把 float 常量 1 推到操作数栈")]),l("tr",null,[l("td",null,"13"),l("td",null,"0x0D"),l("td",null,"fconst_2"),l("td",null,"把 float 常量 2 推到操作数栈")]),l("tr",null,[l("td",null,"14"),l("td",null,"0x0E"),l("td",null,"dconst_0"),l("td",null,"把 double 常量 0 推到操作数栈")]),l("tr",null,[l("td",null,"15"),l("td",null,"0x0F"),l("td",null,"dconst_1"),l("td",null,"把 double 常量 1 推到操作数栈")]),l("tr",null,[l("td",null,"16"),l("td",null,"0x10"),l("td",null,"bipush"),l("td",null,"把单字节常量（-128~127）推到操作数栈")]),l("tr",null,[l("td",null,"17"),l("td",null,"0x11"),l("td",null,"sipush"),l("td",null,"把 short 常量（-32768~32767）推到操作数栈")]),l("tr",null,[l("td",null,"18"),l("td",null,"0x12"),l("td",null,"ldc"),l("td",null,"把常量池中的int，float，String型常量取出并推到操作数栈顶")]),l("tr",null,[l("td",null,"19"),l("td",null,"0x13"),l("td",null,"ldc_w"),l("td",null,"把常量池中的int，float，String型常量取出并推到操作数栈顶（宽索引）")]),l("tr",null,[l("td",null,"20"),l("td",null,"0x14"),l("td",null,"ldc2_w"),l("td",null,"把常量池中的long，double型常量取出并推到操作数栈顶（宽索引）")])])],-1),Yl=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"21"),l("td",null,"0x15"),l("td",null,"iload"),l("td",null,"把 int 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"22"),l("td",null,"0x16"),l("td",null,"lload"),l("td",null,"把 long 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"23"),l("td",null,"0x17"),l("td",null,"fload"),l("td",null,"把 float 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"24"),l("td",null,"0x18"),l("td",null,"dload"),l("td",null,"把 double 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"25"),l("td",null,"0x19"),l("td",null,"aload"),l("td",null,"把引用型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"26"),l("td",null,"0x1A"),l("td",null,"iload_0"),l("td",null,"把局部变量第 1 个 int 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"27"),l("td",null,"0x1B"),l("td",null,"iload_1"),l("td",null,"把局部变量第 2 个 int 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"28"),l("td",null,"0x1C"),l("td",null,"iload_2"),l("td",null,"把局部变量第 3 个 int 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"29"),l("td",null,"0x1D"),l("td",null,"iload_3"),l("td",null,"把局部变量第 4 个 int 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"30"),l("td",null,"0x1E"),l("td",null,"lload_0"),l("td",null,"把局部变量第 1 个 long 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"31"),l("td",null,"0x1F"),l("td",null,"lload_1"),l("td",null,"把局部变量第 2 个 long 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"32"),l("td",null,"0x20"),l("td",null,"lload_2"),l("td",null,"把局部变量第 3 个 long 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"33"),l("td",null,"0x21"),l("td",null,"lload_3"),l("td",null,"把局部变量第 4 个 long 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"34"),l("td",null,"0x22"),l("td",null,"fload_0"),l("td",null,"把局部变量第 1 个 float 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"35"),l("td",null,"0x23"),l("td",null,"fload_1"),l("td",null,"把局部变量第 2 个 float 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"36"),l("td",null,"0x24"),l("td",null,"fload_2"),l("td",null,"把局部变量第 3 个 float 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"37"),l("td",null,"0x25"),l("td",null,"fload_3"),l("td",null,"把局部变量第 4 个 float 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"38"),l("td",null,"0x26"),l("td",null,"dload_0"),l("td",null,"把局部变量第 1 个 double 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"39"),l("td",null,"0x27"),l("td",null,"dload_1"),l("td",null,"把局部变量第 2 个 double 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"40"),l("td",null,"0x28"),l("td",null,"dload_2"),l("td",null,"把局部变量第 3 个 double 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"41"),l("td",null,"0x29"),l("td",null,"dload_3"),l("td",null,"把局部变量第 4 个 double 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"42"),l("td",null,"0x2A"),l("td",null,"aload_0"),l("td",null,"把局部变量第 1 个引用型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"43"),l("td",null,"0x2B"),l("td",null,"aload_1"),l("td",null,"把局部变量第 2 个引用型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"44"),l("td",null,"0x2C"),l("td",null,"aload_2"),l("td",null,"把局部变量第 3 个引用型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"45"),l("td",null,"0x2D"),l("td",null,"aload_3"),l("td",null,"把局部变量第 4 个引用 型局部变量推到操作数栈")]),l("tr",null,[l("td",null,"46"),l("td",null,"0x2E"),l("td",null,"iaload"),l("td",null,"把 int 型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"47"),l("td",null,"0x2F"),l("td",null,"laload"),l("td",null,"把 long 型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"48"),l("td",null,"0x30"),l("td",null,"faload"),l("td",null,"把 float 型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"49"),l("td",null,"0x31"),l("td",null,"daload"),l("td",null,"把 double 型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"50"),l("td",null,"0x32"),l("td",null,"aaload"),l("td",null,"把引用型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"51"),l("td",null,"0x33"),l("td",null,"baload"),l("td",null,"把 boolean或byte型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"52"),l("td",null,"0x34"),l("td",null,"caload"),l("td",null,"把 char 型数组指定索引的值推到操作数栈")]),l("tr",null,[l("td",null,"53"),l("td",null,"0x35"),l("td",null,"saload"),l("td",null,"把 short 型数组指定索引的值推到操作数栈")])])],-1),ql=l("p",null,null,-1),Ql=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"54"),l("td",null,"0x36"),l("td",null,"istore"),l("td",null,"把栈顶 int 型数值存入指定局部变量")]),l("tr",null,[l("td",null,"55"),l("td",null,"0x37"),l("td",null,"lstore"),l("td",null,"把栈顶 long 型数值存入指定局部变量")]),l("tr",null,[l("td",null,"56"),l("td",null,"0x38"),l("td",null,"fstore"),l("td",null,"把栈顶 float 型数值存入指定局部变量")]),l("tr",null,[l("td",null,"57"),l("td",null,"0x39"),l("td",null,"dstore"),l("td",null,"把栈顶 double 型数值存入指定局部变量")]),l("tr",null,[l("td",null,"58"),l("td",null,"0x3A"),l("td",null,"astore"),l("td",null,"把栈顶引用型数值存入指定局部变量")]),l("tr",null,[l("td",null,"59"),l("td",null,"0x3B"),l("td",null,"istore_0"),l("td",null,"把栈顶 int 型数值存入第 1 个局部变量")]),l("tr",null,[l("td",null,"60"),l("td",null,"0x3C"),l("td",null,"istore_1"),l("td",null,"把栈顶 int 型数值存入第 2 个局部变量")]),l("tr",null,[l("td",null,"61"),l("td",null,"0x3D"),l("td",null,"istore_2"),l("td",null,"把栈顶 int 型数值存入第 3 个局部变量")]),l("tr",null,[l("td",null,"62"),l("td",null,"0x3E"),l("td",null,"istore_3"),l("td",null,"把栈顶 int 型数值存入第 4 个局部变量")]),l("tr",null,[l("td",null,"63"),l("td",null,"0x3F"),l("td",null,"lstore_0"),l("td",null,"把栈顶 long 型数值存入第 1 个局部变量")]),l("tr",null,[l("td",null,"64"),l("td",null,"0x40"),l("td",null,"lstore_1"),l("td",null,"把栈顶 long 型数值存入第 2 个局部变量")]),l("tr",null,[l("td",null,"65"),l("td",null,"0x41"),l("td",null,"lstore_2"),l("td",null,"把栈顶 long 型数值存入第 3 个局部变量")]),l("tr",null,[l("td",null,"66"),l("td",null,"0x42"),l("td",null,"lstore_3"),l("td",null,"把栈顶 long 型数值存入第 4 个局部变量")]),l("tr",null,[l("td",null,"67"),l("td",null,"0x43"),l("td",null,"fstore_0"),l("td",null,"把栈顶 float 型数值存入第 1 个局部变量")]),l("tr",null,[l("td",null,"68"),l("td",null,"0x44"),l("td",null,"fstore_1"),l("td",null,"把栈顶 float 型数值存入第 2 个局部变量")]),l("tr",null,[l("td",null,"69"),l("td",null,"0x45"),l("td",null,"fstore_2"),l("td",null,"把栈顶 float 型数值存入第 3 个局部变量")]),l("tr",null,[l("td",null,"70"),l("td",null,"0x46"),l("td",null,"fstore_3"),l("td",null,"把栈顶 float 型数值存入第 4 个局部变量")]),l("tr",null,[l("td",null,"71"),l("td",null,"0x47"),l("td",null,"dstore_0"),l("td",null,"把栈顶 double 型数值存入第 1 个局部变量")]),l("tr",null,[l("td",null,"72"),l("td",null,"0x48"),l("td",null,"dstore_1"),l("td",null,"把栈顶 double 型数值存入第 2 个局部变量")]),l("tr",null,[l("td",null,"73"),l("td",null,"0x49"),l("td",null,"dstore_2"),l("td",null,"把栈顶 double 型数值存入第 3 个局部变量")]),l("tr",null,[l("td",null,"74"),l("td",null,"0x4A"),l("td",null,"dstore_3"),l("td",null,"把栈顶 double 型数值存入第 4 个局部变量")]),l("tr",null,[l("td",null,"75"),l("td",null,"0x4B"),l("td",null,"astore_0"),l("td",null,"把栈顶 引用 型数值存入第 1 个局部变量")]),l("tr",null,[l("td",null,"76"),l("td",null,"0x4C"),l("td",null,"astore_1"),l("td",null,"把栈顶 引用 型数值存入第 2 个局部变量")]),l("tr",null,[l("td",null,"77"),l("td",null,"0x4D"),l("td",null,"astore_2"),l("td",null,"把栈顶 引用 型数值存入第 3 个局部变量")]),l("tr",null,[l("td",null,"78"),l("td",null,"0x4E"),l("td",null,"astore_3"),l("td",null,"把栈顶 引用 型数值存入第 4 个局部变量")]),l("tr",null,[l("td",null,"79"),l("td",null,"0x4F"),l("td",null,"iastore"),l("td",null,"把栈顶 int 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"80"),l("td",null,"0x50"),l("td",null,"lastore"),l("td",null,"把栈顶 long 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"81"),l("td",null,"0x51"),l("td",null,"fastore"),l("td",null,"把栈顶 float 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"82"),l("td",null,"0x52"),l("td",null,"dastore"),l("td",null,"把栈顶 double 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"83"),l("td",null,"0x53"),l("td",null,"aastore"),l("td",null,"把栈顶 引用 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"84"),l("td",null,"0x54"),l("td",null,"bastore"),l("td",null,"把栈顶 boolean or byte 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"85"),l("td",null,"0x55"),l("td",null,"castore"),l("td",null,"把栈顶 char 型数值存入数组指定索引位置")]),l("tr",null,[l("td",null,"86"),l("td",null,"0x56"),l("td",null,"sastore"),l("td",null,"把栈顶 short 型数值存入数组指定索引位置")])])],-1),Wl=l("p",null,null,-1),Zl=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"87"),l("td",null,"0x57"),l("td",null,"pop"),l("td",null,"把栈顶数值弹出（非long，double数值）")]),l("tr",null,[l("td",null,"88"),l("td",null,"0x58"),l("td",null,"pop2"),l("td",null,"把栈顶的一个long或double值弹出，或弹出2个其他类型数值")]),l("tr",null,[l("td",null,"89"),l("td",null,"0x59"),l("td",null,"dup"),l("td",null,"复制栈顶数值并把数值入栈")]),l("tr",null,[l("td",null,"90"),l("td",null,"0x5A"),l("td",null,"dup_x1"),l("td",null,"复制栈顶数值并将两个复制值压入栈顶")]),l("tr",null,[l("td",null,"91"),l("td",null,"0x5B"),l("td",null,"dup_x2"),l("td",null,"复制栈顶数值并将三个（或两个）复制值压入栈顶")]),l("tr",null,[l("td",null,"92"),l("td",null,"0x5C"),l("td",null,"dup2"),l("td",null,"复制栈顶一个（long 或double 类型的)或两个（其它）数值并将复制值压入栈顶")]),l("tr",null,[l("td",null,"93"),l("td",null,"0x5D"),l("td",null,"dup2_x1"),l("td",null,"dup_x1 指令的双倍版本")]),l("tr",null,[l("td",null,"94"),l("td",null,"0x5E"),l("td",null,"dup2_x2"),l("td",null,"dup_x2 指令的双倍版本")]),l("tr",null,[l("td",null,"95"),l("td",null,"0x5F"),l("td",null,"swap"),l("td",null,"把栈顶端的两个数的值交换（数值不能是long 或double 类型< td >的）")])])],-1),$l=l("p",null,null,-1),li=l("p",null,"Java 虚拟机在处理浮点数运算时，不会抛出任何运行时异常，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。",-1),ii=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"96"),l("td",null,"0x60"),l("td",null,"iadd"),l("td",null,"把栈顶两个 int 型数值相加并将结果入栈")]),l("tr",null,[l("td",null,"97"),l("td",null,"0x61"),l("td",null,"ladd"),l("td",null,"把栈顶两个 long 型数值相加并将结果入栈")]),l("tr",null,[l("td",null,"98"),l("td",null,"0x62"),l("td",null,"fadd"),l("td",null,"把栈顶两个 float 型数值相加并将结果入栈")]),l("tr",null,[l("td",null,"99"),l("td",null,"0x63"),l("td",null,"dadd"),l("td",null,"把栈顶两个 double 型数值相加并将结果入栈")]),l("tr",null,[l("td",null,"100"),l("td",null,"0x64"),l("td",null,"isub"),l("td",null,"把栈顶两个 int 型数值相减并将结果入栈")]),l("tr",null,[l("td",null,"101"),l("td",null,"0x65"),l("td",null,"lsub"),l("td",null,"把栈顶两个 long 型数值相减并将结果入栈")]),l("tr",null,[l("td",null,"102"),l("td",null,"0x66"),l("td",null,"fsub"),l("td",null,"把栈顶两个 float 型数值相减并将结果入栈")]),l("tr",null,[l("td",null,"103"),l("td",null,"0x67"),l("td",null,"dsub"),l("td",null,"把栈顶两个 double 型数值相减并将结果入栈")]),l("tr",null,[l("td",null,"104"),l("td",null,"0x68"),l("td",null,"imul"),l("td",null,"把栈顶两个 int 型数值相乘并将结果入栈")]),l("tr",null,[l("td",null,"105"),l("td",null,"0x69"),l("td",null,"lmul"),l("td",null,"把栈顶两个 long 型数值相乘并将结果入栈")]),l("tr",null,[l("td",null,"106"),l("td",null,"0x6A"),l("td",null,"fmul"),l("td",null,"把栈顶两个 float 型数值相乘并将结果入栈")]),l("tr",null,[l("td",null,"107"),l("td",null,"0x6B"),l("td",null,"dmul"),l("td",null,"把栈顶两个 double 型数值相乘并将结果入栈")]),l("tr",null,[l("td",null,"108"),l("td",null,"0x6C"),l("td",null,"idiv"),l("td",null,"把栈顶两个 int 型数值相除并将结果入栈")]),l("tr",null,[l("td",null,"109"),l("td",null,"0x6D"),l("td",null,"ldiv"),l("td",null,"把栈顶两个 long 型数值相除并将结果入栈")]),l("tr",null,[l("td",null,"110"),l("td",null,"0x6E"),l("td",null,"fdiv"),l("td",null,"把栈顶两个 float 型数值相除并将结果入栈")]),l("tr",null,[l("td",null,"111"),l("td",null,"0x6F"),l("td",null,"ddiv"),l("td",null,"把栈顶两个 double 型数值相除并将结果入栈")]),l("tr",null,[l("td",null,"112"),l("td",null,"0x70"),l("td",null,"irem"),l("td",null,"把栈顶两个 int 型数值模运算并将结果入栈")]),l("tr",null,[l("td",null,"113"),l("td",null,"0x71"),l("td",null,"lrem"),l("td",null,"把栈顶两个 long 型数值模运算并将结果入栈")]),l("tr",null,[l("td",null,"114"),l("td",null,"0x72"),l("td",null,"frem"),l("td",null,"把栈顶两个 float 型数值模运算并将结果入栈")]),l("tr",null,[l("td",null,"115"),l("td",null,"0x73"),l("td",null,"drem"),l("td",null,"把栈顶两个 double 型数值模运算并将结果入栈")]),l("tr",null,[l("td",null,"116"),l("td",null,"0x74"),l("td",null,"ineg"),l("td",null,"把栈顶 int 型数值取负并将结果入栈")]),l("tr",null,[l("td",null,"117"),l("td",null,"0x75"),l("td",null,"lneg"),l("td",null,"把栈顶 long 型数值取负并将结果入栈")]),l("tr",null,[l("td",null,"118"),l("td",null,"0x76"),l("td",null,"fneg"),l("td",null,"把栈顶 float 型数值取负并将结果入栈")]),l("tr",null,[l("td",null,"119"),l("td",null,"0x77"),l("td",null,"dneg"),l("td",null,"把栈顶 double 型数值取负并将结果入栈")]),l("tr",null,[l("td",null,"120"),l("td",null,"0x78"),l("td",null,"ishl"),l("td",null,"把 int 型数左移指定位数并将结果入栈")]),l("tr",null,[l("td",null,"121"),l("td",null,"0x79"),l("td",null,"lshl"),l("td",null,"把 long 型数左移指定位数并将结果入栈")]),l("tr",null,[l("td",null,"122"),l("td",null,"0x7A"),l("td",null,"ishr"),l("td",null,"把 int 型数右移指定位数并将结果入栈（有符号）")]),l("tr",null,[l("td",null,"123"),l("td",null,"0x7B"),l("td",null,"lshr"),l("td",null,"把 long 型数右移指定位数并将结果入栈（有符号）")]),l("tr",null,[l("td",null,"124"),l("td",null,"0x7C"),l("td",null,"iushr"),l("td",null,"把 int 型数右移指定位数并将结果入栈（无符号）")]),l("tr",null,[l("td",null,"125"),l("td",null,"0x7D"),l("td",null,"lushr"),l("td",null,"把 long 型数右移指定位数并将结果入栈（无符号）")]),l("tr",null,[l("td",null,"126"),l("td",null,"0x7E"),l("td",null,"iand"),l("td",null,"把栈顶两个 int 型数值 按位与 并将结果入栈")]),l("tr",null,[l("td",null,"127"),l("td",null,"0x7F"),l("td",null,"land"),l("td",null,"把栈顶两个 long 型数值 按位与 并将结果入栈")]),l("tr",null,[l("td",null,"128"),l("td",null,"0x80"),l("td",null,"ior"),l("td",null,"把栈顶两个 int 型数值 按位或 并将结果入栈")]),l("tr",null,[l("td",null,"129"),l("td",null,"0x81"),l("td",null,"lor"),l("td",null,"把栈顶两个 long 型数值 按或与 并将结果入栈")]),l("tr",null,[l("td",null,"130"),l("td",null,"0x82"),l("td",null,"ixor"),l("td",null,"把栈顶两个 int 型数值 按位异或 并将结果入栈")]),l("tr",null,[l("td",null,"131"),l("td",null,"0x83"),l("td",null,"lxor"),l("td",null,"把栈顶两个 long 型数值 按位异或 并将结果入栈")]),l("tr",null,[l("td",null,"132"),l("td",null,"0x84"),l("td",null,"iinc"),l("td",null,"把指定 int 型增加指定值")])])],-1),ni=l("p",null,null,-1),ai=l("p",null,"类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显示类型转换操作。 Java 虚拟机直接支持（即转换时无需显示的转换指令）小范围类型向大范围类型的安全转换，但在处理窄化类型转换时，必须显式使用转换指令来完成。",-1),ei=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"133"),l("td",null,"0x85"),l("td",null,"i2l"),l("td",null,"把栈顶 int 强转 long 并入栈")]),l("tr",null,[l("td",null,"134"),l("td",null,"0x86"),l("td",null,"i2f"),l("td",null,"把栈顶 int 强转 float 并入栈")]),l("tr",null,[l("td",null,"135"),l("td",null,"0x87"),l("td",null,"i2d"),l("td",null,"把栈顶 int 强转 double 并入栈")]),l("tr",null,[l("td",null,"136"),l("td",null,"0x88"),l("td",null,"l2i"),l("td",null,"把栈顶 long 强转 int 并入栈")]),l("tr",null,[l("td",null,"137"),l("td",null,"0x89"),l("td",null,"l2f"),l("td",null,"把栈顶 long 强转 float 并入栈")]),l("tr",null,[l("td",null,"138"),l("td",null,"0x8A"),l("td",null,"l2d"),l("td",null,"把栈顶 long 强转 double 并入栈")]),l("tr",null,[l("td",null,"139"),l("td",null,"0x8B"),l("td",null,"f2i"),l("td",null,"把栈顶 float 强转 int 并入栈")]),l("tr",null,[l("td",null,"140"),l("td",null,"0x8C"),l("td",null,"f2l"),l("td",null,"把栈顶 float 强转 long 并入栈")]),l("tr",null,[l("td",null,"141"),l("td",null,"0x8D"),l("td",null,"f2d"),l("td",null,"把栈顶 float 强转 double 并入栈")]),l("tr",null,[l("td",null,"142"),l("td",null,"0x8E"),l("td",null,"d2i"),l("td",null,"把栈顶 double 强转 int 并入栈")]),l("tr",null,[l("td",null,"143"),l("td",null,"0x8F"),l("td",null,"d2l"),l("td",null,"把栈顶 double 强转 long 并入栈")]),l("tr",null,[l("td",null,"144"),l("td",null,"0x90"),l("td",null,"d2f"),l("td",null,"把栈顶 double 强转 float 并入栈")]),l("tr",null,[l("td",null,"145"),l("td",null,"0x91"),l("td",null,"i2b"),l("td",null,"把栈顶 int 强转 byte 并入栈")]),l("tr",null,[l("td",null,"146"),l("td",null,"0x92"),l("td",null,"i2c"),l("td",null,"把栈顶 int 强转 char 并入栈")]),l("tr",null,[l("td",null,"147"),l("td",null,"0x93"),l("td",null,"i2s"),l("td",null,"把栈顶 int 强转 short 并入栈")])])],-1),ti=l("p",null,null,-1),si=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"148"),l("td",null,"0x94"),l("td",null,"lcmp"),l("td",null,"比较栈顶两long 型数值大小，并将结果（1，0，-1）压入栈顶")]),l("tr",null,[l("td",null,"149"),l("td",null,"0x95"),l("td",null,"fcmpl"),l("td",null,"比较栈顶两float 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将-1 压入栈顶")]),l("tr",null,[l("td",null,"150"),l("td",null,"0x96"),l("td",null,"fcmpg"),l("td",null,"比较栈顶两float 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将1 压入栈顶")]),l("tr",null,[l("td",null,"151"),l("td",null,"0x97"),l("td",null,"dcmpl"),l("td",null,"比较栈顶两double 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将-1 压入栈顶")]),l("tr",null,[l("td",null,"152"),l("td",null,"0x98"),l("td",null,"dcmpg"),l("td",null,"比较栈顶两double 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将1 压入栈顶")]),l("tr",null,[l("td",null,"153"),l("td",null,"0x99"),l("td",null,"ifeq"),l("td",null,"当栈顶 int 型数值等于0时，跳转")]),l("tr",null,[l("td",null,"154"),l("td",null,"0x9A"),l("td",null,"ifne"),l("td",null,"当栈顶 int 型数值不等于0时，跳转")]),l("tr",null,[l("td",null,"155"),l("td",null,"0x9B"),l("td",null,"iflt"),l("td",null,"当栈顶 int 型数值小于0时，跳转")]),l("tr",null,[l("td",null,"156"),l("td",null,"0x9C"),l("td",null,"ifge"),l("td",null,"当栈顶 int 型数值大于等于0时，跳转")]),l("tr",null,[l("td",null,"157"),l("td",null,"0x9D"),l("td",null,"ifgt"),l("td",null,"当栈顶 int 型数值大于0时，跳转")]),l("tr",null,[l("td",null,"158"),l("td",null,"0x9E"),l("td",null,"ifle"),l("td",null,"当栈顶 int 型数值小于等于0时，跳转")]),l("tr",null,[l("td",null,"159"),l("td",null,"0x9F"),l("td",null,"if_icmpeq"),l("td",null,"比较栈顶两个 int 型数值，等于0时，跳转")]),l("tr",null,[l("td",null,"160"),l("td",null,"0xA0"),l("td",null,"if_icmpne"),l("td",null,"比较栈顶两个 int 型数值，不等于0时，跳转")]),l("tr",null,[l("td",null,"161"),l("td",null,"0xA1"),l("td",null,"if_icmplt"),l("td",null,"比较栈顶两个 int 型数值，小于0时，跳转")]),l("tr",null,[l("td",null,"162"),l("td",null,"0xA2"),l("td",null,"if_icmpge"),l("td",null,"比较栈顶两个 int 型数值，大于等于0时，跳转")]),l("tr",null,[l("td",null,"163"),l("td",null,"0xA3"),l("td",null,"if_icmpgt"),l("td",null,"比较栈顶两个 int 型数值，大于0时，跳转")]),l("tr",null,[l("td",null,"164"),l("td",null,"0xA4"),l("td",null,"if_icmple"),l("td",null,"比较栈顶两个 int 型数值，小于等于0时，跳转")]),l("tr",null,[l("td",null,"165"),l("td",null,"0xA5"),l("td",null,"if_acmpeq"),l("td",null,"比较栈顶两个 引用 型数值，相等时跳转")]),l("tr",null,[l("td",null,"166"),l("td",null,"0xA6"),l("td",null,"if_acmpne"),l("td",null,"比较栈顶两个 引用 型数值，不相等时跳转")])])],-1),di=l("p",null,null,-1),ui=l("p",null,"控制转移指令可以让 Java 虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改 PC 寄存器的值。",-1),ri=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"167"),l("td",null,"0xA7"),l("td",null,"goto"),l("td",null,"无条件分支跳转")]),l("tr",null,[l("td",null,"168"),l("td",null,"0xA8"),l("td",null,"jsr"),l("td",null,"跳转至指定16 位offset（bit） 位置，并将jsr 下一条指令地址压入栈顶")]),l("tr",null,[l("td",null,"169"),l("td",null,"0xA9"),l("td",null,"ret"),l("td",null,"返回至局部变量指定的index 的指令位置（一般与jsr，jsr_w联合使用）")]),l("tr",null,[l("td",null,"170"),l("td",null,"0xAA"),l("td",null,"tableswitch"),l("td",null,"用于switch 条件跳转，case 值连续（可变长度指令）")]),l("tr",null,[l("td",null,"171"),l("td",null,"0xAB"),l("td",null,"lookupswitch"),l("td",null,"用于switch 条件跳转，case 值不连续（可变长度指令）")]),l("tr",null,[l("td",null,"172"),l("td",null,"0xAC"),l("td",null,"ireturn"),l("td",null,"结束方法，并返回一个int 类型数据")]),l("tr",null,[l("td",null,"173"),l("td",null,"0xAD"),l("td",null,"lreturn"),l("td",null,"从当前方法返回 long")]),l("tr",null,[l("td",null,"174"),l("td",null,"0xAE"),l("td",null,"freturn"),l("td",null,"从当前方法返回 float")]),l("tr",null,[l("td",null,"175"),l("td",null,"0xAF"),l("td",null,"dreturn"),l("td",null,"从当前方法返回 double")]),l("tr",null,[l("td",null,"176"),l("td",null,"0xB0"),l("td",null,"areturn"),l("td",null,"从当前方法返回 对象引用")]),l("tr",null,[l("td",null,"177"),l("td",null,"0xB1"),l("td",null,"return"),l("td",null,"从当前方法返回 void")])])],-1),oi=l("p",null,null,-1),ci=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"178"),l("td",null,"0xB2"),l("td",null,"getstatic"),l("td",null,"获取指定类的静态域，并将其值压入栈顶")]),l("tr",null,[l("td",null,"179"),l("td",null,"0xB3"),l("td",null,"putstatic"),l("td",null,"为类的静态域赋值")]),l("tr",null,[l("td",null,"180"),l("td",null,"0xB4"),l("td",null,"getfield"),l("td",null,"获取指定类的实例域（对象的字段值），并将其值压入栈顶")]),l("tr",null,[l("td",null,"181"),l("td",null,"0xB5"),l("td",null,"putfield"),l("td",null,"为指定的类的实例域赋值")]),l("tr",null,[l("td",null,"182"),l("td",null,"0xB6"),l("td",null,"invokevirtual"),l("td",null,"调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），是Java语言中最常见的方法分派方式。")]),l("tr",null,[l("td",null,"183"),l("td",null,"0xB7"),l("td",null,"invokespecial"),l("td",null,"调用一些需要特殊处理的实例方法，包括实例初始化方法（）、私有方法和父类方法。这三类方法的调用对象在编译时就可以确定。")]),l("tr",null,[l("td",null,"184"),l("td",null,"0xB8"),l("td",null,"invokestatic"),l("td",null,"调用静态方法")]),l("tr",null,[l("td",null,"185"),l("td",null,"0xB9"),l("td",null,"invokeinterface"),l("td",null,"调用接口方法调，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。")]),l("tr",null,[l("td",null,"186"),l("td",null,"0xBA"),l("td",null,"invokedynamic"),l("td",null,"调用动态链接方法（该指令是指令是Java SE 7 中新加入的）。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。")]),l("tr",null,[l("td",null,"187"),l("td",null,"0xBB"),l("td",null,"new"),l("td",null,"创建一个对象，并将其引用值压入栈顶")]),l("tr",null,[l("td",null,"188"),l("td",null,"0xBC"),l("td",null,"newarray"),l("td",null,"创建一个指定原始类型（如int、float、char……）的数组，并将其引用值压入栈顶")]),l("tr",null,[l("td",null,"189"),l("td",null,"0xBD"),l("td",null,"anewarray"),l("td",null,"创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶")]),l("tr",null,[l("td",null,"190"),l("td",null,"0xBE"),l("td",null,"arraylength"),l("td",null,"获得数组的长度值并压入栈顶")]),l("tr",null,[l("td",null,"191"),l("td",null,"0xBF"),l("td",null,"athrow"),l("td",null,"将栈顶的异常直接抛出。Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，并且，在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。")]),l("tr",null,[l("td",null,"192"),l("td",null,"0xC0"),l("td",null,"checkcast"),l("td",null,"检验类型转换，检验未通过将抛出ClassCastException")]),l("tr",null,[l("td",null,"193"),l("td",null,"0xC1"),l("td",null,"instanceof"),l("td",null,"检验对象是否是指定的类的实例，如果是将1 压入栈顶，否则将0 压入栈顶")]),l("tr",null,[l("td",null,"194"),l("td",null,"0xC2"),l("td",null,"monitorenter"),l("td",null,"获取对象的monitor，用于同步块或同步方法")]),l("tr",null,[l("td",null,"195"),l("td",null,"0xC3"),l("td",null,"monitorexit"),l("td",null,"释放对象的monitor，用于同步块或同步方法")])])],-1),Ai=l("p",null,[i("Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。 **方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。**虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 方法标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。 "),l("strong",null,"同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义"),i(" 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。")],-1),vi=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"196"),l("td",null,"0xC4"),l("td",null,"wide"),l("td",null,"扩展访问局部变量表的索引宽度")]),l("tr",null,[l("td",null,"197"),l("td",null,"0xC5"),l("td",null,"multianewarray"),l("td",null,"创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶")]),l("tr",null,[l("td",null,"198"),l("td",null,"0xC6"),l("td",null,"ifnull"),l("td",null,"为 null 时跳转")]),l("tr",null,[l("td",null,"199"),l("td",null,"0xC7"),l("td",null,"ifnonnull"),l("td",null,"非 null 时跳转")]),l("tr",null,[l("td",null,"200"),l("td",null,"0xC8"),l("td",null,"goto_w"),l("td",null,"无条件跳转（宽索引）")]),l("tr",null,[l("td",null,"201"),l("td",null,"0xC9"),l("td",null,"jsr_w"),l("td",null,"跳转指定32bit偏移位置，并将jsr_w下一条指令地址入栈")])])],-1),pi=l("p",null,null,-1),mi=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"十进制"),l("th",null,"操作码"),l("th",null,"助记符"),l("th",null,"含义")])]),l("tbody",null,[l("tr",null,[l("td",null,"202"),l("td",null,"0xCA"),l("td",null,"breakpoint"),l("td",null,"调试时的断点")]),l("tr",null,[l("td",null,"254"),l("td",null,"0xFE"),l("td",null,"impdep1"),l("td",null,"用于在特定硬件中使用的语言后门")]),l("tr",null,[l("td",null,"255"),l("td",null,"0xFF"),l("td",null,"impdep2"),l("td",null,"用于在特定硬件中使用的语言后门")])])],-1),bi=l("p",null,null,-1),hi={href:"https://juejin.cn/post/7027707475503611940",target:"_blank",rel:"noopener noreferrer"},gi=l("h3",{id:"_4-参考",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#_4-参考","aria-hidden":"true"},"#"),i(" 4. 参考")],-1),fi={href:"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.iload",target:"_blank",rel:"noopener noreferrer"},xi={href:"https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html",target:"_blank",rel:"noopener noreferrer"},_i=t('<h2 id="_3-类加载" tabindex="-1"><a class="header-anchor" href="#_3-类加载" aria-hidden="true">#</a> 3. 类加载</h2><blockquote><ol><li>类加载子系统</li><li>类加载过程</li><li>类加载器分类及各自作用</li><li>类加载原则</li></ol></blockquote><h3 id="_1-目标" tabindex="-1"><a class="header-anchor" href="#_1-目标" aria-hidden="true">#</a> 1. 目标</h3><ul><li>找到相关class文件，并把class文件中的类信息加载到jvm中，使class文件变成可以被运行的相关程序</li><li>java源文件-&gt;.class文件，.class文件-&gt;jvm，jvm根据.class文件描述类的相关信息-&gt;jvm内存结构，</li></ul><blockquote><p>总结：</p><ol><li>类加载的目标是什么，它处于整个 JVM 架构的哪个阶段？</li><li>类加载的时机是什么？什么情况下才会加载一个类？</li><li>类加载机制的内容是什么？【包括类加载器、双亲委派模型、加载过程】</li><li>类加载的应用</li></ol></blockquote><blockquote><p>摘要：</p><ol><li>类加载过程，说白了一句话就是：通过全限定命名获取一个<strong>类的 class 对象</strong>的过程。</li><li>类加载过程，是通过类加载机制完成的，类加载机制包括【类加载器】、【双亲委派】、【加载过程】三部分。</li></ol></blockquote><h3 id="_2-加载过程原理简述" tabindex="-1"><a class="header-anchor" href="#_2-加载过程原理简述" aria-hidden="true">#</a> 2. 加载过程原理简述</h3><blockquote><p>一句话来讲，类的加载过程就是： 通过类的全限定命名来获取描述这个类的 class 对象。 因此需要注意的是： 我们常说的类的加载过程，并不单单指整个加载过程中的第一个阶段的加载部分，而是指整个过程。</p></blockquote><ol><li>通过全限定命名获取字节码文件</li><li>将字节码文件中的类元数据信息加载到运行时数据区的方法区</li><li>**在运行时数据区的堆中创建一个java.lang.Class类的对象，**这样便可以通过该对象访问方法区中的这些数据。</li></ol><blockquote><p>个人理解： <strong>在运行时数据区的堆中创建一个java.lang.Class类的对象</strong> 这里的堆，是逻辑上的堆，与运行期内存结构中的 Java 堆的概念不同，这里的堆事实上是指方法区，因为方法区事实上也是堆的一部分，都属于线程共享区域的区域，只不过这里的 <strong>java.lang.Class类的对象</strong>是一个特殊的对象，以后所有从这个类中 new 出来的对象都是以这个对象为原型的。这也侧面说明了一个事实，堆是整个垃圾回收的基础。</p></blockquote><ul><li>运行时数据区的分配 <ul><li>方法区上封装类的元数据信息</li><li>堆区上分配class对象</li></ul></li></ul><h3 id="_3-类加载的时机" tabindex="-1"><a class="header-anchor" href="#_3-类加载的时机" aria-hidden="true">#</a> 3. 类加载的时机</h3><ul><li><strong>采用预加载方式，即并不是首次使用时才加载</strong></li><li>时机【或触发条件】 <ul><li>使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）以及调用一个类的静态方法时</li><li>使用java.lang.reflect包的方法对类进行反射调用时</li><li>初始化一个类但发现其父类还没有进行初始化时</li><li>启动jvm时先加载包含main()方法的启动类</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ul></li><li>报错： 如果未加载，则在使用时会报错（LinkageError错误）；如果一直没有被使用，即便未加载也不会报错</li></ul><p>了解了类的加载过程，我们再看看类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p><ul><li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ul><p>同时以下几种情况不会执行类初始化：</p><ul><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化。</li><li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName(“jvm.Hello”)默认会加载 Hello 类。</li><li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）。</li></ul><p>示例: 诸如 Class.forName(), classLoader.loadClass() 等 Java API, 反射API, 以及 JNI_FindClass 都可以启动类加载。 JVM 本身也会进行类加载。 比如在 JVM 启动时加载核心类，java.lang.Object, java.lang.Thread 等等。</p><p>**两个没有关系的自定义类加载器之间加载的类是不共享的（只共享父类加载器，兄弟之间不共享），**这样就可以实现不同的类型沙箱的隔离性，我们可以用多个类加载器，各自加载同一个类的不同版本，大家可以相互之间不影响彼此，从而在这个基础上可以实现类的动态加载卸载，热插拔的插件机制等，具体信息大家可以参考OSGi等模块化技术。</p><h3 id="_4-加载工具-类加载器" tabindex="-1"><a class="header-anchor" href="#_4-加载工具-类加载器" aria-hidden="true">#</a> 4. 加载工具：类加载器</h3><p>从 jvm 的角度来讲，类加载器分为两种：</p><ul><li>启动类加载器： 它由 C++ 实现【特指，jdk1.5 之后的 Hotspot，很多虚拟机是由 Java 语言实现的】，它是 jvm 本身的一部分；</li><li>所有其他类的加载器： 都是由 Java 语言实现，并且独立于 jvm 之外，且全部继承自 java.lang.ClassLoader ，这些类加载器需要由启动类加载器加载到内存中之后才能加载其他类；</li></ul><p>从开发者角度来讲，类加载器分为四种：</p><blockquote><p>包括分类、各自负责加载的内容、使用方式等</p></blockquote><ul><li>BootstrapClassloader <ul><li>由c/c++语言实现（仅限Hotspot），主要是用来启动jvm</li><li>负责加载用来启动jvm时所需要的Java的核心库（jre/lib 下的类库 和 被-Xbootclasspath参数指定的路径中的且能被虚拟机识别的类库）</li><li>无法被java程序直接使用</li></ul></li><li>ExtensionClassloader <ul><li>由sun.misc.Launcher$ExtClassLoader实现；</li><li>负责加载lib/ext扩展目录下的类库和由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类）</li><li>开发者可以直接使用</li></ul></li><li>ApplicationClassloader <ul><li>由sun.misc.Launcher$AppClassLoader来实现；如果未自定义加载器，那它就是默认加载器</li><li>负责加载环境变量或系统属性java.class.path路径下的类库</li><li>开发者可以直接使用</li></ul></li><li>CustomerClassloader <ul><li>用户自定义的加载器</li></ul></li></ul><p>非继承关系，而是组合关系；</p><h3 id="_5-加载方式-双亲委派" tabindex="-1"><a class="header-anchor" href="#_5-加载方式-双亲委派" aria-hidden="true">#</a> 5. 加载方式：双亲委派</h3><ul><li>原理 <ul><li>把类加载请求委托给父类加载器，父类加载器再委托给自己的父类加载器，直到找到BootstrapClassloader，然后由BootstrapClassloader通过类的全限定名找到相关类进行加载，加载完成就进行返回，如果加载失败，就由BootstrapClassloader的子类加载器进行加载，依次类推， 直到加载完成。</li></ul></li><li>好处 <ul><li>避免类的重复加载</li><li>保证核心API不会被篡改</li></ul></li></ul><p>有些地方也把双亲委派直接称为类加载机制，其实类加载机制是一个比较全面的概念，双亲委派只是类加载机制中类加载器使用的规范。 类加载机制有三个特点：</p><ol><li><strong>双亲委派</strong>：当一个自定义类加载器需要加载一个类，比如 java.lang.String，它很懒，不会一上来就直接试图加载它，而是先委托自己的父加载器去加载，父加载器如果发现自己还有父加载器，会一直往前找，这样只要上级加载器，比如启动类加载器已经加载了某个类比如 java.lang.String，所有的子加载器都不需要自己加载了。如果几个类加载器都没有加载到指定名称的类，那么会抛出 ClassNotFountException 异常。</li><li><strong>负责依赖</strong>：如果一个加载器在加载某个类的时候，发现这个类依赖于另外几个类或接口，也会去尝试加载这些依赖项。</li><li><strong>缓存加载</strong>：为了提升加载效率，消除重复加载，一旦某个类被一个类加载器加载，那么它会缓存这个加载结果，不会重复加载。</li></ol><h3 id="_6-加载过程【每一个步骤的作用】" tabindex="-1"><a class="header-anchor" href="#_6-加载过程【每一个步骤的作用】" aria-hidden="true">#</a> 6. 加载过程【每一个步骤的作用】</h3><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>注意：</p><ol><li>这五个步骤，加载、校验、准备、初始化这四个阶段的发生顺序是确定的，而解析阶段却不一样，它在某些情况下可以在初始化之后开始，这是为了支持 Java 语言的运行时动态绑定；</li><li>这几个阶段是按照顺序开始的，但是不是按照顺序进行或完成的，这些阶段通常是都是互相交叉混合进行的，比如在验证阶段会激活加载阶段。</li><li>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</li><li></li></ol></blockquote><ul><li><p><strong>加载</strong></p><ul><li>目标： 找到对应的class文件</li><li>源文件来源渠道 <ul><li>加载Class文件的渠道 <ul><li>从本地系统中直接加载，这个文件可能是加密文件；</li><li>通过网络下载.class文件，典型场景是： Web Applet；</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件，比较少见</li><li>运行时计算生成，将Java源文件动态编译为.class文件，如动态代理技术；</li></ul></li></ul></li><li>自定义加载方式【可以通过哪些方式把类加载到jvm中？】 <ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载，将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li><li>通过ClassLoader.loadClass()方法动态加载，只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li></ul></li></ul></li><li><p>链接</p><ul><li>目标： 确保字节码正确加载，并被虚拟机正确赋值，之后转换链接方式（由<strong>符号引用转换成直接引用</strong>）</li><li>包括三个步骤： <ul><li><strong>校验（验证）</strong><ul><li>目的： 保证字节码文件不会危害虚拟机自身的安全</li><li>注意： 在校验过程中也会验证类的层次结构，因此有可能会发生加载的过程，如<strong>在验证到某个子类的 class 时，发现其父类 class 没有加载，于是就会在这个阶段去加载其父类 class</strong>。</li><li>主要验证四项内容 <ul><li>文件格式验证 <ul><li>.class文件，文件头会有 caffbabe 魔数，版本号等</li></ul></li><li>元数据验证 <ul><li>对class文件一些描述信息的数据的验证</li><li>元数据： 描述数据的数据</li></ul></li><li>字节码验证</li><li>符号引用验证</li></ul></li><li>可能抛出的异常 <ul><li>这些检查过程中可能会抛出 VerifyError， ClassFormatError 或 UnsupportedClassVersionError</li><li>类层次结构有问题（例如，该类是自己的超类或接口,死循环了），则 JVM 将抛出 ClassCircularityError。 而如果实现的接口并不是一个 interface，或者声明的超类是一个 interface，也会抛出 IncompatibleClassChangeError</li></ul></li></ul></li><li><strong>准备</strong><ul><li>为类变量分配内存并设置默认初始值</li></ul></li><li><strong>解析</strong><ul><li>把符号引用转化为直接引用 <ul><li>直接引用包括直接指针、相对偏移量和间接定位到目标对象的句柄</li></ul></li></ul></li></ul></li><li></li></ul></li><li><p><strong>初始化</strong></p><ul><li>JVM 规范明确规定, 必须在类的首次“主动使用”时才能执行类初始化。</li><li>执行类构造器方法&lt;clinit()&gt;的过程，补全剩余未被构造出来的部分</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>代码中下面的情况会触发初始化过程</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如Class.forName(“com.shengsiyuan.Test”)）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li></ul></div><blockquote><p><strong>TIPS 1： 准备阶段中【为变量设置默认初始值】 VS 初始化阶段</strong> 准备阶段中为变量设置默认初始值是指变量本身的默认值，如 boolean 的默认初始值为 false，int 的默认初始值为 0，引用类型的默认初始值为 null； 初始化阶段则是指代码中对变量的赋值，如 private int num = 30； 初始化阶段之前，num 的值为 0，初始化阶段完成之后，num 的值就变成了 30；</p><p><strong>TIPS 2 ：init() ， clinit() 和 无参构造函数 的执行顺序；</strong></p></blockquote><p>卸载： <strong>Java虚拟机将结束生命周期的几种情况</strong></p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h3 id="_7-其他" tabindex="-1"><a class="header-anchor" href="#_7-其他" aria-hidden="true">#</a> 7. 其他</h3><ul><li>查看 SpringBoot 项目都加载了哪些 jar 包？</li><li>自定义类加载器实现过程？</li><li>运行期动态加载 class 类？</li><li>父类构造器方法、静态方法、静态代码块、静态变量和子类的这些方法的加载顺序</li><li>两个class对象是否为同一个类存在两个必要条件？ <ul><li>类的全限定命名是否一致</li><li>加载这个类的加载器是否一致</li></ul></li></ul><h3 id="_8-自定义类加载器实现" tabindex="-1"><a class="header-anchor" href="#_8-自定义类加载器实现" aria-hidden="true">#</a> 8. 自定义类加载器实现</h3><h2 id="_4-线程模型" tabindex="-1"><a class="header-anchor" href="#_4-线程模型" aria-hidden="true">#</a> 4. 线程模型</h2><blockquote><ol><li>线程模型的发展历程</li><li>Java 中的线程模型</li></ol></blockquote><h3 id="_1-前置概念" tabindex="-1"><a class="header-anchor" href="#_1-前置概念" aria-hidden="true">#</a> 1. 前置概念</h3><blockquote><p>为什么在说 jvm 时，要先讲一下 Java 的内存模型？ 这个问题的关键在于，jvm 属于操作系统之上的应用，jvm 是通过调用操作系统对外提供的相关接口，来完成对计算机底层硬件计算资源的使用， 也就是说 jvm 使用计算机计算资源的方式是依赖于操作系统使用计算机计算资源的方式的。 因此要想了解 jvm 的整体架构，就必须要先了解计算机操作系统使用底层硬件计算资源的方式。 结合操作系统使用底层硬件计算资源的方式和计算机底层硬件系统架构，并结合“堆管存储，栈管运行”的特性，抽象总结出 JMM 的结构。 最后，基于 JMM 的内存结构，实现 JVM 运行时的基本架构，加上高级语言需要最终转化为机器语言的，最终才有了 JVM 的整体架构。</p></blockquote><h4 id="_1-1-并发和并行" tabindex="-1"><a class="header-anchor" href="#_1-1-并发和并行" aria-hidden="true">#</a> 1.1. 并发和并行</h4><p><img src="'+k+'" alt="并发" loading="lazy"><img src="'+C+'" alt="并行" loading="lazy"> 并发 ： 多个任务在单个处理器上运行，单个处理器通过划分时间片，让任务依次获取执行权限，看上去好像是多个任务同时发生一样，解决了不同任务执行过程中存在的阻塞问题，可以理解为任务阻塞时，就让出处理器的执行权限，目的是更大限度的压榨处理器的处理能力</p><p>并行： 同一时刻很多任务同时获得处理器的执行权限，利用了处理器的多核特性。</p><h4 id="_1-2-并发编程的发展" tabindex="-1"><a class="header-anchor" href="#_1-2-并发编程的发展" aria-hidden="true">#</a> 1.2. 并发编程的发展</h4><p>传统的计算机应用使用计算机的计算资源的方式，并没有因为计算机硬件的快速发展而改变，这就造成了计算机硬件的性能并没有得到显著提升。</p><p>因此人们迫切希望改变传统计算机使用计算机计算资源的方式，于是便出现了：</p><ol><li>使用缓存。</li><li>对指令进行重排序。</li><li>分时复用计算资源。</li></ol><p>基于上面的三个技术手段实现的编程过程，就可以成为并发编程，这也可以看做是并发编程的本质。</p><p>结果人们又发现使用这三项技术会导致并发编程的运算结果与我们实际预期的运算结果不一致。人们分析不一致的原因发现，实际上是因为，并发编程中有这样的需求：</p><ol><li>并发编程中的不同线程需要通信；</li><li>并发编程中的不同线程的指令没有保证顺序；</li></ol><p>这两个点是我们实现并发编程时一定会产生的两个需求，这是由计算机使用计算资源的方式决定的，不为人的意志转移而转移。</p><blockquote><p>比如，我们要实现从 1 加到 1 亿的过程，传统的方式就是简单的从 1 加到 1 亿，而有了多个核心的计算机硬件时，我们就希望 core1 实现从 1 加到 1 万，core2 实现从 1 万加到 2 万……最后把多个核心运算的结果再合并起来。多个核心单独运算时并不需要保证核心之间的运算顺序，只需要保证单个核心内部的运算顺序的正确性即可（这个例子中，单个核心似乎也不需要保证运算顺序），这就说明并发编程中不同线程的指令的运算不需要保证顺序性。最后要把多个核心运算的结果合并起来时，就需要进行线程间的通信问题。 我们也可以认为，如果并发编程中不需要通信，也不需要同步时，并发编程的运算结果就与我们实际的运算结果是一致的。但这种场景在实际的生活中是很少见的，几乎不存在。</p></blockquote><p>人们进一步追究，发现实际上是因为我们使用计算机计算资源的方式出了问题：</p><ol><li>使用缓存产生了<strong>可见性</strong>问题。由于不同缓存之间访问速度的差异导致存储在不同缓存上的同一个变量，在不同线程访问这个变量时会读出不同的值；</li><li>对指令进行重排序产生了<strong>顺序性</strong>问题。编译器把高级语言编译成机器语言时，为了压榨计算机的性能，会对指令进行重新排序，重新排序后的指令会产生不同的运算结果，有些结果是我们所希望的，有些结果则不是，这就说明重排序后的指令在顺序上存在着对的顺序和错的顺序的问题。</li><li>分时复用计算资源产生了<strong>原子性</strong>问题。由于程序以单位时间片的方式占用 CPU，且长的指令执行时间长，短的指令执行时间短，因此这就涉及到指令长短的问题，也就是指令划分的问题。</li></ol><p>人们通过各种复杂的技术手段解决了上面的三个问题后，发现并发编程的运算结果好像和我们预期的结果就一致了。于是我们就称并发编程安全了。由此引出并发编程三要素的概念：</p><ol><li>原子性</li><li>可见性</li><li>顺序性</li></ol><p>我们也说，<strong>遵循了并发编程三要素的程序是线程安全</strong>的。</p><p>在解决并发三要素问题过程中，人们根据并发编程需求的不同的实现思路，把并发编程模型分为两种：</p><ol><li>基于共享内存的并发编程模型；</li><li>基于消息通信的并发编程模型；</li></ol><h4 id="_1-3-操作系统指令集" tabindex="-1"><a class="header-anchor" href="#_1-3-操作系统指令集" aria-hidden="true">#</a> 1.3. 操作系统指令集</h4><p>不同的计算机硬件就意味着需要使用不同的指令进行操作，例如 CPU 有 CPU 的操作指令、内存有内存的操作指令、硬盘有硬盘的操作指令……这些指令组合起来之后就是计算机的指令集。针对不同的计算机架构，计算机的指令集也有所不同。但计算机架构确定下来之后，指令集也就确定下来了。 计算机指令的组合使用过程，又需要有一个协调过程，这个协调过程就可以看作是操作系统来完成的。而我们要想完成并发编程就只能基于操作系统来完成。也就是说，编程语言使用并发编程的计算机资源的方式只能是基于操作系统对外提供的接口来实现。注意，这里所说的并发编程是指高级语言的并发编程。这就说明，Java 语言中的并发编程也是基于操作系统来实现的。</p><p>事实上，JDK 通过屏蔽不同的操作系统的指令集的差异，来实现统一的并发编程过程【这也是 Java 语言的跨平台的原因】。也就是说，不同的厂商根据不同的操作系统实现不同的 JDK，然后程序员又基于不同的 JDK 【但都遵循 Java 语言规范】来实现并发编程。由于 JDK 都遵循 jdk 规范，程序员编写的 Java 代码又都遵循 Java 语言规范，因此对外的表现是同一个并发编程的 Java 代码，在不同的平台上的运算结果是一样的。</p><h3 id="_2-java-并发编程" tabindex="-1"><a class="header-anchor" href="#_2-java-并发编程" aria-hidden="true">#</a> 2. Java 并发编程</h3><p>Java 程序员编写遵循 Java 语言规范的并发编程代码，放到实现了统一的 JDK 规范的不同的 jdk 上运行，其运算结果是一样的。</p><p>在这个过程中，我们把 jdk 看作是调用操作系统接口的一个上层应用，我们编写的 Java 语言就是调用 jdk 接口的更上层次的应用。这样理解起来会更好理解一些。</p><h4 id="_2-1-jmm-模型" tabindex="-1"><a class="header-anchor" href="#_2-1-jmm-模型" aria-hidden="true">#</a> 2.1. JMM 模型</h4><p>JMM 是基于上面一章中说的基于共享内存的并发编程模型而实现的。JMM 模型中要求，工作线程直接复用操作系统层面的线程。因此，我们可以认为 JMM 模型中没有对分时复用技术上的优化【也就是说分时复用技术上的优化是有操作系统负责的】</p><p>在整个并发编程模型中，除了有操作系统层面针对并发三要素问题的解决措施外，JDK 在调用操作系统的并发编程接口时也有不同的解决措施，但是无论怎样，都是基于 JMM 模型来完成的，加之 JMM 模型中要求工作线程直接复用操作系统层面的线程，因此解决措施也就可以分成两部分：</p><ol><li>限制缓存的使用；</li><li>优化指令重排；</li></ol><p>Java 中限制缓存的使用和优化指令重排都是由 JDK 帮我们完成了的，程序员只需要使用 Java 语言规范完成并发编程的代码，就能实现准确的并发编程。事实上 Java 中限制缓存的使用，以及优化指令重排的工作是极其复杂的，在这个过程中有编译器的参与，也有执行引擎的参与，甚至还有针对运行期内存结构的优化手段【如栈上分配、标量替换、同步消除等】的参与等，甚至为了便于程序员使用并发编程，还在这些复杂的实现过程之上又帮我们封装了一套易用的框架，这个框架就是 JUC。</p><h3 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结" aria-hidden="true">#</a> 3. 总结</h3><figure><img src="'+M+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><hr><p>// TODO</p><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>栈管运行，堆管存储。</p><p>实现线程主要有三种方式</p><ul><li>内核线程 （1:1线程模型）</li><li>用户线程 （1:N 线程模型）</li><li>用户线程 + 轻量级进程 混合 （N:M 线程模型）</li></ul><figure><img src="'+j+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+J+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+G+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+y+'" alt="周志明《深入理解Java虚拟机》" tabindex="0" loading="lazy"><figcaption>周志明《深入理解Java虚拟机》</figcaption></figure>',87),ki=l("img",{src:E,alt:"image.png",loading:"lazy"},null,-1),Ci={href:"https://zhuanlan.zhihu.com/p/363839223",target:"_blank",rel:"noopener noreferrer"},Mi=t('<figure><img src="'+X+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一段程序的运行需要经过编译器</p><p>并发编程模型中，涉及到两个重要问题：</p><ol><li>线程如何实现同步；【为什么会出现这个问题】</li><li>线程如何实现通信；【为什么会出现这个问题】</li></ol><table><thead><tr><th></th><th>共享内存</th><th>消息传递</th></tr></thead><tbody><tr><td>如何实现同步</td><td>程序员显式地指定线程之间的互斥行为</td><td>消息的发送必须在消息的接收之前</td></tr><tr><td>如何实现通信</td><td>线程之间通过读-写公共状态进行通信</td><td>线程之间通过明确的发送消息进行通信</td></tr></tbody></table><p>Java 使用的是共享内存的编程模型。</p><ol><li>指令的原子性和顺序性；</li><li>变量的可见性；</li></ol><p>指令的顺序性指的是单条指令的顺序性还是多条指令的顺序？</p><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>总结：</p><ol><li>并发编程的根本性问题在于： <ol><li>如何<strong>实现线程之间通信</strong>。所谓通信就是对于共享状态的变量、代码片段等进行线程间的相互传递；</li><li>如何<strong>实现线程的同步</strong>。所谓同步就是让线程的执行顺序以我们所期望的顺序进行执行；</li><li>总结：这两个问题在高级语言层面的体现就是并发编程过程中运算结果与我们期望的结果不一致，也就是说这两个问题在高级语言层面上的体现就是内存可见性问题。因此，并发编程的根本性问题也可以说是<strong>内存一致性问题</strong>。</li></ol></li><li>解决上面所说的两个问题，有两种实现思路，人们根据这两种实现思路分别抽象出两种并发编程模型： <ol><li><strong>共享内存并发编程模型</strong>。通俗点说，就是把共享状态的变量或代码片段放到一个共享区域内，让线程共同操作这个共享区域。</li><li><strong>消息传递并发编程模型</strong>。通俗点讲，就是遇到共享状态的变量或代码片段时，就使用某种机制实现变更传递。</li><li>区别： 一个是让线程主动操作共享区域，另外一个是让共享状态通过某种机制实现主动通知。</li><li>Java 中使用的是<strong>共享内存并发编程模型</strong>，Java 把这种并发编程模型抽象成 JMM，即 Java 内存模型。</li></ol></li><li>由于更好的压榨计算机的运算能力，于是出现了： <ol><li>缓存技术。如寄存器、高速缓存等；</li><li>分时复用。对 CPU 运行时间进行分片，让程序以单位时间的方式占用 CPU ，从而达到对冲长指令阻塞等待的问题；</li><li>重排序。对指令进行重新排序，以最佳的顺序压榨运算能力。</li></ol></li><li>但这三种技术分别产生了三个问题： <ol><li>缓存技术 产生了 <strong>可见性</strong> 问题。由于不同缓存之间访问速度的差异导致存储在不同缓存上的同一个变量，在不同线程访问这个变量时会读出不同的值；</li><li>分时复用 产生了 <strong>原子性</strong> 问题。由于程序以单位时间片的方式占用 CPU，且长的指令执行时间长，短的指令执行时间短，因此这就涉及到指令长短的问题，也就是指令划分的问题。</li><li>重排序 产生了 <strong>顺序性</strong> 问题。编译器把高级语言编译成机器语言时，为了压榨计算机的性能，会对指令进行重新排序，重新排序后的指令会产生不同的运算结果，有些结果是我们所希望的，有些结果则不是，这就说明重排序后的指令在顺序上存在着对的顺序和错的顺序的问题。</li><li>说明： JVM 底层是调用操作系统的 API 完成运行我们写的程序的运行的，实际上 JVM 中的线程是与操作系统层面上的线程是一一对应的，而操作系统层面，线程的调用是 JVM 无法决定的。因此 JVM 是没有办法通过影响分时复用技术来解决原子性问题的，也就是说 JVM 只能使用操作系统指令集，没有办法再对操作系统指令集中的指令进行再划分或者再组合，但是操作系统指令集中的内存栅栏指令允许多个指令序列组合成一个原子指令，因此 JVM 可以使用内存栅栏的方式实现 JVM 层面上符合指令的 原子性；。因此 JVM 是没有办法影响缓存技术产生的可见性问题的，但是由于</li></ol></li><li>如果解决了【可见性】问题、【原子性】问题、【顺序性】问题，我们就可以说我们的程序是线程安全的。换句话来说，要想<strong>保证线程安全，需要我们运行的程序具有三要素——即保证可见性、原子性和顺序性</strong>，因此，我们又把这三个特性成为“<strong>并发三要素</strong>”。</li><li>要想解决这些问题，是需要编译器、执行器以及处理器共同完成，这是因为高级语言运行的环境中本身包含编译器、执行器和处理器的原因决定的。Java 语言运行时，核心在于调用操作系统 API 来完成运行过程的，因此 Java 语言只能从编译器和执行器的角度来保证并发三要素。而 Java 语言能做的事情却只有从对操作系统指令的应用的角度来解决这些问题，对操作系统指令的应用就只能是指令重排序的优化。这也是为什么 Java 语言中解决了重排序问题就解决了并发编程问题的原因。</li><li>JVM 中包含了编译器和执行引擎，因此 JVM 帮我们实现了一些技术，这些技术保证解决了【<strong>可见性</strong>】问题、【<strong>原子性</strong>】问题、【<strong>顺序性</strong>】问题中的某一部分，但是并没有完全解决，此时就需要我们在编写代码时遵循一些所谓的开发规范，最终达到线程同步的效果。事实上，Java 语言对并发编程安全性保证的措施可以分为两方面： <ol><li>基于 JVM。这部分是由运行在不同操作系统之上的，不同厂商实现的 JVM 来实现的。</li><li>基于 Java 语言的再抽象。这部分是由遵循统一的 Java 语言规范的 Java 框架来实现的。</li></ol></li><li>类比于计算机实现多线程的原理，以及基于共享内存的并发编程模型， Java 提出了 JMM 模型，即 Java 内存模型。</li><li>我们要遵循的开发规范就是 Java 语言的线程 同步 措施。这些同步措施基于 JMM 模型，整体被分为两部分： <ol><li>禁用缓存。Java 中使用 volatile、 synchronized、 final 关键字来进行约束；</li><li>指令优化。Java 中的编译器使用 Happens-Before 原则进行约束；</li></ol></li><li>基于 JMM 模型，Java 把运行时内存结构划分为线程共享和线程私有两部分区域。</li></ol><p>再总结：</p><ol><li><p>操作系统通过“分时复用”、“重排序”、“缓存技术”等技术手段，实现“尽可能压榨计算机性能”的目标。这三种技术手段可以看作是并发编程的底层实现，但这三个技术手段同样也带来了并发编程的三个问题：“原子性问题”、“顺序性问题”和“可见性问题”。如果保证了这三个问题，那么我们就说并发编程是安全的。</p></li><li><p>高级语言对并发编程的实现，一定是调用操作系统 API 来实现的，又由于高级语言的运行过程基本上都有高级语言编译成机器语言的过程，因此，高级语言只能从编译层面来解决并发编程的三个问题。例如，Java 语言需要经过编译器的编译后运行在执行引擎上，之后才是执行引擎调用执行操作系统 API，而编译器和执行引擎是 jdk 已经帮我们实现了的，因此，我们就需要了解 Java 语言层面上的并发编程的实现过程。往深层次讲，我们还需要了解编译器和执行引擎在解决并发编程问题时所做的措施，即 Java 语言的并发编程的底层原理。</p></li><li></li><li></li><li><p>并发编程性问题的表现是： 并发编程的运算结果与我们实际预期的并发编程问题不一致——这就是并发编程问题。</p></li><li><p>这就相当于操作系统对外提供了一系列并发编程的原语指令，让操作系统的上层应用通过灵活的调用操作系统的并发编程原语，来实现自己的并发编程。比如说，操作系统的一个语义是对 i 进行加一操作，它的过程可能是这样的，先从内存中读取 i 的初始值，然后在线程中对 i 进行加 1 操作，那原语指令可能就是：先 loadi，然后 addi，最后是 storei。但是对于操作系统的上层应用，我们看到的可能就是简单的一句话： i=i+1。这就说明了操作系统的上层应用对操作系统上的并发编程原语进行了封装，这样做的目的是为了方便使用并发编程。</p></li><li><p>但是对于 Java 语言来说，它的运行过程需要经过编译器+执行引擎+运行期内存结构，而这三部分是 jdk 根据不同的操作系统平台，已经帮我们实现了，这就说明 jdk 已经帮我们提供了调用操作系统并发编程原语的透明接口。这个透明的接口就是我们在实现并发编程时，遵循的 Java 语言规范。</p></li><li><p>又因为 Java 语言规范实现并发编程时，太过复杂，不够易用，因此为了让我们更加便捷地使用并发编程，Java 语言的设计者又在 Java 语言规范上面封装了一个易用的框架，这个框架就是 JUC。</p></li><li><p>说白了，JUC 就是 Java 语言规范为了方便程序员实现并发编程而封装的框架。因此，我们在学习时，不但要学习 Java 语言规范，还要学习其底层原理，底层原理就可以看作是 JVM 规范。</p></li><li><p>事实上，JDK 为了让我们透明的调用操作系统的并发编程原语做了很多工作，但是不管怎样，JDK 都是利用了限制指令优化和禁止使用缓存这两个思想。这两个思想是基于 JMM 来讲的。</p></li></ol><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><figure><img src="'+K+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）</p><hr>',17),Si={href:"https://pdai.tech/md/java/thread/java-thread-x-theorty.html",target:"_blank",rel:"noopener noreferrer"},ji=l("p",null,"Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。",-1),Ji=l("hr",null,null,-1),Gi={href:"https://pdai.tech/md/java/thread/java-thread-x-theorty.html",target:"_blank",rel:"noopener noreferrer"},yi=l("p",null,"as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题",-1),Ei=l("p",null,"编译上：在不改变程序执行结果的前提下，尽可能的开发并行度 执行上：具有执行顺序一致性",-1),Xi=l("p",null,"内存栅栏指令保证原子性",-1),Ti=l("p",null,"JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证",-1),Ki=l("p",null,"JMM 对正确同步的多线程程序的内存一致性做了如下保证：",-1),Oi=l("ul",null,[l("li",null,"如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）-- 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用")],-1),Vi=l("hr",null,null,-1),Pi={href:"https://pdai.tech/md/java/jvm/java-jvm-jmm.html",target:"_blank",rel:"noopener noreferrer"},zi=t('<h3 id="_4-happens-before-原则" tabindex="-1"><a class="header-anchor" href="#_4-happens-before-原则" aria-hidden="true">#</a> 4. Happens-Before 原则</h3><ul><li>线程原则： <ul><li>单一线程内，前面的操作先于后面的操作发生；</li><li>单一线程内，start()开始于其他操作；</li><li>结束行为发生</li></ul></li></ul><p>可以看作是 JVM 层面的，针对并发编程的“规范”。</p><hr><figure><img src="'+O+'" alt="使用arthas thread 命令查看jvm线程堆栈信息" tabindex="0" loading="lazy"><figcaption>使用arthas thread 命令查看jvm线程堆栈信息</figcaption></figure><p>虚拟机线程 周期任务线程 GC线程 编译线程 信号调度线程</p><p>程序运行方式是通过创建线程的方式进行运行的，而线程的运行过程包括两大过程：内存分配和任务调度，Jvm中的线程调度多是由操作系统的调度来实现的，因此了解线程的内存分配即可。</p><figure><img src="'+V+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>[6] Monitor Ctrl-Break [5] Attach Listener [4] Signal Dispatcher [3] Finalizer [2] Reference Handler [1] main</p><p>Attach Listener Attach Listener线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反 馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。</p><p>Signal Dispatcher 前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</p><p>Finalizer 这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：</p><ol><li>只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；</li><li>该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；</li><li>JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；</li><li>JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</li></ol><p>Reference Handler VM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。</p><p>Monitor Ctrl-Break 这个线程我也不是很明白是干什么用的，oracle官网有详细信息，大家可以去看看</p><figure><img src="'+P+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+z+'" alt="idea中启动一个Java程序的调试界面" tabindex="0" loading="lazy"><figcaption>idea中启动一个Java程序的调试界面</figcaption></figure><p>那问题来了，在linux下虽然创建了5个线程，但是当前活动线程只有两个，main和Monitor Ctrl-Break，这就导致了，我们在等待所有子线程结束后的那句判断代码应该是&gt;2而不是&gt;1!!!</p><p>while (Thread.activeCount() &gt; 2){ System.out.println(Thread.activeCount()); Thread.yield(); } 结论</p>',19),Fi={href:"https://blog.csdn.net/chenxi004/article/details/104972979",target:"_blank",rel:"noopener noreferrer"},Ni=t('<h2 id="_5-运行时内存结构" tabindex="-1"><a class="header-anchor" href="#_5-运行时内存结构" aria-hidden="true">#</a> 5. 运行时内存结构</h2><blockquote><ol><li>运行期内存结构</li><li>对象探秘</li></ol></blockquote><blockquote><p>研究思路：</p><ol><li>为什么要把运行期内存结构划分为线程私有区域和线程共享区域？根据 JMM 模型。</li></ol></blockquote><h3 id="_1-查看运行期内存结构" tabindex="-1"><a class="header-anchor" href="#_1-查看运行期内存结构" aria-hidden="true">#</a> 1. 查看运行期内存结构</h3><p>一般情况下，需要对内存 dump 下来一个某一时刻的快照信息，然后在这个快照上进行分析。</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-线程私有区域【生命周期与线程生命周期一致】" tabindex="-1"><a class="header-anchor" href="#_2-线程私有区域【生命周期与线程生命周期一致】" aria-hidden="true">#</a> 2. 线程私有区域【生命周期与线程生命周期一致】</h3><ul><li><strong>虚拟机栈</strong><ul><li>每当jvm需要运行一个线程时，就会在此区域划分出一小块内存，给这个线程使用，这一小块内存就是虚拟机栈，工作线程与虚拟机栈一一对应【可以认为：Java 中的一个请求对应一个栈帧。】</li><li>代码中的每一个方法就对应着虚拟机栈中的一个栈帧，代码中的方法与栈帧一一对应</li><li>方法的执行和结束对应着栈帧在线程所对应的虚拟机栈中的入栈和出栈操作，但不允许不同线程创建的栈帧之间的相互引用</li><li>线程运行结束后，此线程的栈帧就会消亡，因此虚拟机栈就不存在垃圾回收的问题</li><li>【重点】栈帧包括 <ul><li><strong>局部变量表</strong>（LV） <ul><li>基本单位是变量槽（slot），一个变量槽是32位，多个变量槽组成一个局部变量表</li><li>存放的信息主要是用来描述方法参数和局部变量，包括这些方法参数和变量的类型信息、值和索引；1. 索引信息是为了访问；2. 类型信息则标识了方法参数和局部变量的所属类型； <ul><li>基本数据类型 <ul><li>long和double占用2个slot</li><li>其余占用1个slot</li></ul></li><li>引用类型</li><li>returnAddress类型</li></ul></li><li>Slot是可以被复用的</li></ul></li><li><strong>操作数栈</strong>（Operate Stack） <ul><li>缓存计算的中间结果</li><li><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li><strong>动态链接</strong>（Dynamic Link） <ul><li>指向方法区中的运行时常量池的方法引用</li><li>额外知识点 <ul><li>链接的分类 <ul><li>静态链接：编译期可知，并且运行期会保持不变，在类加载过程就会把方法的符号引用转换为直接引用的过程</li><li>动态链接：被调用的方法在编译期无法被确定下来，只能在运行时把方法的符号引用转换为直接引用，高级语言中的多态性就是通过动态链接来完成的。</li></ul></li><li>被静态解析的条件 <ul><li>方法在运行前就有一个确定的调用版本</li></ul></li><li>方法的分类 <ul><li>非虚方法：在编译期就确定下来并且运行期不会发生改变的方法 <ul><li>静态方法</li><li>私有方法</li><li>final方法</li><li>实例构造器</li><li>父类方法</li></ul></li><li>虚方法：不能在编译期确定下来或者运行期可能会发生改变的方法，抛开非虚方法以外的方法都是虚方法</li></ul></li></ul></li></ul></li><li><strong>方法出口</strong>（Return Address） <ul><li>方法结束有两种方式 <ul><li>正常结束 <ul><li>会把方法的返回值给到上层调用者，即调用该方法的上层调用者线程的PC寄存器的值，由上层调用者线程继续执行</li></ul></li><li>遇到异常结束 <ul><li>不会给上层调用者返回任何值，即返回异常表中的异常信息，剩余没有执行完的线程也不再执行</li></ul></li></ul></li></ul></li><li><strong>附加信息</strong><ul><li>例如，支持调试程序的相关信息，这部分取决于虚拟机的实现</li></ul></li></ul></li><li>可能会出现的异常 <ul><li>当线程请求的深度大于虚拟机所允许的最大深度时，会出现StackOverflowError异常</li><li>当虚拟机尝试扩展但无法申请到足够的内存空间，或没有多余空间为新线程分配时，会出现OOM异常</li></ul></li><li>参数 <ul><li>-Xss，规定了函数调用的最大深度</li><li>一般情况下，不设置虚拟机栈的大小</li></ul></li><li><ol><li>线程与虚拟机栈是一对一关系；2. 代码中的方法与栈帧是一对一关系；3. 虚拟机栈与栈帧是一对多关系</li></ol></li><li>一个请求对应一个虚拟机栈。</li></ul></li><li><strong>本地方法栈</strong><ul><li>是使用C语言实现的，直接调用本地方法接口，即操作系统对外提供的接口</li><li>原理与虚拟机栈一样，只不过是执行的方法是本地方法，即操作系统方法</li><li>出现的异常也跟虚拟机栈一样</li></ul></li><li><strong>PC寄存器</strong><ul><li>存放程序运行的下一条指令的地址</li><li>多个线程的运行是通过操作系统随机分配CPU执行的时间片来完成的，那么在切换时间片时，就需要标记被切换的线程下一条指令的地址，这样就保证了这个线程再次获取执行权时，能够找到之前执行到的位置</li><li>唯一一个没有异常的区域</li></ul></li><li>虚拟机栈、本地方法栈和程序计数器均由所需要运行的线程来管理。线程结束，对应的虚拟机栈、本地方法栈和程序计数器区域被回收，供后续进行重新使用</li></ul><h3 id="_3-线程共享区域【生命周期与jvm的生命周期一致】" tabindex="-1"><a class="header-anchor" href="#_3-线程共享区域【生命周期与jvm的生命周期一致】" aria-hidden="true">#</a> 3. 线程共享区域【生命周期与jvm的生命周期一致】</h3><ul><li><strong>方法区</strong><ul><li>目标 <ul><li>字节码文件加载完成后存放的内存区域，主要是让线程“依葫芦画瓢”完成内存分配</li></ul></li><li>线程共享的原因 <ul><li>每一个需要运行的线程，都需要从这个区域内读取类的信息，因此是线程共享的区域</li></ul></li><li>存储的内容 <ul><li>域信息 <ul><li>包括域修饰符、域类型、域名称</li></ul></li><li>类型信息 <ul><li>包括类修饰符、全限定名称、直接父类的全限定名称、直接接口的有序列表</li></ul></li><li>方法信息 <ul><li>包括方法的修饰符、方法返回的类型、方法名称、参数列表、方法体信息（方法的字节码、操作数栈、局部变量表、方法大小）、异常信息表（每一个异常的开始位置、结束为止、PC计数器的偏移地址、异常类所在的常量池索引）</li></ul></li><li>non-final的类变量【即静态变量】 <ul><li>随着类的加载而加载，可以被这个类的所有实例访问，即便是没有类实例也可以访问</li></ul></li><li>声明了final的类变量【即全局变量】 <ul><li>编译期就已经被分配了</li></ul></li><li>运行期常量池 <ul><li>由class文件中的“常量池”生成 <ul><li>class文件中如果选择直接保存数据的方式，字节码文件就会很大。采用常量池方式存储数据，在实际运行过程中再按照常量池里面的信息为数据分配实际的存储空间，这样可以避免字节码文件臃肿庞大的问题</li></ul></li><li>存放编译期生成的各种字面量和符号引用</li></ul></li><li>JIT代码缓存</li></ul></li><li>垃圾回收 <ul><li>这个区域的回收效果比较难以令人满意</li><li>主要回收两部分内容 <ul><li>常量池中没有被任何地方引用的常量 <ul><li>回收过程类似于Java堆</li></ul></li><li>不再被使用的类型</li></ul></li></ul></li></ul></li><li><strong>Java堆</strong><ul><li>存放内容 <ul><li>对象</li><li>数组</li></ul></li><li>异常类型</li></ul></li><li>事实上，<strong>方法区和Java堆两部分内容才构成了整个JVM的堆空间</strong><ul><li><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul><h3 id="_4-直接内存区域" tabindex="-1"><a class="header-anchor" href="#_4-直接内存区域" aria-hidden="true">#</a> 4. 直接内存区域</h3><ul><li>NIO的使用区域，使用native方法直接分配内存，然后通过DirectByteBuffer对象进行引用；</li><li>不受Java堆大小的限制，但是受物理内存大小的限制；</li></ul><hr><ul><li>根据是否由用户线程共享使用把运行期内存数据区域划分为两部分 <ul><li>用户线程共享的区域（事先规定好总量的大小，来一个用户线程就划分一块区域给这个线程使用，与用户线程是一对多的关系，即一个区域对应多个用户线程） <ul><li><code>方法区</code><ul><li>保存类型信息、常量、静态变量、即时编译产生的代码缓存等</li><li>早期版本中有永久代的概念，是为了像管理堆一样管理方法区，但这种设计更容易遇到内存溢出的问题，于是后期版本中废弃了永久代的概念</li><li>这部分的回收目标是针对常量池（主要存放各种字面量和符号引用以及符号引用的直接引用）的回收和类型卸载，回收效果差强人意</li><li>当无法满足新的内存分配需求时会抛出OOM异常</li></ul></li><li><code>Java堆</code><ul><li>主要存放各种对象和数组</li><li>是由一个个TLAB组成，在内存中可以连续，也可以不连续，为了回收和访问效率，可能会要求大对象在内存上连续</li><li>“新生代”、“老年代”、“Eden区”、“Surivivor区”等都是具体的垃圾回收器在回收内存空间时对堆上存储内容的再次划分，不能说运行期内存就有这部分区域</li><li>一般通过“-Xmx”和“-Xmx”设定，当没有多余的内存空间分配时且堆无法进行扩展时会抛出OOM异常</li></ul></li></ul></li><li>用户线程私有的区域（与用户线程是一对一的关系，重要特征是会随着用户线程的消亡而消亡） <ul><li><code>PC计数器</code><ul><li>字节码的行号指示器，用来标记线程切换后的执行位置</li><li>没有OOM异常</li></ul></li><li><code>虚拟机栈</code><ul><li>只存放栈帧，Java中方法的执行对应着栈帧的入栈和出栈</li><li>栈帧中存放着局部变量表、操作数栈、动态链接和方法的出口等</li><li>局部变量存放着基本数据类型、对象类型和方法返回等</li><li>而基本数据类型是以Slot为基本单位进行分配的，long和double占2个Slot，其余全部是1个Slot</li><li>执行一个方法请求时，这个请求的线程会根据方法区的类型描述创建一个又一个栈帧，请求结束，线程会释放这里的空间</li><li>使用相关工具观察jvm运行期内存区域时，会发现此区域会随着请求的变化而变化</li><li>一般通过“-Xss”进行设定，当线程请求的栈的深度大于虚拟机所允许的最大深度或者栈扩展时无法申请到足够的内存时会抛出OOM异常</li></ul></li><li><code>本地方法栈</code><ul><li>与虚拟机栈类似，但存放的内容是本地方法的相关内容</li></ul></li><li><code>直接内存</code><ul><li>例如在NIO中会直接使用Native函数分配直接内存，然后使用DirectByteBuffer进行操作，使用完成后由线程直接释放</li><li>受到物理内存大小的限制，也会产生OOM</li></ul></li></ul></li></ul></li></ul><h3 id="_5-研究方法" tabindex="-1"><a class="header-anchor" href="#_5-研究方法" aria-hidden="true">#</a> 5. 研究方法</h3><ul><li><ol><li>明确所在运行期内存结构模型中的哪一部分</li></ol><ul><li>所在区域：堆</li></ul></li><li><ol start="2"><li>代码中实例化对象的方式</li></ol></li><li><ol start="3"><li>明确一个对象一般情况下都包含哪些内容？</li></ol><ul><li>对象的内存结构</li></ul></li><li><ol start="4"><li>明确对象包含的各个部分如何放到运行期内存结构模型中</li></ol><ul><li>对象的内存分布</li></ul></li><li><ol start="5"><li>明确对象的创建过程</li></ol><ul><li>对象的创建过程</li></ul></li><li><ol start="6"><li>明确如何使用对象（或者如何访问对象）</li></ol><ul><li>对象的访问定位</li></ul></li></ul><h3 id="_6-代码中实例化对象的方式" tabindex="-1"><a class="header-anchor" href="#_6-代码中实例化对象的方式" aria-hidden="true">#</a> 6. 代码中实例化对象的方式</h3><ul><li>new Object()</li><li>class的newInstance()方法</li><li>构造器的newInstance(args)方法</li><li>使用clone</li><li>反序列化</li><li>第三方工具包</li></ul><h3 id="_7-对象的内存结构" tabindex="-1"><a class="header-anchor" href="#_7-对象的内存结构" aria-hidden="true">#</a> 7. 对象的内存结构</h3><ul><li><strong>对象头（Header）</strong><ul><li>包括两部分内容 <ul><li>运行时元数据（Mark word） <ul><li><img src="'+U+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li>哈希值</li><li>GC分代年龄</li><li>锁标志位</li><li>线程持有的锁</li><li>偏向线程id</li><li>偏向时间戳</li></ul></li><li>类型指针 <ul><li>指向方法区的类型元数据InstanceKlass，确定该对象的类型信息</li></ul></li></ul></li><li>如果是数组，还会有数组的长度信息</li></ul></li><li><strong>实例数据（Instance data）</strong><ul><li>它存储了对象的实际信息，包括代码中定义的各种类型字段（包括从父类继承来的和自身拥有的）</li><li>规则 <ul><li>父类的定义的变量出现在子类之前</li><li>相同宽度的字段总是分配到一起</li><li>如果CompactFields参数为true，子类的窄变量可能会插入到父类变量的空隙空间</li></ul></li></ul></li><li><strong>对齐填充（Padding）</strong><ul><li>不是必须的，没有特殊含义，仅仅是为了保证内存分配规整</li></ul></li></ul><h3 id="_8-对象的内存分布" tabindex="-1"><a class="header-anchor" href="#_8-对象的内存分布" aria-hidden="true">#</a> 8. 对象的内存分布</h3><ul><li>与具体的JVM产品有关，不同的JVM产品，其模型可能不同 <ul><li>如Hotspot中 <ul><li><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li><li>对象在Hotspot中分代回收模型中的内存分配过程 <ul><li><ol start="0"><li>创建在栈上的对象随着方法执行的结束，由栈直接回收</li></ol></li><li><ol><li>创建的小对象直接分配到eden区，直到eden区满</li></ol></li><li><ol start="2"><li>eden区满了之后，会触发MinorGC/YoungGC，躲过MinorGC/YoungGC后的对象进入S0区</li></ol></li><li><ol start="3"><li>下次要创建的小对象依然放入eden区，直到eden区满</li></ol></li><li><ol start="4"><li>之后再次触发MinorGC/YoungGC，MinorGC/YoungGC会把S0区的对象复制到S1区，在复制过程中，会判断对象的年龄，如果对象的年龄大于jvm设置的最大年龄（默认15），就把S0区的对象复制到Tenured区，之后对换S0区和S1区位置</li></ol></li><li><ol start="5"><li>【Tenured区满】或【创建的对象所需要的空间大于S0区的可用空间，也大于老年代的可用空间】会触发FullGC，FullGC会回收整个堆空间（包括Java堆和方法区）</li></ol></li></ul></li></ul><h3 id="_9-对象的创建过程" tabindex="-1"><a class="header-anchor" href="#_9-对象的创建过程" aria-hidden="true">#</a> 9. 对象的创建过程</h3><ul><li><ol start="0"><li>事实上，在创建对象前，Hotspot-JVM会做一些优化，以确定把对象创建到何处以及如何优化对象创建过程</li></ol><ul><li>0.1 查看空间分配担保配置和对象年龄晋升（确定分配到哪个区域） <ul><li>对象升代策略 <ul><li>空间分配担保</li><li>大对象直接进入老年代</li><li>长期存活对象直接进入老年代</li><li>动态年龄判断</li></ul></li><li>空间分配担保（原理、优化手段） <ul><li>原理： 【空间分配担保策略】就是老年代空间能否担保新生代晋升为老年代对象时的空间</li><li>JDK6u24之前 <ul><li>问题：如果MinorGC/YoungGC之前，需要迁移到老年区的对象（此刻新生代所有对象的总大小）所需要的内存大于老年代剩余的最大可用的连续空间，那么到底是进行MinorGC/YoungGC还是要进行FullGC呢？</li><li>解答：使用空间分配担保。</li><li>过程详解 <ul><li>发生MinorGC/YoungGC之前，会先比较【需要迁移到老年区的对象（此刻新生代所有对象的总大小）所需要的空间大小】与【老年代剩余的最大可用连续空间的大小】关系 <ul><li>小于，说明MinorGC/YoungGC是安全的，可以进行MinorGC/YoungGC</li><li>大于，JVM会检查-XX:HandlePromotionFailure的值 <ul><li>为True，检查【老年代剩余的最大可用的连续空间是否】大于【历次晋升到老年代的对象的平均大小】 <ul><li>是，进行MinorGC/YoungGC，但是是不安全的</li><li>否，进行一次FullGC</li></ul></li><li>为False <ul><li>直接进行FullGC</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>JDK6u24及以后 <ul><li>保留了-XX:HandlePromotionFailure参数，但是已经不影响空间担保策略了，改为：如果【老年代剩余的最大可用连续空间】&gt; 【需要晋升的对象所需要的总空间 || 历代晋升到老年代所需要的平均空间大小】，就进行MinorGC/YoungGC，否则就进行FullGC</li></ul></li></ul></li></ul></li><li>0.2 首先会对对象进行逃逸分析，主要是分析对象的作用域（确定代码层面的优化，例如不该写同步的地方写了同步等） <ul><li>如果发现没有被外部访问，编译器就会做一些优化 <ul><li>【栈上分配】把对象分配到栈上 <ul><li>可以理解为只用一次的对象，用完之后当然需要立马清理掉才是最好的方式，而用完立马清理最好的方式当然就是放到栈帧里面，让它随着使用它的线程一并消失就行了 <ul><li>分配到TLAB上</li><li>参数 <ul><li>-XX:UseTLAB： 开启栈上分配</li><li>-XX:TLABWasteTargetPercent： 设置TLAB占用eden的百分比</li></ul></li></ul></li></ul></li><li>【同步消除】省略掉同步过程 <ul><li>对象访问的时候可能会遇到同步，经过逃逸分析后，发现压根不需要同步过程，编译器就会优化代码，把代码的同步过程消除掉，这个过程也称为锁消除</li></ul></li><li>【替换标量】替换成标量 <ul><li>经过逃逸分析后，发现一个对象不会被外界访问，就会把这个对象拆解成若干个小对象【相当于利用了“化整为零”的思想】 <ul><li>替换前的代码 <ul><li><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>等价于替换后的代码 <ul><li><img src="'+H+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li><li>参数： -XX:EliminateAllocations，默认是打开的，允许把对象打散分配到栈上</li><li>标量：无法分解成更小数据的数据，与之对应的是聚合量。</li></ul></li></ul></li><li>参数：jdk6u23已经默认开启逃逸分析了，但是也可以通过-XX:DoEscapeAnalysis显式开启，可以通过-XX:PrintEscapeAnalysis查看逃逸分析的相关日志</li><li>挑战： 逃逸分析技术并不成熟，根本原因在于无法保证逃逸分析的产出比，因为逃逸分析本身也是需要进行一系列的复杂分析的，这些辅助的分析也是需要一些性能损耗的。</li></ul></li></ul></li><li><ol><li>先去方法区的运行期常量池中检查是否能够定位到一个类的符号引用，检查这个类是否被加载、解析和初始化，没有的话就先执行类加载过程；</li></ol></li><li><ol start="2"><li>执行对象的内存分配过程</li></ol><ul><li>内存是规整的 <ul><li>指针碰撞</li></ul></li><li>内存是不规整的 <ul><li>空闲列表</li></ul></li></ul></li><li><ol start="3"><li>处理并发安全问题</li></ol><ul><li>意思是： 在代码的运行过程中可能会涉及到优化后的同步问题，这个时候要确定具体执行并发安全的方式，这些方式有两种： <ul><li>利用CAS算法+失败重试来保证更新的原子性</li><li>为每一个线程分配独立的TLAB空间</li></ul></li></ul></li><li><ol start="4"><li>把划分好的内存区域初始化为零值</li></ol></li><li><ol start="5"><li>进行必要的设置，包括</li></ol><ul><li>实例对象的类对象信息</li><li>元数据信息的定位</li><li>对象的哈希码</li><li>对象的GC分代年龄</li></ul></li><li><ol start="6"><li>执行init方法，完成其它资源和状态信息的构造</li></ol></li></ul><h3 id="_10-对象的访问定位过程" tabindex="-1"><a class="header-anchor" href="#_10-对象的访问定位过程" aria-hidden="true">#</a> 10. 对象的访问定位过程</h3><ul><li>问题描述：对象是如何通过栈帧中的对象引用找到堆中实际的对象信息的？</li><li>问题讲解：所谓对象信息包括两部分内容——对象实例信息和对象类型信息，而对象实例信息位于Java堆中，对象类型信息位于方法区 <ul><li><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>问题解答 <ul><li>句柄池方式 <ul><li><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>直接指针方式 <ul><li><img src="'+Y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul><p>直接指针的方式比着句柄池的方式少了一次饮用，积少成多的情况下也会带来非常可观的收益。</p><h2 id="_6-执行引擎" tabindex="-1"><a class="header-anchor" href="#_6-执行引擎" aria-hidden="true">#</a> 6. 执行引擎</h2><blockquote><ol><li>执行方式</li><li>方法的执行过程</li></ol></blockquote><blockquote><p>AOT</p></blockquote><h3 id="_1-执行方式" tabindex="-1"><a class="header-anchor" href="#_1-执行方式" aria-hidden="true">#</a> 1. 执行方式</h3><ul><li>解释执行 <ul><li>对字节码文件逐行解释执行，换言之，就是依次读取.class文件的每一行，然后把读取到的字节码“翻译”成机器语言进行执行 <ul><li>效率低下</li></ul></li></ul></li><li>编译执行（编译器分类及举例）</li></ul><h3 id="_2-包含内容" tabindex="-1"><a class="header-anchor" href="#_2-包含内容" aria-hidden="true">#</a> 2. 包含内容</h3><ul><li>解释器</li><li>即时编译器 <ul><li>分析器</li></ul></li><li>垃圾回收器</li></ul><h3 id="_3-执行过程" tabindex="-1"><a class="header-anchor" href="#_3-执行过程" aria-hidden="true">#</a> 3. 执行过程</h3><ul><li>Java运行分为两个阶段 <ul><li>第一阶段：把.java文件编译成.class文件 <ul><li><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>第二阶段：运行.class文件 <ul><li><img src="'+Q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul><hr><h3 id="_4-java中运行代码的方式分为两种-解释运行-和-编译运行。" tabindex="-1"><a class="header-anchor" href="#_4-java中运行代码的方式分为两种-解释运行-和-编译运行。" aria-hidden="true">#</a> 4. Java中运行代码的方式分为两种，<code>解释运行</code> 和 <code>编译运行</code>。</h3><p><code>解释运行</code>是对字节码文件逐行解释执行，换言之，就是依次读取.class文件的每一行，然后把读取到的字节码“翻译”成机器语言进行执行，这种方式效率低下。JS、JSP、ASP等语言都是解释型编程语言。</p><p><code>编译运行</code>则是将一种语言规范转化成另外一种语言规范，即将<code>便于人理解的语言规范</code>转化成<code>机器容易理解的语言规范</code>的过程就是编译。</p><h4 id="_4-1-编译器" tabindex="-1"><a class="header-anchor" href="#_4-1-编译器" aria-hidden="true">#</a> 4.1. 编译器</h4><p>编译运行一般情况下会有专门的编译器来完成编译工作，Java中根据编译器的作用把编译器分为三类：</p><ul><li>前端编译器，主要作用是把.java文件编译成.class文件，如javac、ECJ等；</li><li>后端编译器（JIT即时编译器），主要作用是把字节码文件转变成可执行的机器码，主要有两种C1和C2编译器，C1的启动时间比C2启动时间短，系统稳定后，C2执行效率比C1高；</li><li>静态提前编译器（AOT编译器），直接把.java文件转变成可执行的机器码，包括GCJ等，还处于实验阶段；</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>HotSpotJVM是两种方式并存的。运行过程原理大概是这样的：等待所有的代码编译完成再进行运行是不值得的，项目启动前期就要使用解释器解释执行一些代码，同时也会针对执行到的热点代码进行探测，对热点代码再进行编译执行，相当于对二者进行取长补短。</p><p>使用什么技术探测热点代码？</p><ul><li>使用<code>方法调用计数器</code>统计方法的调用次数，配置参数： -XX:CompileThreshold</li><li>使用<code>回边计数器</code>统计循环体的执行次数</li></ul><p>对热点代码的优化手段？</p><ul><li>栈上分配</li><li>同步消除</li><li>标量替换</li></ul></div><h4 id="_4-2-执行" tabindex="-1"><a class="header-anchor" href="#_4-2-执行" aria-hidden="true">#</a> 4.2. 执行</h4><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果</p><figure><img src="'+W+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="_7-垃圾回收理论" tabindex="-1"><a class="header-anchor" href="#_7-垃圾回收理论" aria-hidden="true">#</a> 7. 垃圾回收理论</h2><blockquote><p>垃圾对象的特点、收集的区域 垃圾对象的判断标准 垃圾对象的定位 垃圾对象的收集算法以及衍生问题</p></blockquote><h3 id="_1-研究方法" tabindex="-1"><a class="header-anchor" href="#_1-研究方法" aria-hidden="true">#</a> 1. 研究方法</h3><ul><li><ol><li>明确需要回收的区域在运行期内存结构模型中的位置</li></ol><ul><li>堆</li></ul></li><li><ol start="2"><li>明确何为垃圾（或垃圾有何特点）</li></ol></li><li><ol start="3"><li>明确如何定位垃圾（或如何标记垃圾）</li></ol></li><li><ol start="3"><li>明确如何回收垃圾（或垃圾回收算法）</li></ol></li><li><ol start="4"><li>明确垃圾回收的时机</li></ol></li><li><ol start="5"><li>垃圾回收需要考虑的问题</li></ol></li><li><ol start="6"><li>GC类型</li></ol></li></ul><h3 id="_2-回收区域在运行期内存结构模型中的位置" tabindex="-1"><a class="header-anchor" href="#_2-回收区域在运行期内存结构模型中的位置" aria-hidden="true">#</a> 2. 回收区域在运行期内存结构模型中的位置</h3><ul><li>栈管运行、堆管存储 <ul><li>线程私有区域：可以完全交由负责运行的线程来管理，线程运行结束，所占用的内存空间自然就应该被回收</li><li>线程共享区域： 生命周期与JVM的生命周期一致，需要额外的收集器进行收集 <ul><li>方法区 <ul><li>永久区/元空间 <ul><li>基本不收集，回收条件苛刻，判断一个类是否可以被回收，需同时满足 <ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有任何地方引用，无法在任何地方通过反射访问该类的方法</li></ul></li></ul></li></ul></li><li>Java堆 <ul><li>新生代 <ul><li>频繁收集</li></ul></li><li>老年代 <ul><li>较少收集</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="_3-垃圾对象定位" tabindex="-1"><a class="header-anchor" href="#_3-垃圾对象定位" aria-hidden="true">#</a> 3. 垃圾对象定位</h3><ul><li><p>引用计数法</p><ul><li>原理 <ul><li>给对象引用次数设置一个变量，每引用一次，就对这个变量+1，使用之后变量-1，变量为0即代表对象没有被引用，可以被回收，此对象属于垃圾对象</li></ul></li><li>缺点 <ul><li><ol><li>需要额外的空间来存储引用次数，增加了空间的开销</li></ol></li><li><ol start="2"><li>每次删减引用后，都需要操作这块空间，增加了时间的开销</li></ol></li><li><ol start="3"><li>无法处理循环引用的问题</li></ol></li></ul></li><li>优点 <ul><li>实现简单、回收效率高</li></ul></li></ul></li><li><p>可达性分析（Hotspot采用的方法）</p><ul><li>基本原理 <ul><li>在某一时刻的快照里，以GCRoot作为起始点，向下收集，收集的路径称为引用链，引用链上的所有对象都是存活对象；不在引用链上的对象为不可达对象，不可达对象就是要回收的垃圾对象 <ul><li>可作为GCRoot的对象元素 <ul><li>虚拟机栈所引用的对象</li><li>本地方法栈所引用的对象</li><li>方法区静态变量引用的对象</li><li>方法区常量引用的对象</li><li>同步锁持有的对象</li><li>虚拟机的内部引用，如常驻的异常对象、class对象、类加载器对象</li><li>虚拟机监控对象、本地代码缓存对象、JVMTI中注册的回调等</li></ul></li><li>临时性加入的对象</li></ul></li><li>我们希望有这样一种情况：如果内存空间足够时，就把对象保留到内存中；如果内存空间不够时，就清理掉对象。 <ul><li>对引用分等级，视内存紧张程度来决定是否回收 <ul><li>强引用，StrongReference <ul><li>只要存在强引用，就不会被回收</li></ul></li><li>软引用，SoftReference <ul><li>下次GC一定会回收软引用的对象</li></ul></li><li>弱引用，WeakReference <ul><li>下次GC前，不管空间是否够用，一律回收</li></ul></li><li>虚引用，PhantomReference <ul><li>虚引用的对象在回收时收到系统的一个通知</li></ul></li><li>终结引用，FinalReference <ul><li>供Finalizer线程找到被引用对象，并调用其finalization()方法，第二次GC时才能回收被引用对象</li></ul></li></ul></li></ul></li></ul></li><li>详细细节 <ul><li>对象的finalization()方法 <ul><li>Java语言提供的一种机制，为了让程序员控制一些类在销毁前做一些自定义操作</li><li>特性 <ul><li>可以被子类重写</li><li>程序员提供销毁前的自定义处理逻辑，实际调用过程则由JVM完成</li><li>垃圾回收器在销毁对象之前，总是会先调用一下对象的finalization()方法</li><li>垃圾收集器调用finalization()方法可能会导致对象“复活”，极端情况下垃圾收集器不会掉用finalization()方法</li></ul></li></ul></li><li>两次标记过程 <ul><li>第一次标记：筛选没有被GCRoot引用的对象 <ul><li>看GCRoot引用链上是否有此对象</li></ul></li><li>第二次标记：触发没有被GCRoot引用的对象的finalization()方法 <ul><li>finalization()方法已经被调用过。如果此对象没有重写finalization()方法且finalization()方法已经被虚拟机调用过了，或者此对象重写了finalization()方法，也已经被虚拟机调用过了，则直接标记这个对象为不可触及对象</li><li>finalization()方法还没有被调用过。链接如果此对象没有被调用过finalization()方法，虚拟机就会创建一个F-queue的队列，并把这个对象放到这个队列里面，之后由一个低优先级的Finalizer线程依次触发队列里面对象的finalization()方法。如果finalization()方法执行完成之后，对象依然没有与引用链上的其他对象建立引用，就标记此对象为不可触及对象，并剔除对列里面与引用链上的某一个对象建立了引用关系的对象</li></ul></li><li>判断一个对象能否被回收 <ul><li><img src="'+Z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul></li></ul></li><li><p>统计出所有需要回收的对象【Java堆上保存的就是Java对象，要回收当然就要统计出所有需要回收的对象】</p><ul><li>枚举根节点 <ul><li>迄今为止，所有收集器在枚举根节点这一步骤都是必须暂停用户线程的（jvm中在垃圾回收的时候单独开辟一个线程去收集垃圾的，在收集的过程中，用户线程在不断产生新的垃圾，因此需要暂停用户线程），如果根节点过多，那么收集就会耗费很长时间，也就是暂停时间过长，那么势必会影响整个jvm的吞吐量，因此一定会有一个地方存放着；</li><li>HotSpot的解决方案中，会使用一组称为OopMap的数据结构来达到这个目的，在类加载完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即使编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用</li></ul></li><li>更新记忆集 <ul><li>所有涉及到部分区域收集行为的垃圾收集器，都会<code>面临着非收集区域指向收集区域的跨区域引用的问题</code>；</li><li>额外开辟一块内存区域，然后创建一种数据结构，就记录非收集区域指向收集区域的指针或引用，这种数据结构就叫记忆集；每次垃圾回收时，只需要关注记忆集和根节点就行，免去了每次都要扫描全部区域的麻烦</li><li>简单来说，就是对收集区域进行划分，然后进行编号，之后就会形成一个数组，如果此区域包含了跨代引用或跨区域引用的对象，那么这个位置的值就设置为1，这样每次进行回收的时候，碰到为1的位置就不进行回收了，这样形成的数组就是卡表；</li><li>卡表由很多中具体的实现方式，可以卡对象的精度，也可以卡内存快的精度，还可以卡字长的精度。所谓卡对象的精度，就是对对象进行编号，存在跨代引用就把这个编号的值置为1，卡字长的精度，就是根据jvm的字长进行编号；</li><li>更新记忆集的时候也是会产生并发一致性的问题，即在垃圾回收需要读取记忆集信息的时候，会同时产生新的引用信息；HotSpot是使用写屏障的技术手段来解决这个问题的；</li><li>使用AOP的思想，在对象赋值操作时，对卡表进行更新，即在对象赋值操作时建立切面，然后生成更新卡表的代码语句；</li></ul></li><li>三色标记 <ul><li>收集线程所产生的开销会随着收集区域的扩大而扩大，这会造成jvm吞吐量的下降；</li><li>收集线程在进行第二次标记时，用户线程也在重新建立引用或删除引用，即第二次标记时，对象引用关系发生了改变，采用三色标记方式进行解决； <ul><li>黑色：第一次标记时，被垃圾回收器访问过，且这个对象的所有引用都被扫描过，那么把这个对象标记为黑色；</li><li>灰色：第一次标记时，被垃圾回收器访问过，但是至少有一个引用还没有被扫描到，那么就把这个对象标记为灰色；</li><li>白色：第一次标记时，没有被垃圾回收器访问过，那么就把这个对象标记为白色；</li></ul></li><li>第二次标记完成后，所有的灰色对象要么变成白色、要么变成灰色，之后垃圾回收器只需要回收白色对象，下次垃圾回收会再次忽略黑色对象，直接从白色对象进行第二次标记；</li></ul></li></ul></li></ul><h3 id="_4-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_4-垃圾回收算法" aria-hidden="true">#</a> 4. 垃圾回收算法</h3><h4 id="_4-1-垃圾对象特点" tabindex="-1"><a class="header-anchor" href="#_4-1-垃圾对象特点" aria-hidden="true">#</a> 4.1. 垃圾对象特点</h4><ul><li>绝大多数对象“朝生夕死”</li><li>熬过多次GC后的对象更难消亡</li><li>跨代引用相对于同代引用只占少数比例</li></ul><p>基于上述三条实践原理，把对象分为年轻代、老年代。</p><ul><li>划分 <ul><li>分区 <ul><li>如何划分区域 <ul><li>划分为等大小的小区域，化整为零</li></ul></li><li>如何回收 <ul><li>部分回收</li></ul></li></ul></li><li>分代（如何划分及各区域如何回收（或回收的算法）） <ul><li>新生代</li><li>老年代</li><li>方法区</li></ul></li><li>混合 <ul><li>分区+分代</li></ul></li></ul></li><li>清除垃圾 <ul><li>已有的理论成果——垃圾收集算法 <ul><li>标记整理：  让所有存活的对象向内存空间一端移动，然后清理掉边界以外的内存 <ul><li>原理 <ul><li><ol><li>标记阶段： Collector从引用根节点开始遍历，标记所有被引用的对象</li></ol></li><li><ol start="2"><li>清除阶段： 把可以被回收的对象的地址放置到一个空闲列表中，下次进行分配时，先判断垃圾空间是否够用，如果够用就存放</li></ol></li></ul></li><li>缺点 <ul><li><ol><li>效率不高</li></ol></li><li><ol start="2"><li>清理出来的空闲空间不是连续的，产生内存碎片</li></ol></li><li><ol start="3"><li>需要额外空间来保存被清理的对象的地址</li></ol></li></ul></li><li>使用场景 <ul><li>老年代对象收集过程</li></ul></li><li><img src="'+$+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>标记清除 <ul><li>原理 <ul><li><ol><li>标记阶段： Collector从引用根节点开始遍历，标记所有被引用的对象</li></ol></li><li><ol start="2"><li>清除阶段：清除掉没有被引用的对象</li></ol></li><li><ol start="3"><li>压缩阶段：把剩余没有被清理的对象压缩到内存的一端</li></ol></li></ul></li><li>优缺点 <ul><li><ol><li>解决了内存碎片问题</li></ol></li><li><ol start="2"><li>但是如果对象被其他对象引用，还需要调整引用的地址</li></ol></li></ul></li><li>使用场景 <ul><li>老年代对象收集过程</li></ul></li><li><img src="'+ll+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li>腾出来的空间再次分配时，可以使用“指针碰撞”的方式进行分配</li></ul></li><li>复制算法 <ul><li>原理 <ul><li>准备两块相同大小的内存空间，把应该保留的对象都复制到另外一块内存空间上，然后再把原来的内存空间全部清空即可</li></ul></li><li>优缺点 <ul><li>没有标记和清除阶段，运行效率较高</li><li>不会出现内存碎片问题</li><li>但是需要两倍内存空间</li><li>对于分区域收集的垃圾回收器，需要维护跨区域引用的关系，会产生额外的性能开销</li></ul></li><li>使用场景 <ul><li>适合<strong>垃圾对象较多，存活对象较少</strong>的场景。因此，<strong>是现在大多数商用虚拟机新生代所采用的收集算法</strong></li></ul></li><li><img src="'+il+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>增量收集算法 <ul><li>原理 <ul><li>通过妥善处理“垃圾清理线程”与“用户工作线程”的切换，让垃圾清理线程每次只清理一小块内存区域。</li></ul></li><li>优缺点 <ul><li>减少每次垃圾回收的停顿时间</li><li>需要妥善处理好“垃圾清理线程”与“用户工作线程”的切换问题，并且线程切换会带来损耗，造成系统吞吐量下降</li></ul></li></ul></li><li>分区收集算法 <ul><li>原理 <ul><li>把整块内存区域“化整为零”，每个小块空间独立使用，独立回收</li></ul></li><li>优缺点 <ul><li>可以控制每次回收多少个小区间，达到停顿时间可控的目的</li></ul></li></ul></li><li>都会产生STW <ul><li>GC发生过程中，会导致所有用户线程都暂停，像是整个世界都停止了一样</li><li>特性 <ul><li>所有的GC回收器都会产生</li><li>是由JVM主动发起的</li><li>调优的主要目的就是降低STW的停顿时间</li></ul></li><li>原因 <ul><li>收集垃圾时需要在一个一致性快照中进行，不能一边清理垃圾一边产生垃圾</li></ul></li><li>停顿的时间点 <ul><li>安全点 <ul><li>在某一时刻，所有的用户线程都会停下来，让jvm标识垃圾，这个时刻就是安全点。</li><li>所有的用户线程主动轮训一个GC标志位并采用主动中断的方式来挂起自身线程</li></ul></li><li>安全区 <ul><li>如果单单是安全点，那么所有的线程都会在这个点进行主动中断，这就会出现有些线程等待时间过长的问题，因此可以延长这个“时刻”，把“时刻”变成“时间段”，这个时间段就是安全区，在这个安全区内，代码引用关系不会发生改变，换言之在这个区域内任何地方开始GC操作，都是等价的。</li></ul></li></ul></li></ul></li></ul></li><li>最佳实践——分代收集算法 <ul><li>新生代 <ul><li>特点 <ul><li>区域小、对象生命周期短、存活率低、回收频繁</li></ul></li><li>最佳实践 <ul><li>复制算法</li></ul></li></ul></li><li>老年代 <ul><li>特点 <ul><li>区域大、对象生命周期长、存活率高、回收不是很频繁</li></ul></li><li>最佳实践 <ul><li>“标记清除”与“标记整理”混合使用</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="_5-垃圾回收的时机" tabindex="-1"><a class="header-anchor" href="#_5-垃圾回收的时机" aria-hidden="true">#</a> 5. 垃圾回收的时机</h3><ul><li>不能一边打扫房间一边丢垃圾，必须在某一时刻停止制造垃圾的用户线程。所以这个 【停止用户工作线程的时刻】 和 【用户工作线程的停止时间间隔】 就比较重要，不可能随时随地停止，也不可能停止无限长的时间。</li><li>用户工作线程停止的时刻 <ul><li>选择标准 <ul><li>是否具有让程序长时间执行的特征</li></ul></li><li>分类 <ul><li>安全点： 虚拟机会选取一些能够长时间执行的指令作为安全点，并在安全点处采用主动中断的方式挂起所有用户线程（主动中断就是用户线程主动去轮询一个GC标志位，如果标志位为真，表示要进行GC回收，此时用户线程就会主动中断）</li><li>安全区域 <ul><li>只有安全点的概念，会使主动中断等待的时间过长（GC线程等待所有用户线程都到达安全点才主动中断），试想在一个区域内才更加合理，这个区间就是安全区域</li></ul></li></ul></li><li>停顿之后主线程的工作方式</li></ul></li><li>用户工作线程停止的方式 <ul><li>主动中断 <ul><li>主动中断就是用户线程主动去轮询一个GC标志位，如果标志位为真，表示要进行GC回收，此时用户线程就会主动中断</li></ul></li><li>被动阻塞</li></ul></li><li>用户工作线程停止的时长 <ul><li>全局停顿时间 <ul><li>在新生代进行的GC叫做minor GC，在老年代进行的GC都叫major GC，Full GC同时作用于新生代和老年代。在垃圾回收过程中经常涉及到对对象的挪动（比如上文提到的对象在Survivor 0和Survivor 1之间的复制），进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿。Stop-The-World对系统性能存在影响，因此垃圾回收的一个原则是尽量减少“Stop-The-World”的时间</li></ul></li></ul></li></ul><h3 id="_6-垃圾回收需要考虑的问题" tabindex="-1"><a class="header-anchor" href="#_6-垃圾回收需要考虑的问题" aria-hidden="true">#</a> 6. 垃圾回收需要考虑的问题</h3><ul><li>要回收垃圾，就要暂停JVM中所有应用程序，理论上回收的区域越大、暂停的时间也就越多，用户线程等待时间也就越长；用户线程等待的时间越长，意味着相同时间内的吞吐量就越小；</li><li>性能指标 <ul><li>吞吐量 <ul><li>系统运行时间占总时间的比例</li></ul></li><li>停顿时间 <ul><li>二者是相互竞争的</li><li>调优的目标**： 在最大吞吐量优先的前提下，尽量缩短停顿时间**</li></ul></li><li>收集频率</li><li>内存占用</li><li>垃圾收集的开销</li><li>服务器性能指标</li><li>JVM性能指标</li><li>应用性能指标</li></ul></li></ul><h3 id="_7-gc类型" tabindex="-1"><a class="header-anchor" href="#_7-gc类型" aria-hidden="true">#</a> 7. GC类型</h3><ul><li>按照【部分回收 or 全部回收】分为 <ul><li>PartitionGC <ul><li>对整个堆空间的部分回收</li></ul></li><li>FullGC <ul><li>对整个堆空间进行整体回收，包括Java堆和方法区</li></ul></li></ul></li><li>按照【针对老年代进行回收 or 针对新生代进行回收】分为 <ul><li>MinorGC（有时也称YoungGC） <ul><li>对Eden区、S0区、S1区进行回收，回收过程会产生STW</li></ul></li><li>MajorGC <ul><li>只对Tenured区（养老区，也称老年代区）进行回收，回收过程也会产生STW，但是是新生代耗时的好几倍</li></ul></li></ul></li><li>事实上，我们对JVM调优，根本目的<strong>在于如何减少MajorGC是造成的STW的时间</strong></li></ul><h5 id="_7-0-1-minor-gc、major-gc、full-gc" tabindex="-1"><a class="header-anchor" href="#_7-0-1-minor-gc、major-gc、full-gc" aria-hidden="true">#</a> 7.0.1. Minor GC、Major GC、Full GC</h5><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。 针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： <ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 <ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 <ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><hr>',70),Ri={href:"https://pdai.tech/md/java/jvm/java-jvm-gc.html",target:"_blank",rel:"noopener noreferrer"},Di=t('<h3 id="_8-垃圾回收器分类" tabindex="-1"><a class="header-anchor" href="#_8-垃圾回收器分类" aria-hidden="true">#</a> 8. 垃圾回收器分类</h3><ul><li>按照线程工作模式 <ul><li>串行垃圾回收器</li><li>并行垃圾回收器</li></ul></li><li>按照碎片处理方式 <ul><li>压缩式垃圾回收器</li><li>非压缩式垃圾回收器</li></ul></li><li>按照工作的内存区间 <ul><li>新生代垃圾回收器</li><li>老年代垃圾回收器</li></ul></li></ul><h2 id="_8-hotspot-虚拟机-5020-配置-hotspot" tabindex="-1"><a class="header-anchor" href="#_8-hotspot-虚拟机-5020-配置-hotspot" aria-hidden="true">#</a> 8. Hotspot 虚拟机 &amp; 5020.配置 Hotspot</h2><blockquote><p>【还是理论部分】 经典垃圾回收器 针对不同垃圾回收器实现的实际的内存划分； 查看有哪些配置参数 各种配置参数讲解 配置参数表现行为等：如配置 printGCDetails，就会打印日志，打印日志是怎样的，如何理解这些日志等</p></blockquote><h3 id="_1-不同的回收方式具有不同的运行期内存结构模型" tabindex="-1"><a class="header-anchor" href="#_1-不同的回收方式具有不同的运行期内存结构模型" aria-hidden="true">#</a> 1. 不同的回收方式具有不同的运行期内存结构模型</h3><ul><li>分区 <ul><li>区域划分</li></ul></li><li>分代 <ul><li>Java8之前 <ul><li>新生代 <ul><li>Eden</li><li>S0</li><li>S1</li></ul></li><li>老年代Tenured</li><li>永久区，也就是方法区</li></ul></li><li>Java8及以后 <ul><li>新生代 <ul><li>Eden</li><li>S0</li><li>S1</li></ul></li><li>老年代Tenured</li><li>元空间，也就是方法区</li></ul></li></ul></li></ul><h3 id="_2-前置知识点" tabindex="-1"><a class="header-anchor" href="#_2-前置知识点" aria-hidden="true">#</a> 2. 前置知识点</h3><h4 id="_2-1-并发-vs-并行" tabindex="-1"><a class="header-anchor" href="#_2-1-并发-vs-并行" aria-hidden="true">#</a> 2.1. 并发 VS 并行</h4><figure><img src="'+nl+'" alt="1726200002579" tabindex="0" loading="lazy"><figcaption>1726200002579</figcaption></figure><p><img src="'+al+'" alt="1726200014505" loading="lazy"> 并发 ： 多个任务在单个处理器上运行，单个处理器通过划分时间片，让任务依次获取执行权限，看上去好像是多个任务同时发生一样，解决了不同任务执行过程中存在的阻塞问题，可以理解为任务阻塞时，就让出处理器的执行权限，目的是更大限度的压榨处理器的处理能力</p><p>并行： 同一时刻很多任务同时获得处理器的执行权限，利用了处理器的多核特性</p><p>串行：</p><h4 id="_2-2-内存溢出-vs-内存泄露" tabindex="-1"><a class="header-anchor" href="#_2-2-内存溢出-vs-内存泄露" aria-hidden="true">#</a> 2.2. 内存溢出 VS 内存泄露</h4><ul><li>内存溢出： 没有内存空间可用，并且经过垃圾回收器收集后依然没有内存空间可用</li><li>内存泄漏： 一些对象已经不再被应用程序使用，但是收集器又没有办法回收 <ul><li>常见的内存泄露 <ul><li>单例模式中单例对象持有对外部对象的引用</li><li>IO资源未关闭，如数据库链接、Socket链接、文件链接等</li></ul></li></ul></li></ul><h3 id="_3-七款经典垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_3-七款经典垃圾回收器" aria-hidden="true">#</a> 3. 七款经典垃圾回收器</h3><figure><img src="'+el+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>这里的并行是指： 垃圾收集线程由原来的单个垃圾收集线程变成多个垃圾收集线程，也就是说同一时间有多个垃圾收集线程在运行。 这里的并发是指： 垃圾收集线程和用户线程同时存在。</p><figure><img src="'+tl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="_3-1-串行收集器" tabindex="-1"><a class="header-anchor" href="#_3-1-串行收集器" aria-hidden="true">#</a> 3.1. 串行收集器</h4><ul><li>Serial收集器 <ul><li>针对新生代的收集器</li><li>采用复制算法</li><li>是Client模式下默认的新生代垃圾回收器</li><li>STW机制：在垃圾回收时，会使用<strong>一个CPU或一个收集线程</strong>来完成垃圾收集工作 <ul><li>意味着进行垃圾回收时，必须暂停其他工作线程</li></ul></li></ul></li><li>SerialOld 收集器 <ul><li>针对老年代的收集器</li><li>采用标记-整理算法</li><li>是Server模式下默认的老年代垃圾回收器</li><li>进行垃圾回收时也需要STW机制</li></ul></li><li>限定单核CPU才可以使用，一般web应用程序中是不会采用这种串行的垃圾收集器的 <ul><li>配合使用 <ul><li><img src="'+sl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul><h4 id="_3-2-并行收集器" tabindex="-1"><a class="header-anchor" href="#_3-2-并行收集器" aria-hidden="true">#</a> 3.2. 并行收集器</h4><blockquote><p>并行收集器利用了计算机多核的特性，扩展了串行收集器的并行收集能力。 强调的是收集器利用多核的特性。</p></blockquote><ul><li>ParNew收集器 <ul><li>除了采用并行回收的方式执行内存回收外，与Serial收集器几乎没有任何区别</li><li>同样采用复制算法、STW机制</li><li>是多数JVM运行在Server模式下新生代的默认垃圾收集器</li></ul></li><li>ParallelScavenge回收器 <ul><li>吞吐量优先的垃圾收集器</li><li>与ParNew收集器实现方式基本类似，只不过是保证了吞吐量优先</li><li>可以使用-XX:+UseAdaptiveSizePolicy，开启动态自适应策略，让JVM根据当前系统运行情况，动态调整新生代大小、Eden和Survivor区域的比例以及晋升老年代对象年龄，以期获得最合适的停顿时间或最大的吞吐量。</li></ul></li><li>ParallelOld收集器 <ul><li>除了采用并行回收的方式执行内存回收外，其他与SerialOld收集器几乎没有区别</li></ul></li><li>适合执行批量处理、订单处理、工资支付、科学计算的应用程序 <ul><li>配合使用 <ul><li><img src="'+dl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li></ul><h4 id="_3-3-并发收集器" tabindex="-1"><a class="header-anchor" href="#_3-3-并发收集器" aria-hidden="true">#</a> 3.3. 并发收集器</h4><h5 id="_3-3-1-cms-回收器" tabindex="-1"><a class="header-anchor" href="#_3-3-1-cms-回收器" aria-hidden="true">#</a> 3.3.1. CMS 回收器</h5><ul><li>让垃圾收集线程与用户工作线程并发执行</li><li>主要关注点是：减少停顿时间，低延迟</li><li>老年代的垃圾回收器，无法与ParallelScavenge回收器一并使用，只能配合ParNew和Serial串行收集器，在预留空间无法保证工作线程的运行时，就会临时启动Serial Old收集器作为老年代的垃圾回收器</li><li>原理及过程 <ul><li><ol><li>初始标记</li></ol><ul><li>利用STW机制，标记出GCRoot的对象，速度非常快</li></ul></li><li><ol start="2"><li>并发标记</li></ol><ul><li>并发标记出GCRoots的直接关联对象并遍历整个对象图，其过程是与工作线程一并工作，耗时较长但是不需要停顿用户线程，</li></ul></li><li><ol start="3"><li>重新标记</li></ol><ul><li>再次利用STW机制，标记第二阶段产生的新的变动的对象，但是垃圾收集线程是并发进行的</li></ul></li><li><ol start="4"><li>并发清除</li></ol><ul><li>与用户工作线程一同工作，清除掉已经死亡的对象，并释放空间</li><li>使用标记-清除算法 <ul><li>不可避免的会产生一些内存碎片，因此也不能使用指针碰撞的方式分配空间，只能使用空闲列表的方式分配空间</li><li>不使用标记-整理算法的原因：在清理的时候，用户线程还在使用对应的内存空间，整理内存空间会导致用户线程正在使用的内存空间失效。</li></ul></li></ul></li></ul></li><li>不会像其他老年代收集器一样，等到老年代几乎被填满之后才进行收集，而是当堆内存使用超过一个阈值后就开始进行回收，以确保程序在CMS运行期间有足够的空间支持应用程序的运行，如果预留的空间无法保证程序的运行，就会出现“Concurrent Mode Failuer”失败，此时JVM会临时启用Serial Old收集器作为老年代的垃圾收集器，停顿时间就会变的很长</li><li>优缺点 <ul><li>并发收集 <ul><li>垃圾收集线程与用户工作线程是并发执行的</li></ul></li><li>低延迟 <ul><li>除了初始阶段和重新标记阶段会出现短暂的停顿外，其他阶段不会出现停顿，是一款专注入低延迟的垃圾收集器</li></ul></li><li>会产生浮动垃圾 <ul><li>在并发清除阶段，由于用户工作线程依然在工作，也有可能会产生一些垃圾对象，但是此时CMS已经无法对这些对象进行标记，只能等到下次GC时再进行清除</li></ul></li><li>对CPU资源敏感 <ul><li>与等待老年代几乎填满后再进行垃圾回收的其他老年代收集器不同，CMS回收器是当堆空间使用到一定阈值时就会开始进行回收垃圾</li></ul></li><li>会产生内存碎片 <ul><li>并发清除阶段使用的是标记-清除算法，这种算法会产生内存碎片问题</li></ul></li></ul></li><li>迭代 <ul><li>JDK9及以后的版本，使用-XX:+UseConcMarkSweepGC开启CMS垃圾收集器时，会收到一个警告信息——提示CMS未来将被废弃</li><li>JDK14完全移除CMS，用户使用-XX:+UseConcMarkSweepGC显式开启CMS收集器时，不会收到提示，会自动使用默认的垃圾收集器进行收集</li></ul></li><li>特点 <ul><li>低延迟</li><li>并发标记</li><li><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul><h5 id="_3-3-2-g1-回收器" tabindex="-1"><a class="header-anchor" href="#_3-3-2-g1-回收器" aria-hidden="true">#</a> 3.3.2. G1 回收器</h5><ul><li>随着业务的发展，机器越来越先进，CPU核心数越来越多，JVM管理的内存越来越大，之前的GC收集器已经不能满足业务的要求了</li><li>基本原理 <ul><li>把堆空间使用“化整为零”的思想，划分成相同大小的多个区域，之后每次只回收部分区域。</li><li>把堆空间“化整为零”，分割成很多不相关的区域，并且G1会维护一个优先列表以便追踪每一个区域的垃圾堆积的价值大小，回收时优先回收价值最大的区域。</li></ul></li><li>回收过程 <ul><li>先进行年轻代GC【注意，要解决跨区域引用的问题】 <ul><li><img src="'+ul+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption><ul><li>如果没有被回收的区域内的对象引用了要回收的区域的对象，该如何解决？是否需要全堆扫描？全堆扫描的效率低下。使用记忆集进行解决，JVM会为每一个Region分配一个记忆集，记忆集中记录了本区域内哪些对象（包括引用类型对象）被其他区域所引用。在实际回收过程中，GCRoots引用链引用到的本区域内的对象加上记忆集中的对象构成整个存活对象集。</li><li>【重点】G1的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页（卡表的单个元素）的范围之内。G1的记忆集在存储结构的本质上是一 种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”），由于记忆集的存在，会造成JVM堆容量10%到20%的空间浪费。</li><li>卡表的作用是什么？记录当前区域内的引用类型对象在其他Region中的哪个区域（哪个卡页）。由于引用类型对象涉及到写-写操作时的同步问题，因此还需要“写屏障”技术避免线程安全问题，写屏障原理是使用中断的方式。</li></ul></li><li>当年轻代的Eden区用尽时开始年轻代回收过程，回收过程是并行的独占式的。G1会暂停所有工作线程，启动多线程回收年轻代，把年轻代的存活对象转移到S区或者老年区</li></ul></li><li>老年代并发标记过程（Concurrent Marking） <ul><li><img src="'+rl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption><ul><li>从GC日志中查看过程 <ul><li><img src="'+ol+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li><li><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li>当堆内存使用达到一定的值后，开始老年代并发标记过程</li></ul></li><li>混合回收（Mixed GC） <ul><li><img src="'+cl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption><ul><li><img src="'+Al+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>老年代并发标记过程完成后，立刻进入混合回收阶段，G1从老年代移动存活对象到空闲区间，使部分空闲区间成为老年代的一部分。老年代的回收并不是全部回收的，只回收其中的一部分。部分年轻代也一并回收</li></ul></li><li>（如果需要，单线程、独占式、高强度的FullGC还是继续存在的，它是针对GC的评估失败提供了一种失败保护机制，即强力回收） <ul><li><img src="'+vl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li><li>分区过程 <ul><li>如果设置了Region数量，那么Region大小就不是固定的，但是大小肯定是2的幂次方，并且在1~32M之间；如果设置了Region大小，那么Region数量就不是固定的，但是肯定是2048附近；</li><li>通过-XX:G1HeapRegionSize设定</li><li>分区大小一定相同，且在JVM生命周期内不会被改变</li></ul></li><li>特点 <ul><li><ol><li>属于分代型垃圾回收器，同时兼顾年轻代和老年代，不同Region之间使用复制算法，整体可以看作是标记-整理算法</li></ol></li><li><ol start="2"><li>并行性与并发性</li></ol></li><li><ol start="3"><li>空间整合</li></ol><ul><li>Region之间是复制算法，整体看上去是标记-整理算法</li></ul></li><li><ol start="4"><li>可预测的停顿时间模型</li></ol><ul><li>通过维护的优先列表，保证优先回收价值最大的Region，保证在有效的时间内获取尽可能高的收集效率</li></ul></li><li><ol start="5"><li>小内存应用上CMS表现优于G1，但大内存应用上G1表现优于CMS，平衡点6-8G</li></ol></li></ul></li><li>使用 <ul><li>jdk1.7移除了“实验”标志</li><li>jdk8中还不是默认的垃圾收集器，需要使用-XX:+UseG1GC进行启用</li><li>JDK9的默认垃圾回收器</li><li>避免使用-Xmn或-XX:NewRatio等显式设置年轻代大小，因为这些参数会覆盖设置的暂停时间参数，最好是让垃圾回收器自己调节</li><li>避免使用苛刻的暂停时间目标</li></ul></li><li><img src="'+pl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+ml+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption><ul><li>每个Region的角色只能是E、S、O、H中的一个，但是随着GC的过程，身份是不确定的，有可能这次GC前是E，下次GC就变成了O</li><li>设置H（大对象区域）的原因： 之前垃圾回收器，会把大对象默认分配到老年代中，但是如果它是一个短期存在的对象，这就会对老年代区域产生影响，G1就划分了一个H角色来保存大对象，并规定如果一个H区装不下，就寻找连续的H区来存储。</li></ul></li></ul><h4 id="_3-4-组合使用" tabindex="-1"><a class="header-anchor" href="#_3-4-组合使用" aria-hidden="true">#</a> 3.4. 组合使用</h4><figure><img src="'+bl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+hl+'" alt="周志明-第三版" tabindex="0" loading="lazy"><figcaption>周志明-第三版</figcaption></figure><ul><li>组合使用 <ul><li>组合关系</li><li><img src="'+gl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li>目前，基本上都使用G1</li><li><img src="'+fl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+xl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+_l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul><h4 id="_3-5-展望" tabindex="-1"><a class="header-anchor" href="#_3-5-展望" aria-hidden="true">#</a> 3.5. 展望</h4><ul><li>Serial GC在Serverless应用场景下找到了新的舞台</li><li>CMS GC在jdk9中被标记为废弃，JDK14中移除</li><li>ZGC和Shenandoah主打低延迟，可以做到在不影响吞吐量的前提下，实现任意堆内存大小下的停顿时间限制在10毫秒以内的低延迟</li></ul><h3 id="_4-代码运行方式" tabindex="-1"><a class="header-anchor" href="#_4-代码运行方式" aria-hidden="true">#</a> 4. 代码运行方式</h3><ul><li>混合运行模式（解释运行+编译运行）</li><li>解释器</li><li>编译器 <ul><li>分类 <ul><li>前端编译器 <ul><li>把.java文件转变成.class文件 <ul><li>包括javac、ECJ等</li></ul></li></ul></li><li>后端编译器，也叫JIT编译器 <ul><li>把字节码文件转变成可执行的机器码 <ul><li>C1编译器 <ul><li>对字节码进行简单可靠的优化，以期达到更快的编译速度，是虚拟机client模式下的默认编译器</li><li>优化手段 <ul><li>方法内联</li><li>去虚拟化</li><li>冗余消除</li></ul></li></ul></li><li>C2编译器 <ul><li>对字节码进行长时间的优化，以期达到更高的代码执行效率，是虚拟机server模式下的默认编译器</li><li>优化手段 <ul><li>栈上分配</li><li>同步消除</li><li>标量替换</li></ul></li></ul></li><li>C1的启动时间比C2启动时间短，系统稳定后，C2执行效率比C1高</li></ul></li></ul></li><li>静态提前编译器，也叫AOT编译器 <ul><li>直接把.java文件转变成可执行的机器码 <ul><li>包括GCJ等，还处于实验阶段</li></ul></li></ul></li><li>HotSpotJVM是两种方式并存的 <ul><li>原理：等待所有的代码编译完成再进行运行是不值得的，项目启动前期就要使用解释器解释执行一些代码，同时也会针对执行到的热点代码进行探测，对热点代码再进行编译执行。相当于对二者进行取长补短 <ul><li>使用热点探测技术探测热点代码 <ul><li>如何探测热点代码 <ul><li>使用方法调用计数器 <ul><li>统计方法的调用次数</li><li>-XX:CompileThreshold</li></ul></li><li>回边计数器 <ul><li>统计循环体的执行次数</li></ul></li></ul></li><li>探测到热点代码后 <ul><li>栈上分配</li><li>同步消除</li><li>标量替换</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="_5-常用参数总结" tabindex="-1"><a class="header-anchor" href="#_5-常用参数总结" aria-hidden="true">#</a> 5. 常用参数总结</h3><ul><li>Java堆 <ul><li>-Xms <ul><li>Java堆初始化大小，默认是物理内存总容量/64</li></ul></li><li>-Xmx <ul><li>Java堆最大容量，默认是物理内存总容量/4</li></ul></li><li>-XX:NewRatio <ul><li>【老年代容量：新生代容量】的比例，默认是2，表示新生代占总容量的1/3，老年代占总容量的2/3</li></ul></li><li>-Xmn <ul><li>新生代的最大容量，S0+S1+Eden所能使用的最大容量，一般默认即可</li></ul></li><li>-XX:SurvivorRatio <ul><li>S0、S1与Eden区的比例，默认是8，表示S0:S1:Eden=1:1:8</li></ul></li><li>-XX:MaxTenuringThreshold <ul><li>对象进入老年代区的最大年龄，默认是15</li></ul></li><li>-XX:HandlePromotionFailure <ul><li>是否开启空间分配担保</li><li>值为True/False</li></ul></li><li>-XX:UseTLAB <ul><li>是否开启TLAB</li><li>值为True/False</li></ul></li><li>-XX:TLABWasteTargetPencent <ul><li>设置TLAB占用Eden空间的大小</li></ul></li><li>一般情况下会把这两个值设置成相同数值，目的是为了减少内存重新分配的次数，提高性能</li></ul></li><li>虚拟机栈 <ul><li>-Xss <ul><li>线程的最大栈空间，决定了函数的最大调用深度，常见的值有25k、64k、128k等</li></ul></li></ul></li><li>方法区 <ul><li>JDK8以前 <ul><li>-XX:PermSize</li><li>-XX:MaxPermSize</li></ul></li><li>JDK8及以后 <ul><li>-XX:MetaspaceSize</li><li>-XX:MaxMetaspaceSize</li></ul></li><li>-Xnoclassgc <ul><li>不开启方法区的gc</li></ul></li><li>-XX:+TraceClass-Loading / -XX:+TraceClassUnloading <ul><li>查看类加载和类卸载信息</li></ul></li></ul></li><li>执行器 <ul><li>-Xint <ul><li>完全使用解释器的方式执行</li></ul></li><li>-Xcomp <ul><li>完全使用即时编译器的方式执行 <ul><li>-client <ul><li>使用C1编译器，对字节码进行简单可靠的优化，达到更快的编译速度</li></ul></li><li>-server <ul><li>使用C2编译器，对字节码进行较长时间的优化，达到更高的代码执行效率</li></ul></li></ul></li></ul></li><li>-Xmixed <ul><li>使用混合的方式执行</li></ul></li></ul></li><li>垃圾回收器 <ul><li>-XX:+UseSerialGC <ul><li>指定jvm在新生代和老年代收集内存时都是用串行收集器 <ul><li>等价于新生代使用Serial收集器、老年代使用SerialOld收集器</li></ul></li></ul></li><li>-XX:+UseParNewGC <ul><li>表示新生代使用ParNew的收集器，不影响老年代</li></ul></li><li>-XX:+UseParallelGC <ul><li>手动指定新生代使用Parallel并行收集器</li></ul></li><li>-XX:+UseParallelOldGC <ul><li>手动指定老年代使用并行收集器</li></ul></li><li>-XX:+UseG1GC <ul><li>手动指定使用G1垃圾回收器</li></ul></li><li>-XX:ParallelGCThreads <ul><li>使用并行收集器时，设置年轻代并行收集器的线程数，默认与CPU数量一致 <ul><li><img src="'+kl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li></ul></li><li>-XX:MaxGCPauseMillis <ul><li>设置垃圾收集器最大停顿时间，STW时间，单位是毫秒</li></ul></li><li>-XX:+UseAdapterSizePolicy <ul><li>ParallelScavenge开启自适应策略 <ul><li>JVM会自动调整年轻代区域大小、Eden与S区比例、老年代年龄等参数，以达到堆大小、吞吐量和停顿时间的平衡点</li><li>手动调优比较困难的场景下，可以设置此参数，把调优工作交给jvm</li></ul></li></ul></li><li>-XX:GCTimeRatio <ul><li>垃圾收集时间占总时间的比例</li><li>取值范围：0-100，默认是99，表示垃圾回收时间不超过1%</li></ul></li><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+CMSInitialingOccupanyFraction</li><li>-XX:+UseCMSCompactAtFullCollection</li><li>-XX:CMSFullGCsBeforeCompaction</li><li>-XX:ParallelCMSThreads</li><li>-XX:G1HeapRegionSize <ul><li>设置每一个Region的大小</li></ul></li><li>-XX:ConcGCThreads <ul><li>设置并发表计的线程数</li></ul></li><li>-XX:InitiatingHeapOccupancyParcent <ul><li>设置并发GC的Java堆占用率的阈值，超过就出发GC，默认是45</li></ul></li><li>JDK8默认的收集器，开启其中一个，另外一个也会被开启，相互激活</li></ul></li><li>监控参数 <ul><li>-XX:+PrintGC</li><li>-Xloggc:../logs/gc.log</li><li>-verbose:gc</li><li>-XX:+PrintGCDetails <ul><li>打印GC详细信息</li></ul></li><li>-XX:+PrintGCTimeStamps <ul><li>输出GC的时间戳，以基准时间的形式</li></ul></li><li>-XX:+PrintGCDateStamps <ul><li>输出GC的时间戳，以日期的形式，如2013-05-04T21:34:24.123+0800</li></ul></li><li>-XX:+PrintHeapAtGC <ul><li>在进行GC的前后打印堆信息</li></ul></li><li>-XX:+PrintFlagsInitial <ul><li>查看jvm所有参数初始默认值</li></ul></li><li>-XX:+PrintFlagsFinal <ul><li>查看jvm所有参数最终值</li></ul></li><li>打印GC简要信息</li></ul></li></ul><h3 id="_6-日志分析" tabindex="-1"><a class="header-anchor" href="#_6-日志分析" aria-hidden="true">#</a> 6. 日志分析</h3><ul><li>MinorGC <ul><li><img src="'+Cl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>FullGC <ul><li><img src="'+Ml+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>日志样例</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>2023-04-04T12:08:11.670+0800: 104.882: [GC (Allocation Failure) [PSYoungGen: 262144K-&gt;43503K(305664K)] 282367K-&gt;138752K(1005056K), 0.0710736 secs] [Times: user=0.34 sys=0.06, real=0.07 secs] 

【2023-04-04T12:08:11.670+0800】 表示发生GC的时间戳
【104.882】表示从JVM启动，到打印这行日志，经过了104.882秒的时间
【GC (Allocation Failure) 】表示GC触发的类型是『Allocation Failure』，即分配失败
【[PSYoungGen: 262144K-&gt;43503K(305664K)]】 表示新生代使用的是ParraleScavenge回收器，262144K-&gt;43503K，表示从262144K回收到43503K，305664K表示新生代总容量
【282367K-&gt;138752K(1005056K) 】 表示整个堆从282367K降到138752K，堆的总容量为1005056K
【0.0710736 secs 】 表示GC的时间是0.0710736秒
【Times: user=0.34 sys=0.06, real=0.07 secs 】 表示整个GC过程中，用户态占用时间、系统态占用时长和真实用时

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>2023-04-04T12:06:27.811+0800: 1.023: <span class="token url">[<span class="token content">Full GC (Metadata GC Threshold) [PSYoungGen: 16268K-&gt;0K(305664K)</span>] [<span class="token variable">ParOldGen: 24K-&gt;15506K(699392K)</span>]</span> 16292K-&gt;15506K(1005056K), [Metaspace: 20436K-&gt;20434K(1067008K)], 0.0200635 secs] [Times: user=0.07 sys=0.00, real=0.02 secs] 
这是FullGC的过程日志。
新生代总大小为305664K，从16268K降到0K；
老年代总大小为699392K，GC前为24K，GC后为15506K；
整个堆大小为1005056K，GC前为16292K，GC后为15506K；
元空间总大小为：1067008K，GC前为20436K，GC后为20434K；
Times: user=0.07 sys=0.00, real=0.02 secs ： 表示整个GC过程中，用户态占用时间、系统态占用时长和真实用时

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>2023-04-04T12:09:49.638+0800: 202.850: <span class="token url">[<span class="token content">Full GC (Ergonomics) [PSYoungGen: 116735K-&gt;0K(160256K)</span>] [<span class="token variable">ParOldGen: 699391K-&gt;14256K(699392K)</span>]</span> 816127K-&gt;14256K(859648K), [Metaspace: 40493K-&gt;40493K(1087488K)], 0.0174834 secs] [Times: user=0.07 sys=0.01, real=0.02 secs] Heap PSYoungGen total 160256K, used 41013K [0x00000007aab00000, 0x00000007c0000000, 0x00000007c0000000)  eden space 116736K, 35% used [0x00000007aab00000,0x00000007ad30d7f8,0x00000007b1d00000)  from space 43520K, 0% used [0x00000007bd580000,0x00000007bd580000,0x00000007c0000000)  to space 116224K, 0% used [0x00000007b1d00000,0x00000007b1d00000,0x00000007b8e80000) ParOldGen total 699392K, used 14256K [0x0000000780000000, 0x00000007aab00000, 0x00000007aab00000)  object space 699392K, 2% used [0x0000000780000000,0x0000000780dec388,0x00000007aab00000) Metaspace used 41838K, capacity 43950K, committed 44592K, reserved 1087488K  class space used 5400K, capacity 5783K, committed 5936K, reserved 1048576Kused 

已使用的空间大小capacity：当前已经分配且未释放的空间容量大小committed：当前已经分配的空间大小reserved：预留的空间大小capacity + 已经被释放的空间容量 = committed

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-工具包" tabindex="-1"><a class="header-anchor" href="#_9-工具包" aria-hidden="true">#</a> 9. 工具包</h2><blockquote><p>Hotspot 工具包 第三方工具包 使用案例</p></blockquote><h3 id="_1-jvm自带工具" tabindex="-1"><a class="header-anchor" href="#_1-jvm自带工具" aria-hidden="true">#</a> 1. JVM自带工具</h3><h4 id="_1-1-jps" tabindex="-1"><a class="header-anchor" href="#_1-1-jps" aria-hidden="true">#</a> 1.1. jps</h4><h4 id="_1-2-jstack" tabindex="-1"><a class="header-anchor" href="#_1-2-jstack" aria-hidden="true">#</a> 1.2. jstack</h4><h4 id="_1-3-jmap" tabindex="-1"><a class="header-anchor" href="#_1-3-jmap" aria-hidden="true">#</a> 1.3. jmap</h4><h4 id="_1-4-jcmd" tabindex="-1"><a class="header-anchor" href="#_1-4-jcmd" aria-hidden="true">#</a> 1.4. jcmd</h4><h4 id="_1-5-jinfo" tabindex="-1"><a class="header-anchor" href="#_1-5-jinfo" aria-hidden="true">#</a> 1.5. jinfo</h4><h4 id="_1-6-jprofiler" tabindex="-1"><a class="header-anchor" href="#_1-6-jprofiler" aria-hidden="true">#</a> 1.6. jprofiler</h4><h4 id="_1-7-jvisualvm" tabindex="-1"><a class="header-anchor" href="#_1-7-jvisualvm" aria-hidden="true">#</a> 1.7. jvisualvm</h4><p>jcmd jmap jinfo pid // jstack pid // 查看当前jvm有哪些进程，初步排查线程健康状况，如果多数线程处于等待状态，很可能就有问题了 jstat -gc pid // GC回收情况 jps -l</p><figure><img src="`+Sl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+jl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li>把堆内存dump下载 jps //查看pid jmap -dump:format=b,file=heap.1 pid //不进行垃圾回收直接dump jmap -dump:live,format=b,file=heap.2 pid //进行fgc垃圾回收在进行dump jmap -histo:live pid //进行fgc垃圾回收在进行dump</li><li>使用java VisualVM(lib目录下jdk8自带)导入dump文件</li></ol><h3 id="_2-第三方工具" tabindex="-1"><a class="header-anchor" href="#_2-第三方工具" aria-hidden="true">#</a> 2. 第三方工具</h3>',58),Ui={href:"https://arthas.aliyun.com/",target:"_blank",rel:"noopener noreferrer"},wi={href:"https://github.com/alibaba/arthas/issues/1892",target:"_blank",rel:"noopener noreferrer"},Bi={href:"https://blog.openresty.com.cn/cn/dynamic-tracing/",target:"_blank",rel:"noopener noreferrer"},Hi={href:"https://github.com/alibaba/arthas/issues/1202",target:"_blank",rel:"noopener noreferrer"},Li={href:"https://blog.csdn.net/qq_43692950/article/details/122688520",target:"_blank",rel:"noopener noreferrer"},Ii={href:"https://blog.csdn.net/qq_14996421/article/details/115982546",target:"_blank",rel:"noopener noreferrer"},Yi=t('<h3 id="_3-安装" tabindex="-1"><a class="header-anchor" href="#_3-安装" aria-hidden="true">#</a> 3. 安装</h3><h3 id="_4-启动" tabindex="-1"><a class="header-anchor" href="#_4-启动" aria-hidden="true">#</a> 4. 启动</h3><p>java -jar arthas-boot.jar</p><h3 id="_5-常用命令" tabindex="-1"><a class="header-anchor" href="#_5-常用命令" aria-hidden="true">#</a> 5. 常用命令</h3><ol><li>dashboard</li><li>thread -b</li><li>jvm</li><li>heapdum /path/to/hproffile/my.hprof</li><li></li></ol><h3 id="_6-常用场景" tabindex="-1"><a class="header-anchor" href="#_6-常用场景" aria-hidden="true">#</a> 6. 常用场景</h3><ol><li>查看jvm参数</li><li>查看阻塞的线程</li><li>生成堆栈快照文件</li><li>查看仪表盘</li><li>查看类加载信息</li><li>在线更换.class文件</li><li>项目启动时，查看各个区域所使用的比例，来判断各个参数的配置应该是多少</li></ol><h3 id="_7-控制面板" tabindex="-1"><a class="header-anchor" href="#_7-控制面板" aria-hidden="true">#</a> 7. 控制面板</h3><p>发送请求，发现 『ps_old_gen』 区域的使用容量越来越大，如下面两张图，<strong>这说明有很多大对象进入了老年代。</strong></p><figure><img src="'+Jl+'" alt="图1" tabindex="0" loading="lazy"><figcaption>图1</figcaption></figure><figure><img src="'+Gl+'" alt="图2" tabindex="0" loading="lazy"><figcaption>图2</figcaption></figure><h3 id="_8-利用arthas生成dump文件" tabindex="-1"><a class="header-anchor" href="#_8-利用arthas生成dump文件" aria-hidden="true">#</a> 8. 利用Arthas生成dump文件</h3><figure><img src="'+yl+'" alt="生成dump文件到指定目录" tabindex="0" loading="lazy"><figcaption>生成dump文件到指定目录</figcaption></figure><h3 id="_9-arthas的其他命令" tabindex="-1"><a class="header-anchor" href="#_9-arthas的其他命令" aria-hidden="true">#</a> 9. Arthas的其他命令</h3><ol><li>运行</li></ol><figure><img src="'+El+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="2"><li>选取一个应用进行链接</li></ol><figure><img src="'+Xl+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="3"><li>查看仪表盘</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[arthas@41713]$ dashboard

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+Tl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+Kl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+Ol+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[arthas@47132]$ jvm
 RUNTIME                                                                                                                                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MACHINE-NAME                                                         47132@ShawndeMacBook-Pro.local                                                                                                                                               
 JVM-START-TIME                                                       2023-04-02 21:28:43                                                                                                                                                          
 MANAGEMENT-SPEC-VERSION                                              1.2                                                                                                                                                                          
 SPEC-NAME                                                            Java Virtual Machine Specification                                                                                                                                           
 SPEC-VENDOR                                                          Oracle Corporation                                                                                                                                                           
 SPEC-VERSION                                                         1.8                                                                                                                                                                          
 VM-NAME                                                              OpenJDK 64-Bit Server VM                                                                                                                                                     
 VM-VENDOR                                                            Azul Systems, Inc.                                                                                                                                                           
 VM-VERSION                                                           25.282-b08                                                                                                                                                                   
 INPUT-ARGUMENTS                                                      -Xms100m                                                                                                                                                                     
                                                                      -Xmx100m                                                                                                                                                                     
                                                                      -verbose:gc                                                                                                                                                                  
                                                                      -XX:+PrintGCDetails                                                                                                                                                          
                                                                      -XX:+PrintGCDateStamps                                                                                                                                                       
                                                                      -XX:+HeapDumpOnOutOfMemoryError                                                                                                                                              
                                                                      -XX:HeapDumpPath=/Users/shawnwang/Downloads/jvm-logs                                                                                                                         
                                                                      -XX:ErrorFile=/Users/shawnwang/Downloads/jvm-logs/java_err.log                                                                                                               
                                                                      -Xloggc:/Users/shawnwang/Downloads/jvm-logs/gc.log                                                                                                                           
 CLASS-PATH                                                           jvm-test-0.0.1-SNAPSHOT.jar                                                                                                                                                  
 BOOT-CLASS-PATH                                                      /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/Jav 
                                                                      aVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachin 
                                                                      es/zulu-8.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Con 
                                                                      tents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/classes                                                                            
 LIBRARY-PATH                                                         /Users/shawnwang/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.                           
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CLASS-LOADING                                                                                                                                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 LOADED-CLASS-COUNT                                                   8164                                                                                                                                                                         
 TOTAL-LOADED-CLASS-COUNT                                             8164                                                                                                                                                                         
 UNLOADED-CLASS-COUNT                                                 0                                                                                                                                                                            
 IS-VERBOSE                                                           false                                                                                                                                                                        
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 COMPILATION                                                                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 NAME                                                                 HotSpot 64-Bit Tiered Compilers                                                                                                                                              
 TOTAL-COMPILE-TIME                                                   3537                                                                                                                                                                         
 [time (ms)]                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GARBAGE-COLLECTORS                                                                                                                                                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PS Scavenge                                                          name : PS Scavenge                                                                                                                                                           
 [count/time (ms)]                                                    collectionCount : 16                                                                                                                                                         
                                                                      collectionTime : 36                                                                                                                                                          
 PS MarkSweep                                                         name : PS MarkSweep                                                                                                                                                          
 [count/time (ms)]                                                    collectionCount : 2                                                                                                                                                          
                                                                      collectionTime : 61                                                                                                                                                          
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MEMORY-MANAGERS                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CodeCacheManager                                                     Code Cache                                                                                                                                                                   
 Metaspace Manager                                                    Metaspace                                                                                                                                                                    
                                                                      Compressed Class Space                                                                                                                                                       
 PS Scavenge                                                          PS Eden Space                                                                                                                                                                
                                                                      PS Survivor Space                                                                                                                                                            
 PS MarkSweep                                                         PS Eden Space                                                                                                                                                                
                                                                      PS Survivor Space                                                                                                                                                            
                                                                      PS Old Gen                                                                                                                                                                   
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MEMORY                                                                                                                                                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HEAP-MEMORY-USAGE                                                    init : 109051904(104.0 MiB)                                                                                                                                                  
 [memory in bytes]                                                    used : 33169048(31.6 MiB)                                                                                                                                                    
                                                                      committed : 95420416(91.0 MiB)                                                                                                                                               
                                                                      max : 96993280(92.5 MiB)                                                                                                                                                     
 NO-HEAP-MEMORY-USAGE                                                 init : 2555904(2.4 MiB)                                                                                                                                                      
 [memory in bytes]                                                    used : 59594664(56.8 MiB)                                                                                                                                                    
                                                                      committed : 63012864(60.1 MiB)                                                                                                                                               
                                                                      max : -1(-1 B)                                                                                                                                                               
 PENDING-FINALIZE-COUNT                                               0                                                                                                                                                                            
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 OPERATING-SYSTEM                                                                                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 OS                                                                   Mac OS X                                                                                                                                                                     
 ARCH                                                                 aarch64                                                                                                                                                                      
 PROCESSORS-COUNT                                                     8                                                                                                                                                                            
 LOAD-AVERAGE                                                         2.14892578125                                                                                                                                                                
 VERSION                                                              13.0.1                                                                                                                                                                       
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 THREAD                                                                                                                                                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 COUNT                                                                30                                                                                                                                                                           
 DAEMON-COUNT                                                         26                                                                                                                                                                           
 PEAK-COUNT                                                           30                                                                                                                                                                           
 STARTED-COUNT                                                        35                                                                                                                                                                           
 DEADLOCK-COUNT                                                       0                                                                                                                                                                            
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 FILE-DESCRIPTOR                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MAX-FILE-DESCRIPTOR-COUNT                                            10240                                                                                                                                                                        
 OPEN-FILE-DESCRIPTOR-COUNT                                           202                                                              

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -server -Xms100m -Xmx100m -verbose:gc -XX:+PrintGCDetails \\
-XX:+PrintGCDateStamps \\
-XX:+HeapDumpOnOutOfMemoryError \\
-XX:HeapDumpPath=/Users/shawnwang/Downloads/jvm-logs \\
-XX:ErrorFile=/Users/shawnwang/Downloads/jvm-logs/java_err.log \\
-XX:+UseG1GC -XX:SoftRefLRUPolicyMSPerMB=0 -XX:SurvivorRatio=8 \\
-Xloggc:/Users/shawnwang/Downloads/jvm-logs/gc.log \\
-jar jvm-test-0.0.1-SNAPSHOT.jar 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+Vl+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[arthas@46428]$ jvm
 RUNTIME                                                                                                                                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MACHINE-NAME                                                         46428@ShawndeMacBook-Pro.local                                                                                                                                               
 JVM-START-TIME                                                       2023-04-02 21:19:08                                                                                                                                                          
 MANAGEMENT-SPEC-VERSION                                              1.2                                                                                                                                                                          
 SPEC-NAME                                                            Java Virtual Machine Specification                                                                                                                                           
 SPEC-VENDOR                                                          Oracle Corporation                                                                                                                                                           
 SPEC-VERSION                                                         1.8                                                                                                                                                                          
 VM-NAME                                                              OpenJDK 64-Bit Server VM                                                                                                                                                     
 VM-VENDOR                                                            Azul Systems, Inc.                                                                                                                                                           
 VM-VERSION                                                           25.282-b08                                                                                                                                                                   
 INPUT-ARGUMENTS                                                      -Xms100m                                                                                                                                                                     
                                                                      -Xmx100m                                                                                                                                                                     
                                                                      -verbose:gc                                                                                                                                                                  
                                                                      -XX:+PrintGCDetails                                                                                                                                                          
                                                                      -XX:+PrintGCDateStamps                                                                                                                                                       
                                                                      -XX:+HeapDumpOnOutOfMemoryError                                                                                                                                              
                                                                      -XX:HeapDumpPath=/Users/shawnwang/Downloads/jvm-logs                                                                                                                         
                                                                      -XX:ErrorFile=/Users/shawnwang/Downloads/jvm-logs/java_err.log                                                                                                               
                                                                      -XX:+UseG1GC                                                                                                                                                                 
                                                                      -XX:SoftRefLRUPolicyMSPerMB=0                                                                                                                                                
                                                                      -XX:SurvivorRatio=8                                                                                                                                                          
                                                                      -Xloggc:/Users/shawnwang/Downloads/jvm-logs/gc.log                                                                                                                           
 CLASS-PATH                                                           jvm-test-0.0.1-SNAPSHOT.jar                                                                                                                                                  
 BOOT-CLASS-PATH                                                      /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/Jav 
                                                                      aVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachin 
                                                                      es/zulu-8.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Con 
                                                                      tents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/jre/classes                                                                            
 LIBRARY-PATH                                                         /Users/shawnwang/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.                           
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CLASS-LOADING                                                                                                                                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 LOADED-CLASS-COUNT                                                   8783                                                                                                                                                                         
 TOTAL-LOADED-CLASS-COUNT                                             8791                                                                                                                                                                         
 UNLOADED-CLASS-COUNT                                                 8                                                                                                                                                                            
 IS-VERBOSE                                                           false                                                                                                                                                                        
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 COMPILATION                                                                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 NAME                                                                 HotSpot 64-Bit Tiered Compilers                                                                                                                                              
 TOTAL-COMPILE-TIME                                                   5532                                                                                                                                                                         
 [time (ms)]                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GARBAGE-COLLECTORS                                                                                                                                                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 G1 Young Generation                                                  name : G1 Young Generation                                                                                                                                                   
 [count/time (ms)]                                                    collectionCount : 8                                                                                                                                                          
                                                                      collectionTime : 50                                                                                                                                                          
 G1 Old Generation                                                    name : G1 Old Generation                                                                                                                                                     
 [count/time (ms)]                                                    collectionCount : 0                                                                                                                                                          
                                                                      collectionTime : 0                                                                                                                                                           
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MEMORY-MANAGERS                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CodeCacheManager                                                     Code Cache                                                                                                                                                                   
 Metaspace Manager                                                    Metaspace                                                                                                                                                                    
                                                                      Compressed Class Space                                                                                                                                                       
 G1 Young Generation                                                  G1 Eden Space                                                                                                                                                                
                                                                      G1 Survivor Space                                                                                                                                                            
                                                                      G1 Old Gen                                                                                                                                                                   
 G1 Old Generation                                                    G1 Eden Space                                                                                                                                                                
                                                                      G1 Survivor Space                                                                                                                                                            
                                                                      G1 Old Gen                                                                                                                                                                   
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MEMORY                                                                                                                                                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HEAP-MEMORY-USAGE                                                    init : 109051904(104.0 MiB)                                                                                                                                                  
 [memory in bytes]                                                    used : 55500944(52.9 MiB)                                                                                                                                                    
                                                                      committed : 109051904(104.0 MiB)                                                                                                                                             
                                                                      max : 109051904(104.0 MiB)                                                                                                                                                   
 NO-HEAP-MEMORY-USAGE                                                 init : 2555904(2.4 MiB)                                                                                                                                                      
 [memory in bytes]                                                    used : 68178360(65.0 MiB)                                                                                                                                                    
                                                                      committed : 71303168(68.0 MiB)                                                                                                                                               
                                                                      max : -1(-1 B)                                                                                                                                                               
 PENDING-FINALIZE-COUNT                                               0                                                                                                                                                                            
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 OPERATING-SYSTEM                                                                                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 OS                                                                   Mac OS X                                                                                                                                                                     
 ARCH                                                                 aarch64                                                                                                                                                                      
 PROCESSORS-COUNT                                                     8                                                                                                                                                                            
 LOAD-AVERAGE                                                         1.33984375                                                                                                                                                                   
 VERSION                                                              13.0.1                                                                                                                                                                       
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 THREAD                                                                                                                                                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 COUNT                                                                45                                                                                                                                                                           
 DAEMON-COUNT                                                         41                                                                                                                                                                           
 PEAK-COUNT                                                           46                                                                                                                                                                           
 STARTED-COUNT                                                        53                                                                                                                                                                           
 DEADLOCK-COUNT                                                       0                                                                                                                                                                            
                                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 FILE-DESCRIPTOR                                                                                                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 MAX-FILE-DESCRIPTOR-COUNT                                            10240                                                                                                                                                                        
 OPEN-FILE-DESCRIPTOR-COUNT                                           202                 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ thread -b
&quot;http-bio-8080-exec-4&quot; Id=27 TIMED_WAITING
    at java.lang.Thread.sleep(Native Method)
    at test.arthas.TestThreadBlocking.doGet(TestThreadBlocking.java:22)
    -  locked java.lang.Object@725be470 &lt;---- but blocks 4 other threads!
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:624)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:731)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
    at test.filter.TestDurexFilter.doFilter(TestDurexFilter.java:46)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)
    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)
    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)
    at com.taobao.tomcat.valves.ContextLoadFilterValve$FilterChainAdapter.doFilter(ContextLoadFilterValve.java:191)
    at com.taobao.eagleeye.EagleEyeFilter.doFilter(EagleEyeFilter.java:81)
    at com.taobao.tomcat.valves.ContextLoadFilterValve.invoke(ContextLoadFilterValve.java:150)
    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:170)
    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)
    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:429)
    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1085)
    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:625)
    at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:318)
    -  locked org.apache.tomcat.util.net.SocketWrapper@7127ee12
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
    at java.lang.Thread.run(Thread.java:745)

    Number of locked synchronizers = 1
    - java.util.concurrent.ThreadPoolExecutor$Worker@31a6493e

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_10-arthas场景应用" tabindex="-1"><a class="header-anchor" href="#_10-arthas场景应用" aria-hidden="true">#</a> 10. Arthas场景应用</h3><ol><li>获取jvm启动时所设置的参数</li><li>监控thread的运行情况</li><li>监控内存的运行情况</li><li>生成dump文件</li><li>动态替换.class文件，达到不停机式投产</li></ol><h3 id="_11-常见案例" tabindex="-1"><a class="header-anchor" href="#_11-常见案例" aria-hidden="true">#</a> 11. 常见案例</h3><h2 id="_10-调优" tabindex="-1"><a class="header-anchor" href="#_10-调优" aria-hidden="true">#</a> 10. 调优</h2><blockquote><p>方法论</p></blockquote><h3 id="_1-事前使用合理的手段-生产时基本上是不需要调优的" tabindex="-1"><a class="header-anchor" href="#_1-事前使用合理的手段-生产时基本上是不需要调优的" aria-hidden="true">#</a> 1. 事前使用合理的手段，生产时基本上是不需要调优的</h3><h4 id="_1-1-合理的架构设计" tabindex="-1"><a class="header-anchor" href="#_1-1-合理的架构设计" aria-hidden="true">#</a> 1.1. 合理的架构设计</h4><ul><li>更好的针对性能问题和结构问题进行聚焦和优化</li></ul><h4 id="_1-2-代码review" tabindex="-1"><a class="header-anchor" href="#_1-2-代码review" aria-hidden="true">#</a> 1.2. 代码Review</h4><ul><li>禁止查询全表数据给客户端，会导致创建大量对象</li><li>文件、链接等资源使用完毕之后需要关闭</li><li>禁止使用System.gc()方法 <ul><li>避免fullgc</li></ul></li><li>合适的设计模式 <ul><li>有利于提高代码复用，减少方法区大小</li></ul></li></ul><h4 id="_1-3-代码中完备的日志记录" tabindex="-1"><a class="header-anchor" href="#_1-3-代码中完备的日志记录" aria-hidden="true">#</a> 1.3. 代码中完备的日志记录</h4><h4 id="_1-4-项目启动时合理的配置参数" tabindex="-1"><a class="header-anchor" href="#_1-4-项目启动时合理的配置参数" aria-hidden="true">#</a> 1.4. 项目启动时合理的配置参数</h4><h4 id="_1-5-服务器上完善的监控系统" tabindex="-1"><a class="header-anchor" href="#_1-5-服务器上完善的监控系统" aria-hidden="true">#</a> 1.5. 服务器上完善的监控系统</h4><ul><li>链路追踪</li><li>服务器资源监控</li></ul><h3 id="_2-两类问题" tabindex="-1"><a class="header-anchor" href="#_2-两类问题" aria-hidden="true">#</a> 2. 两类问题</h3><h3 id="_3-大对象导致oom" tabindex="-1"><a class="header-anchor" href="#_3-大对象导致oom" aria-hidden="true">#</a> 3. 大对象导致OOM</h3><h4 id="_3-1-获取堆栈信息" tabindex="-1"><a class="header-anchor" href="#_3-1-获取堆栈信息" aria-hidden="true">#</a> 3.1. 获取堆栈信息</h4><h4 id="_3-2-使用jvisualvm找到大对象的堆栈信息" tabindex="-1"><a class="header-anchor" href="#_3-2-使用jvisualvm找到大对象的堆栈信息" aria-hidden="true">#</a> 3.2. 使用jvisualvm找到大对象的堆栈信息</h4><h4 id="_3-3-在堆栈信息上找到对应的代码" tabindex="-1"><a class="header-anchor" href="#_3-3-在堆栈信息上找到对应的代码" aria-hidden="true">#</a> 3.3. 在堆栈信息上找到对应的代码</h4><h3 id="_4-资源未关闭" tabindex="-1"><a class="header-anchor" href="#_4-资源未关闭" aria-hidden="true">#</a> 4. 资源未关闭</h3><h4 id="_4-1-思路差不多同上" tabindex="-1"><a class="header-anchor" href="#_4-1-思路差不多同上" aria-hidden="true">#</a> 4.1. 思路差不多同上</h4><hr><h3 id="_5-综述" tabindex="-1"><a class="header-anchor" href="#_5-综述" aria-hidden="true">#</a> 5. 综述</h3><h3 id="_6-jvm调优和生产问题的方法论" tabindex="-1"><a class="header-anchor" href="#_6-jvm调优和生产问题的方法论" aria-hidden="true">#</a> 6. JVM调优和生产问题的方法论</h3><blockquote><p>事实上，JVM相关的问题并不可怕，重要的是我们需要建立关于JVM使用层面的完整的方法论。</p></blockquote><ol><li>问题总是在发展中逐渐被发现，换言之，我们不可能预想到所有的问题，所以先干起来再说，也就是不管三七二十一，先投产再说，遇到问题了再解决。</li><li>JVM层面的调优和生产环境问题定位可以看做是两部分内容。</li></ol><h4 id="_6-1-判断jvm运行异常的方法论" tabindex="-1"><a class="header-anchor" href="#_6-1-判断jvm运行异常的方法论" aria-hidden="true">#</a> 6.1. 判断JVM运行异常的方法论</h4><ol><li>要想知道JVM运行是否正常，首先要知道JVM正常运行时的状态是怎样的，也就是说要知道JVM正常运行时的性能指标是怎样的，我们要确立一个评价JVM正常运行与JVM异常运行的衡量标准。其次，我们还需要建立一个长效的监控机制，监控JVM长时间运行的状态，才能够捕捉异常的状态。最后，才是我们针对异常的运行状态进行调优的过程。</li><li>评价JVM运行是否正常的衡量标准，不是『放之四海而皆准』的标准，而是『家家有本经』的标准。所以，这个标准与我们的生产实践有关。常见的实践过程是通过试运营期来摸索。在试运营期，我们可以不断的调整JVM各项配置参数，并监控记录在此期间的各项资源的使用情况，以此来获取最优的配置参数。还有一种实践方式是直接压测方式，就是直接使用各种压测工具，对生产环境进行压力测试，测试出系统资源占用最大情况下的业务指标和JVM指标，并以资源占用最大情况下的JVM各种指标作为JVM的基准指标。</li></ol><h4 id="_6-2-gc配置参数及正常指标的获取过程" tabindex="-1"><a class="header-anchor" href="#_6-2-gc配置参数及正常指标的获取过程" aria-hidden="true">#</a> 6.2. GC配置参数及正常指标的获取过程</h4><ol><li>试运行期： <ol><li>运维团队会划拨一些与投产环境资源配置一样的服务器资源，然后根据开发团队提供的一些JVM各项配置参数部署上我们的应用程序，并不断观察在试运行期间的各项指标： <ol><li>服务器各项资源使用情况（包括CPU负载、内存占用情况、线程忙闲程度、网络开销、磁盘IO开销等）</li><li>JVMGC时的各项指标（包括GC频率、GC耗时、STW时间等）</li></ol></li><li>然后在试运行期间，除了公测用户使用系统外，测试团队也会进行各项测试（如压测），运维团队会根据观察到的服务器各项指标，动态调整试运行期间的JVM各项配置参数，<strong>以期获取在服务器各项资源使用率最高的情况下的JVM的配置参数以及GC的各项指标</strong>；</li><li>之后运维团队会上一步获取到的JVM配置参数设置投产环境，并确定好正式投产环境具体的JVM指标（这也是后续优化的目标）； <ol><li>一些常见的JVM配置参数 <ol><li>-Xmx 等价于 -XX:MaxHeapSize</li><li>-Xms 等价于 -XX:InitialHeapSize</li><li>-Xmn</li><li>-XX:PermSize 等价于 -XX:MaxDirectMemorySize</li><li>-XX:SurvivorRatio</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCDateStamps</li><li>-XX:+PrintGCTimeStamps</li><li>-XX:HeapDumpOnOutOfMemoryError</li><li>-XX:HeapDumPath</li><li>-XX:MaxTenuringThreshold</li><li>-XX:+PrintGCApplicationStoppedTime</li></ol></li><li>一些常见的JVM指标 <ol><li>FullGC频率为每天一次；</li><li>OldGC频率为每天一次；</li><li>YoungGC频率为3-6s一次；</li><li>每次YoungGC耗时不得超过500ms；</li><li>每次FullGC耗时不得超过700ms；</li><li>每次OldGC耗时不超过700ms;</li><li>相邻两次YoungGC后的堆空间容量增长不超过10%『这说明YoungGC回收比较彻底，基本没有对象到老年代中，说明回收效果很好，这个指标只针对于设置了可动态增长的堆空间大小』；</li><li>OldGC后老年代容量增长比例不超过10%；</li></ol></li></ol></li></ol></li><li>正常运行期，即功能迭代期 <ol><li>之后便是功能迭代，在不断的功能迭代过程中，运维团队也会不断的观察服务器各项指标，在功能迭代过程中，发现某项指标发生异常（与前面确定好的优化目标对比），此时就需要进行JVM调优了；</li><li>假如试运行期我们设置的YoungGC频率为3-6s一次，FullGC频率为一天一次，那么在后续的生产过程中，如果GC的频率远远高于这个值，比如1s十次，那就说明那么就需要进行调优了；如果GC频率远远低于这个值，比如一分钟一次，那就说明JVM相当空闲，基本处于无事可做的状态，那么就需要缩小占用空间了，就需要调低Xmn； <ol><li>YoungGC频率过高，则可以检查： <ol><li>新生代所占空间大小，可以适当调大Xmn，使得新生代在整个堆空间中占比25%-40%；</li><li>SurvivorRatio的比例，为8比较合适，这是经过JVM团队验证过的；</li><li>每次YoungGC后，幸存区的大小，如果幸存区容量过大，则表示不合理；</li><li>服务器SWAP、IO等情况，SWAP发生时，会拉长GC耗时，需要进行优化；</li></ol></li><li>FullGC频率过高，则可以检查： <ol><li>新生代与老年代的比例，推荐是4：6</li><li>每次FullGC后，老年代的增长情况，如果增长比例很高，说明可能存在大对象，需要排查大对象；</li><li>业务代码中是否存在一些System.gc()；如果没有配置-XX:+DisableExplicitGC，即没有屏蔽System.gc()触发FullGC，那么可以通过排查GC日志中有System字样判断是否System.gc()触发（日志样本：558082.666: [Full GC (System) [PSYoungGen: 368K-&gt;0K(42112K)]；</li><li>如果使用了CMS收集器，可能还需要观察内存碎片问题；</li><li>-XX:MetaspaceSize的值是首次FullGC的触发条件。当首次FullGC后，释放的空间不足，那么在不超过-XX:MaxMetaspaceSize的前提下，jvm会适当提高实际的元空间大小；如果释放的空间过多，则会适当降低元空间的大小。</li></ol></li></ol></li></ol></li><li>但是实际运行过程中，我们处理更多的应该是OOM的情况。也就是说调优的阶段会在试运营期就完成，但是在实际生产运营期间，我们遇到的问题多是由我们的代码写的太菜而导致的。可以这样说：假如我们能够严格的控制软件工程的每一个阶段的质量，我们甚至连OOM可能都会很少遇到。</li></ol><p>总结：</p><ol><li>预估字节码的占用空间决定初始值；</li><li>小范围内测获得第一首性能指标</li><li>压测获得极限性能指标；</li><li>监控获得异常指标；</li><li>发展中发现问题并解决问题，即不过早优化；</li><li>具体业务有具体的指标；</li></ol><h4 id="_6-3-代码审核的一些要求" tabindex="-1"><a class="header-anchor" href="#_6-3-代码审核的一些要求" aria-hidden="true">#</a> 6.3. 代码审核的一些要求</h4><ol><li>禁止进行全表查询；</li><li>禁止使用select *操作，用到那个字段就展示哪个字段等；</li><li>使用文件、网络等做IO操作时，需要关闭资源；</li><li>使用线程池而不是使用简单线程；</li><li>List集合对象不宜过大，过大要考虑拆分；</li><li>禁止使用System.gc()方法</li></ol><h4 id="_6-4-jvm的配置参数" tabindex="-1"><a class="header-anchor" href="#_6-4-jvm的配置参数" aria-hidden="true">#</a> 6.4. JVM的配置参数</h4><h4 id="_6-5-gc日志分析" tabindex="-1"><a class="header-anchor" href="#_6-5-gc日志分析" aria-hidden="true">#</a> 6.5. GC日志分析</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2023-04-04T12:08:11.670+0800: 104.882: [GC (Allocation Failure) [PSYoungGen: 262144K-&gt;43503K(305664K)] 282367K-&gt;138752K(1005056K), 0.0710736 secs] [Times: user=0.34 sys=0.06, real=0.07 secs] 
2023-04-04T12:06:27.802+0800: 1.014: [GC (Metadata GC Threshold) [PSYoungGen: 173046K-&gt;16268K(305664K)] 173046K-&gt;16292K(1005056K), 0.0088983 secs] [Times: user=0.03 sys=0.01, real=0.01 secs] 
2023-04-04T12:06:27.811+0800: 1.023: [Full GC (Metadata GC Threshold) [PSYoungGen: 16268K-&gt;0K(305664K)] [ParOldGen: 24K-&gt;15506K(699392K)] 16292K-&gt;15506K(1005056K), [Metaspace: 20436K-&gt;20434K(1067008K)], 0.0200635 secs] [Times: user=0.07 sys=0.00, real=0.02 secs] 
2023-04-04T12:08:23.399+0800: 116.611: [Full GC (Ergonomics) [PSYoungGen: 43515K-&gt;0K(160256K)] [ParOldGen: 555360K-&gt;584932K(699392K)] 598876K-&gt;584932K(859648K), [Metaspace: 40740K-&gt;40740K(1087488K)], 0.9348212 secs] [Times: user=6.37 sys=0.07, real=0.94 secs] 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2023-04-04T12:08:11.670+0800: 104.882: [GC (Allocation Failure) [PSYoungGen: 262144K-&gt;43503K(305664K)] 282367K-&gt;138752K(1005056K), 0.0710736 secs] [Times: user=0.34 sys=0.06, real=0.07 secs] 

2023-04-04T12:08:11.670+0800: 表示发生GC的时间戳
104.882 ： 表示从JVM启动，到打印这行日志，经过了104.882秒的时间；
GC (Allocation Failure) ： 表示GC触发的类型是『Allocation Failure』，即分配失败；
[PSYoungGen: 262144K-&gt;43503K(305664K)] ： 表示新生代使用的是ParraleScavenge回收器，262144K-&gt;43503K，表示从262144K回收到43503K，305664K表示新生代总容量；
282367K-&gt;138752K(1005056K) ： 表示整个堆从282367K降到138752K，堆的总容量为1005056K；
0.0710736 secs ： 表示GC的时间是0.0710736秒；
Times: user=0.34 sys=0.06, real=0.07 secs ： 表示整个GC过程中，用户态占用时间、系统态占用时长和真实用时

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2023-04-04T12:06:27.811+0800: 1.023: [Full GC (Metadata GC Threshold) [PSYoungGen: 16268K-&gt;0K(305664K)] [ParOldGen: 24K-&gt;15506K(699392K)] 16292K-&gt;15506K(1005056K), [Metaspace: 20436K-&gt;20434K(1067008K)], 0.0200635 secs] [Times: user=0.07 sys=0.00, real=0.02 secs] 

这是FullGC的过程日志。
新生代总大小为305664K，从16268K降到0K；
老年代总大小为699392K，GC前为24K，GC后为15506K，整个堆大小为1005056K，GC前为16292K，GC后为15506K；
元空间总大小为：1067008K，GC前为20436K，GC后为20434K；
Times: user=0.07 sys=0.00, real=0.02 secs ： 表示整个GC过程中，用户态占用时间、系统态占用时长和真实用时

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2023-04-04T12:09:49.638+0800: 202.850: [Full GC (Ergonomics) [PSYoungGen: 116735K-&gt;0K(160256K)] [ParOldGen: 699391K-&gt;14256K(699392K)] 816127K-&gt;14256K(859648K), [Metaspace: 40493K-&gt;40493K(1087488K)], 0.0174834 secs] [Times: user=0.07 sys=0.01, real=0.02 secs] 
Heap
 PSYoungGen      total 160256K, used 41013K [0x00000007aab00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 116736K, 35% used [0x00000007aab00000,0x00000007ad30d7f8,0x00000007b1d00000)
  from space 43520K, 0% used [0x00000007bd580000,0x00000007bd580000,0x00000007c0000000)
  to   space 116224K, 0% used [0x00000007b1d00000,0x00000007b1d00000,0x00000007b8e80000)
 ParOldGen       total 699392K, used 14256K [0x0000000780000000, 0x00000007aab00000, 0x00000007aab00000)
  object space 699392K, 2% used [0x0000000780000000,0x0000000780dec388,0x00000007aab00000)
 Metaspace       used 41838K, capacity 43950K, committed 44592K, reserved 1087488K
  class space    used 5400K, capacity 5783K, committed 5936K, reserved 1048576K




used ：已使用的空间大小
capacity：当前已经分配且未释放的空间容量大小
committed：当前已经分配的空间大小
reserved：预留的空间大小

capacity + 已经被释放的空间容量 = committed


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>G1日志样本</p><figure><img src="`+Pl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="_6-6-jvm的监控指标" tabindex="-1"><a class="header-anchor" href="#_6-6-jvm的监控指标" aria-hidden="true">#</a> 6.6. JVM的监控指标</h4><h4 id="_6-7-jvm的调优工具" tabindex="-1"><a class="header-anchor" href="#_6-7-jvm的调优工具" aria-hidden="true">#</a> 6.7. JVM的调优工具</h4><ol><li>Linux服务器自带的一些命令，如Top、ps等；</li><li>jdk自带的一些命令，如jinfo、jcmd、jstack、jheap、jstat、jmap、jps、jvisualvm等</li><li>第三方工具，如Arthas、MAT、Jprofiler、JConsole等；</li></ol><h4 id="_6-8-jvm调优案例" tabindex="-1"><a class="header-anchor" href="#_6-8-jvm调优案例" aria-hidden="true">#</a> 6.8. JVM调优案例</h4><p>试运营期时，JVM调优的一些案例</p><ol><li>堆空间、新生代、永久代空间、直接内存过小；</li><li>大对象</li><li>数组越界</li><li>线程资源耗尽</li></ol><p>正式投产期，JVM调优的案例</p><ol><li>YoungGC频率异常</li><li>FullGC频率异常</li><li>STW时间过长</li></ol><h4 id="_6-9-线上oom定位案例" tabindex="-1"><a class="header-anchor" href="#_6-9-线上oom定位案例" aria-hidden="true">#</a> 6.9. 线上OOM定位案例</h4><ol><li>大对象</li><li>IO资源未关闭</li></ol><h3 id="_7-参考" tabindex="-1"><a class="header-anchor" href="#_7-参考" aria-hidden="true">#</a> 7. 参考</h3>',81),qi={href:"https://www.cnblogs.com/gentlemanhai/p/12151904.html",target:"_blank",rel:"noopener noreferrer"},Qi={href:"https://blog.csdn.net/u011277123/article/details/109353489",target:"_blank",rel:"noopener noreferrer"},Wi={href:"https://blog.csdn.net/v123411739/article/details/123778478",target:"_blank",rel:"noopener noreferrer"},Zi=t(`<hr><p>// 待整理</p><ol><li><p>事前要有<strong>良好的软件控制过程</strong>和<strong>良好的软件监控过程</strong></p><ol><li>投产之前的代码Review过程；</li><li>代码中完备的日志打印；</li><li>项目的链路监控</li><li>服务器资源监控工具，如普罗米修斯、</li></ol></li><li><p>投产时要配置上相对应的JVM监控参数；</p><ol><li>dump文件开关、dump文件目录</li><li>gc文件开关、gc文件目录</li></ol></li><li><p>OOM的定位</p><ol><li>根据OOM类型分情况讨论</li><li></li></ol></li><li><p>Fullgc的调优</p></li></ol><h3 id="_8-定位思路" tabindex="-1"><a class="header-anchor" href="#_8-定位思路" aria-hidden="true">#</a> 8. 定位思路</h3><p>如果有监控，那么通过图形能比较直观、快速的了解gc情况； 如果没有监控，那么只能看gc日志或jstat来分析 这是基本技能 一定要熟练</p><ol><li>观察年轻代 gc的情况，多久执行一次、每次gc后存活对象有多少 survivor区多大 存活对象比较多 超过survivor区大小或触发动态年龄判断 =&gt; 调整内存分配比例</li><li>观察老年代的内存情况 水位情况，多久执行一次、执行耗时多少、回收掉多少内存 如果在持续的上涨，而且full gc后回收效果不好，那么很有可能是内存溢出了 =&gt; dump 排查具体是什么玩意</li><li>如果年轻代和老年代的内存都比较低，而且频率低 那么又可能是元数据区加载太多东西了</li><li>其实如果是自己负责的系统，可能要看是不是发版改了什么配置、代码</li></ol><h2 id="_11-出错" tabindex="-1"><a class="header-anchor" href="#_11-出错" aria-hidden="true">#</a> 11. 出错</h2><blockquote><p>出错类型 排查过程 最佳实践经验 案例</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- OOM
  - OOM类型
    - 服务器异常
      - Swap分区
        - 异常类型
          - Out of swap space
        - 本质原因
          - Linux系统会把不常用的内存里面的数据放到一个swap分区中，这样再次使用这些数据时，就直接从swap分区中读到内存中就行，即交换分区。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成，遇到这个异常，表示虚拟内存耗尽。
        - 常见具体原因
          - 地址空间不足
          - 物理内存耗尽
          - 应用程序的本地内存泄露（native leak），例如不断申请内存空间，却不释放
        - 优化手段
          - 执行 jmap -histo:live &lt;pid&gt; 命令，强制执行FullGC，如果几次执行后内存明显下降，则基本可以确认为 Direct buffer 问题
          - 升级地址空间为64bit
          - 升级服务器配置规格或进行资源隔离
      - 线程资源
        - 异常类型
          - Unable to create new native thread
        - 本质原因
          - JVM创建的用户线程都是由底层操作系统来完成的，而操作系统创建线程需要分配空间，当JVM创建系统线程，而操作系统又没有足够资源分配时，就会抛出异常信息。
        - 常见的具体原因
          - JVM创建的线程数超过了操作系统的ulimit限制
          - 线程数超过了kernel.pid_max
          - 本地线程内存空间不足
        - 优化手段
          - 调整ulimit限制，ulimit -u xxx
          - 减小JVM其他资源使用，腾出更多空间给线程使用
            - 限制线程栈大小，即调小-Xss大小
            - 减小堆空间大小
            - 限制线程池大小
          - 修复其他应用程序内存泄露问题
      - OOM Killer机制
        - 异常类型
          - Kill process or sacrifice child
        - 本质原因
          - 默认情况下，Linux允许用户进程申请大于系统可用内存的空间，这样可以『错峰复用』，有利于提高资源利用率。但这也导致了『超卖』问题，因此当线程申请不到资源时，系统会自动激活OOM Killer机制，寻找评分较低的进程来释放资源。在监控工具上的表现是：空闲的内存空间突然大幅度上升
        - 常见的具体原因
          - 这个异常类型是由操作系统层面出发的，也就是操作系统自动触发的OOM Killer机制导致的异常
        - 优化手段
          - 可以采用资源隔离或对系统OOM Killer机制进行调优
    - Java堆
      - 内存泄露或内存溢出
        - 异常类型
          - Java heap space
        - 本质原因
          - 堆空间没有足够的空间存放新创建的对象时，就会抛出异常信息
        - 常见的具体原因
          - 请求创建一个大对象，通常是一个大数组
          - 业务流量激增，这种情况需要配合监控工具中的尖峰值时期与OOM时期来判断是否是因为业务流量激增导致的
          - 过度使用终结器（Finalizer），该对象没有立即被 GC
          - 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收
        - 优化手段
          - 通常是调高JVM堆内存空间即可，还是不行就采用下面的手段
          - 超大对象，就要检查业务代码，判断其合理性
          - 如果是业务峰值，就扩大资源，或做限流熔断等
          - 如果是内存泄露，需要找到持有的对象，修改代码设计，比如关闭没有释放的资源等
      - 多次GC仍无法满足分配资源所需要的空间
        - 异常类型
          - GC overhead limit exceeded
        - 本质原因
          - JVM花费了98%的GC时间回收不到2%的内存空间，换句话来说应用程序已经耗尽了所有可用内存，连GC也不会回收
        - 优化手段
          - 同 Java heap space
      - 数组越界
        - 异常类型
          - Requested array size exceed VM limit
        - 本质原因
          - 程序请求创建的数组超过最大长度限制抛出异常
        - 优化手段
          - 检查代码，判断合理性，或改为分批次执行等
      - 发生的时机不同，GC overhead limit exceeded 发生时，可能并没有申请内存空间使用，只是多次GC后回收的内存空间过小；而 Java heap space 发生时，一定会有JVM为完成对象的创建而申请内存空间分配
    - 方法区
      - 方法区已满
      - 本质原因
        - 方法区已满，通常是加载的class数目太多或体积太大
      - 异常类型
        - 永久代/老年代
          - 永久代空间已满
            - Permgen space
        - 元空间
          - 元空间已满
            - Metaspace
      - 优化手段
        - 根据出现的时机采用不同的办法
          - 程序启动时，调整 -XX:MaxPermSize 或 -XX:MaxMetaspaceSize 启动参数，调大方法区的大小
          - 应用重新部署时，应用没有重新启动，导致加载了多份class信息，再次重启即可
          - 运行时报错，可能是应用程序动态创建了大量的class，而这些class生命周期却很短暂，但是jvm并没有卸载class，可以配置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC 两个参数，允许JVM卸载class
          - 如果上面还不能解决，就是用 jmap -dump:format=b,file=dump.hprof &lt;process-id&gt; 命令dump内存对象，然后通过MAT工具分析开销最大的classloader及重复的class
    - 直接内存
      - JVM允许应用程序通过 Direct byte buffer 直接访问堆外内存，一些应用程序通过 Direct byte buffer 结合内存映射文件（memory mapped file）实现高速IO。Direct byte buffer 默认的大小是64MB，一旦超出这个限制，就会抛出异常。通常情况下，涉及到Nio操作时才会抛错。
      - 异常类型
        - Direct buffer memory
      - 本质原因
        - 应用程序使用Direct byte buffer时，超出了限制
      - 优化手段
        - 通过 -XX:MaxDirectMemorySize 启动参数，调整直接内存的大小
        - 检查堆外内存使用代码，确认是否存在内存泄露；或通过反射调用sun.misc.Cleaner的clean()方法，主动释放被 Direct ByteBuffer 持有的内存空间
        - Java只能通过ByteBuffer.allocateDirect来操作Direct ByteBuffer，因此可以通过Arthas拦截改方法进行排查
        - 检查一下 -XX:+DisableExplicitGC 参数是否启动，如果有就去掉，因为这个参数会让 System.gc() 失效
- StackOverFlow
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_12-停顿" tabindex="-1"><a class="header-anchor" href="#_12-停顿" aria-hidden="true">#</a> 12. 停顿</h2><blockquote><p>正常指标： 获取正常指标的过程、正常指标有哪些？ 异常指标：如何监控异常指标？ 最佳实践经验 案例</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- 本质： FullGC频繁
  - 表现
    - 机器 cpu 负载过高
    - 频繁 full gc 告警
    - 系统无法请求处理或者过慢， 接口无关的、全面性的无法响应请求或响应过慢
  - 原因
    - 解决思路： full gc 触发条件是 老年代空间不足， 所以追因的方向就是导致 老年代空间不足的原因：大量对象频繁进入老年代 + 老年代空间释放不掉
    - 系统并发高、执行耗时过长，或者数据量过大，导致 young gc频繁，且gc后存活对象太多，但是survivor 区存放不下（太小 或 动态年龄判断） 导致对象快速进入老年代 老年代迅速堆满
    - 发程序一次性加载过多对象到内存 （大对象），导致频繁有大对象进入老年代 造成full gc
    - 存在内存溢出的情况，老年代驻留了大量释放不掉的对象， 只要有一点点对象进入老年代 就达到 full gc的水位了
    - 元数据区加载了太多类 ，满了 也会发生 full gc
    - 堆外内存 direct buffer memory 使用不当导致
    - 也许， 你看到老年代内存不高 重启也没用 还在频繁发生full gc， 那么可能有人作妖，在代码里搞执行了 System.gc();
- 解决思路
  - 如果有监控，那么通过图形能比较直观、快速的了解gc情况；
  - 如果没有监控，那么只能看gc日志或jstat来分析 这是基本技能 一定要熟练
    - 观察年轻代 gc的情况，多久执行一次、每次gc后存活对象有多少 survivor区多大
      - 存活对象比较多 超过survivor区大小或触发动态年龄判断 =&gt; 调整内存分配比例
    - 观察老年代的内存情况 水位情况，多久执行一次、执行耗时多少、回收掉多少内存
      - 如果在持续的上涨，而且full gc后回收效果不好，那么很有可能是内存溢出了 =&gt; dump 排查具体是什么玩意
    - 如果年轻代和老年代的内存都比较低，而且频率低 那么又可能是元数据区加载太多东西了
      - 排查系统是否加载了无用的lib包，对系统所依赖的类库进行精简
    - 其实如果是自己负责的系统，可能要看是不是发版改了什么配置、代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-log line-numbers-mode" data-ext="log"><pre class="language-log"><code><span class="token operator">-</span> 运行期内存结构
  <span class="token number">1</span><span class="token punctuation">.</span> 线程私有
     <span class="token number">1</span><span class="token punctuation">.</span> 虚拟机栈： 存放内容、常见配置参数、异常；
     <span class="token number">2</span><span class="token punctuation">.</span> 本地方法栈： 存放内容、常见配置参数、异常；
     <span class="token number">3</span><span class="token punctuation">.</span> 程序计数器： 存放内容、常见配置参数、异常；
     <span class="token number">4</span><span class="token punctuation">.</span> 直接内存
  <span class="token number">2</span><span class="token punctuation">.</span> 线程共享
     <span class="token number">1</span><span class="token punctuation">.</span> Java堆： 存放内容、常见配置参数、异常；
     <span class="token number">2</span><span class="token punctuation">.</span> 方法区： 存放内容、常见配置参数、异常；
<span class="token number">1</span><span class="token punctuation">.</span> GC内存模型
  <span class="token number">1</span><span class="token punctuation">.</span> eden<span class="token operator">+</span>s0<span class="token operator">+</span>s1<span class="token operator">+</span>old<span class="token operator">+</span>永久代<span class="token operator">/</span>元空间
  <span class="token number">2</span><span class="token punctuation">.</span> minorgc、majorgc、FullGC
<span class="token number">2</span><span class="token punctuation">.</span> 垃圾回收
  <span class="token number">1</span><span class="token punctuation">.</span> 存活对象判断标准
     <span class="token number">1</span><span class="token punctuation">.</span> 可作为GCRoot的对象
     <span class="token number">2</span><span class="token punctuation">.</span> 引用类型
  <span class="token number">2</span><span class="token punctuation">.</span> 垃圾回收算法
  <span class="token number">3</span><span class="token punctuation">.</span> 垃圾回收器
     <span class="token number">1</span><span class="token punctuation">.</span> 配置参数
     <span class="token number">2</span><span class="token punctuation">.</span> 回收过程
     <span class="token number">3</span><span class="token punctuation">.</span> 优缺点分析
<span class="token number">3</span><span class="token punctuation">.</span> 对象探秘
  <span class="token number">1</span><span class="token punctuation">.</span> 对象的内存分布
     <span class="token number">1</span><span class="token punctuation">.</span> 对象头（哈希值、分代次数、持有的锁、偏向线程id、偏向时间戳）
     <span class="token number">2</span><span class="token punctuation">.</span> 实例数据（自身的字段数据和从父类继承过来的字段数据）
     <span class="token number">3</span><span class="token punctuation">.</span> 对齐填充
  <span class="token number">2</span><span class="token punctuation">.</span> 对象创建过程
     <span class="token number">1</span><span class="token punctuation">.</span> 逃逸分析（栈上分配、锁消除、标量替换等）；
     <span class="token number">2</span><span class="token punctuation">.</span> 方法区常量池能否定位类型数据；
     <span class="token number">3</span><span class="token punctuation">.</span> 分配内存；
     <span class="token number">4</span><span class="token punctuation">.</span> 处理同步问题；
     <span class="token number">5</span><span class="token punctuation">.</span> 初始化；
     <span class="token number">6</span><span class="token punctuation">.</span> 执行init，完成其他信息的构造；
  <span class="token number">3</span><span class="token punctuation">.</span> 对象内存分配过程及访问定位、对象年龄晋升过程；
<span class="token number">4</span><span class="token punctuation">.</span> 类的加载
  <span class="token number">1</span><span class="token punctuation">.</span> 双亲委派模型
  <span class="token number">2</span><span class="token punctuation">.</span> 类加载器
  <span class="token number">3</span><span class="token punctuation">.</span> 类加载过程
<span class="token number">5</span><span class="token punctuation">.</span> 实操
  <span class="token number">1</span><span class="token punctuation">.</span> 性能指标
  <span class="token number">2</span><span class="token punctuation">.</span> 工具（自带的和第三方提供的）
  <span class="token number">3</span><span class="token punctuation">.</span> 两大类问题
     <span class="token number">1</span><span class="token punctuation">.</span> 异常信息
     <span class="token number">2</span><span class="token punctuation">.</span> 优化JVM
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_13-参考" tabindex="-1"><a class="header-anchor" href="#_13-参考" aria-hidden="true">#</a> 13. 参考</h2>`,14),$i={href:"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html",target:"_blank",rel:"noopener noreferrer"},ln=t('<h3 id="_13-1-概览" tabindex="-1"><a class="header-anchor" href="#_13-1-概览" aria-hidden="true">#</a> 13.1. 概览</h3><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 概览及总述：</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 类加载子系统，JVM是如何把Java语言加载到JVM中的？</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 运行期内存结构，加载到JVM中的源代码是如何使用内存的？</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 执行引擎，</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 本地方法接口及本地方法库</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 理论层次</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> JVM中的后台进程</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 字节码文件</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> 类加载子系统</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> 【where】类来源途径（本地文件、网络、压缩包、数据库、动态编译生成等）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> 【who】类加载器（分类、作用、加载内容）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> 【how】双亲委派（原理、好处）、破坏双亲委派模型的样例</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> 运行期内存结构</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> 线程私有区域</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> 程序计数器 （存放内容、异常信息、存在的原因）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> 虚拟机栈（存放内容（局部变量表、操作数栈、动态链接、方法出口及一些附加信息）、异常信息、配置参数）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> 本地方法栈  （存放内容、异常信息）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> 线程共享区域</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> Java堆（存放内容（Java对象及数组）、配置参数、异常类型及解决方案）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> 方法区（存放内容（Java对象及数组）、配置参数、异常类型及解决方案）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-20" disabled="disabled"><label class="task-list-item-label" for="task-item-20"> 执行引擎</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-21" disabled="disabled"><label class="task-list-item-label" for="task-item-21"> Java中的运行方式（解释运行、编译运行），HotSpot的运行方式</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-22" disabled="disabled"><label class="task-list-item-label" for="task-item-22"> 解释运行与编译运行的区别</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-23" disabled="disabled"><label class="task-list-item-label" for="task-item-23"> 编译器分类（前端编译器、后端编译器、静态提前编译器，各自区别）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-24" disabled="disabled"><label class="task-list-item-label" for="task-item-24"> 本地方法接口与本地库</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-25" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-25"> 对象探秘</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-26" disabled="disabled"><label class="task-list-item-label" for="task-item-26"> 对象实例化方式</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-27" disabled="disabled"><label class="task-list-item-label" for="task-item-27"> 对象内存结构</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-28" disabled="disabled"><label class="task-list-item-label" for="task-item-28"> JVM为对象分配内存的过程【即在分代回收模型中的内存分配过程】</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-29" disabled="disabled"><label class="task-list-item-label" for="task-item-29"> 对象的创建过程（空间分配担保+对象年龄晋升确定所在区域、逃逸分析确定代码优化结果）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-30" disabled="disabled"><label class="task-list-item-label" for="task-item-30"> 对象的访问定位；</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-31" disabled="disabled"><label class="task-list-item-label" for="task-item-31"> 内存结构、内存分配过程、访问定位、升代策略</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-32" disabled="disabled"><label class="task-list-item-label" for="task-item-32"> 垃圾回收理论</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-33" disabled="disabled"><label class="task-list-item-label" for="task-item-33"> 虚拟机中的高效并发</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-34" disabled="disabled"><label class="task-list-item-label" for="task-item-34"> 具体实现层面</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-35" disabled="disabled"><label class="task-list-item-label" for="task-item-35"> 不同回收方式具有不同的运行期内存结构</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-36" disabled="disabled"><label class="task-list-item-label" for="task-item-36"> 经典垃圾回收器（各自垃圾回收过程、所采用的算法、适用场景、配置参数）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-37" disabled="disabled"><label class="task-list-item-label" for="task-item-37"> 组合使用</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-38" disabled="disabled"><label class="task-list-item-label" for="task-item-38"> JVM调优</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-39" disabled="disabled"><label class="task-list-item-label" for="task-item-39"> 方法论</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-40" disabled="disabled"><label class="task-list-item-label" for="task-item-40"> 调优和异常</label></li></ul><h3 id="_13-2-架构图" tabindex="-1"><a class="header-anchor" href="#_13-2-架构图" aria-hidden="true">#</a> 13.2. 架构图</h3><figure><img src="'+zl+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+Fl+'" alt="1726199438377" tabindex="0" loading="lazy"><figcaption>1726199438377</figcaption></figure><figure><img src="'+Nl+'" alt="周志明第三版" tabindex="0" loading="lazy"><figcaption>周志明第三版</figcaption></figure><figure><img src="'+Rl+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="_13-3-研究方法" tabindex="-1"><a class="header-anchor" href="#_13-3-研究方法" aria-hidden="true">#</a> 13.3. 研究方法</h3><ol><li>分别了解上图中的每一部分中涉及到的理论知识；</li><li>了解Hotspot的具体实现细节</li><li>针对JVM进行基准测试，了解其基本指标数据；</li><li>之后进行调优和问题解决；</li></ol>',9);function nn(an,en){const a=r("ExternalLinkIcon"),A=r("Tabs");return p(),m("div",null,[Ul,l("ul",null,[l("li",null,[l("a",wl,[i("https://docs.oracle.com/javase/specs/index.html"),n(a)])])]),Bl,l("p",null,[l("a",Hl,[i("https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html"),n(a)])]),Ll,n(A,{id:"372",data:[{title:"Constants 常量相关"},{title:"Loads 加载相关"},{title:"Loads Store 存储相关"},{title:"Loads Stack 栈相关"},{title:"Loads Math 运算相关"},{title:"Loads Conversions 转换相关"},{title:"Loads Comparisons 比较相关"},{title:"Loads Control 控制相关"},{title:"Loads references 引用、方法、异常、同步相关"},{title:"Loads Extended 扩展相关"},{title:"Loads Reserved 保留指令"}]},{tab0:e(({title:s,value:d,isActive:u})=>[Il]),tab1:e(({title:s,value:d,isActive:u})=>[Yl,ql]),tab2:e(({title:s,value:d,isActive:u})=>[Ql,Wl]),tab3:e(({title:s,value:d,isActive:u})=>[Zl,$l]),tab4:e(({title:s,value:d,isActive:u})=>[li,ii,ni]),tab5:e(({title:s,value:d,isActive:u})=>[ai,ei,ti]),tab6:e(({title:s,value:d,isActive:u})=>[si,di]),tab7:e(({title:s,value:d,isActive:u})=>[ui,ri,oi]),tab8:e(({title:s,value:d,isActive:u})=>[ci,Ai]),tab9:e(({title:s,value:d,isActive:u})=>[vi,pi]),tab10:e(({title:s,value:d,isActive:u})=>[mi,bi]),_:1}),l("blockquote",null,[l("p",null,[i("作者：刘Java 链接："),l("a",hi,[i("https://juejin.cn/post/7027707475503611940"),n(a)]),i(" 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])]),gi,l("ul",null,[l("li",null,[l("a",fi,[i("SE7-JVM Instruction Set"),n(a)])]),l("li",null,[l("a",xi,[i("字节码文件结构"),n(a)])])]),_i,l("p",null,[ki,i(" 图源： "),l("a",Ci,[i("https://zhuanlan.zhihu.com/p/363839223"),n(a)])]),Mi,l("p",null,[i("著作权归@pdai所有 原文链接："),l("a",Si,[i("https://pdai.tech/md/java/thread/java-thread-x-theorty.html"),n(a)])]),ji,Ji,l("p",null,[i("著作权归@pdai所有 原文链接："),l("a",Gi,[i("https://pdai.tech/md/java/thread/java-thread-x-theorty.html"),n(a)])]),yi,Ei,Xi,Ti,Ki,Oi,Vi,l("p",null,[i("著作权归@pdai所有 原文链接："),l("a",Pi,[i("https://pdai.tech/md/java/jvm/java-jvm-jmm.html"),n(a)])]),zi,l("p",null,[i("windows下这个Monitor Ctrl-Break是不算在活动线程的，所以这样大于1是可以执行的，但是linux下应该是 大于2 ———————————————— 版权声明：本文为CSDN博主「chenxi004」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接："),l("a",Fi,[i("https://blog.csdn.net/chenxi004/article/details/104972979"),n(a)])]),Ni,l("p",null,[i("著作权归@pdai所有 原文链接："),l("a",Ri,[i("https://pdai.tech/md/java/jvm/java-jvm-gc.html"),n(a)])]),Di,l("ul",null,[l("li",null,[l("a",Ui,[i("Arhtas"),n(a)])]),l("li",null,[l("a",wi,[i("通过 Arthas Trace 命令将接口性能优化十倍（User Case 投稿）"),n(a)])]),l("li",null,[l("a",Bi,[i("动态追踪技术漫谈"),n(a)])]),l("li",null,[l("a",Hi,[i("利用Arthas精准定位Java应用CPU负载过高问题"),n(a)])]),l("li",null,[l("a",Li,[i("阿里Java诊断工具 arthas - 排查线上环境内存使用过大、线程cpu使用率高问题"),n(a)])]),l("li",null,[l("a",Ii,[i("【死磕JVM】用Arthas排查JVM内存 真爽！我从小用到大"),n(a)])])]),Yi,l("p",null,[l("a",qi,[i("诊断gc是否正常"),n(a)]),l("a",Qi,[i("线上JVM调优实践，FullGC40次/天到10天一次的优化"),n(a)]),l("a",Wi,[i("面试官：如何进行 JVM 调优（附真实案例）"),n(a)])]),Zi,l("p",null,[l("a",$i,[i("Java SE 8 Edition"),n(a)])]),ln])}const sn=v(Dl,[["render",nn],["__file","jvm.html.vue"]]);export{sn as default};
