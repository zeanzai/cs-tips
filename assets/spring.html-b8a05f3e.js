import{_ as c,W as r,X as u,Y as n,Z as a,$ as t,a0 as e,C as d}from"./framework-16b96b76.js";const p="/cs-tips/assets/1699281071220-e386ec15.png",i="/cs-tips/assets/1697786119443-3ae68aab.png",o="/cs-tips/assets/1697785648081-4fd52636.png",l="/cs-tips/assets/1697994094493-8b78cb21.png",k="/cs-tips/assets/1697787615019-240579fe.png",g="/cs-tips/assets/1697787590700-32187cdd.png",v="/cs-tips/assets/1699277811397-de5a3702.png",m="/cs-tips/assets/1699277467634-95fc03ba.png",b="/cs-tips/assets/1699277577293-b9608627.png",h="/cs-tips/assets/1697994367738-b22a93bc.png",f="/cs-tips/assets/1699584004385-6de16fe1.png",S="/cs-tips/assets/1699586154326-9008b731.png",y="/cs-tips/assets/1699279436208-acf937ae.png",x="/cs-tips/assets/1699585463644-a422854c.png",w="/cs-tips/assets/1699585634709-593c9f10.png",B="/cs-tips/assets/1699585688008-0f4ee120.png",A="/cs-tips/assets/1699585718921-a7c00cfd.png",_="/cs-tips/assets/1699585732359-b98f31e1.png",C="/cs-tips/assets/1699585748319-271f9950.png",J="/cs-tips/assets/1699585839113-99303d2b.png",j="/cs-tips/assets/1726528805453-81a5ee90.png",I="/cs-tips/assets/1726528725057-e9eeefbb.png",D="/cs-tips/assets/1726528726462-5bbc11d2.png",q="/cs-tips/assets/1726528727804-1c536d5a.png",P="/cs-tips/assets/1726528729156-0ba66f11.png",T="/cs-tips/assets/1726528730600-6ea208d0.png",E="/cs-tips/assets/1699280288242-9b7b7050.png",M="/cs-tips/assets/1699280372737-a4fce89d.png",O="/cs-tips/assets/1699597382459-e163316e.png",R="/cs-tips/assets/1699597400155-55fc3e49.png",L="/cs-tips/assets/1699597422438-3763c456.png",F="/cs-tips/assets/1699597450638-669ac88f.png",H="/cs-tips/assets/1699055765830-188df1d3.png",z="/cs-tips/assets/1699056268419-c4805662.png",G="/cs-tips/assets/1699056367872-c36f867c.png",V="/cs-tips/assets/1699056729954-a7792461.png",W={},K=e('<h1 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> spring</h1><table><thead><tr><th><strong>日期</strong></th><th><strong>迭代内容</strong></th></tr></thead><tbody><tr><td>23-11-24</td><td>1. 导学指引。确定一种学习和记忆 Spring 相关知识点的逻辑树。</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">导学指引</p><p>Java 作为一个编程语言，随着 JVM 功能的完善，Java 逐渐应用于工程领域（相对于科学计算领域）。但是在工程领域，人们实现的 Java 框架很庞大和臃肿，并不利于程序员的理解和应用，于是人们想要把程序员从繁重复杂的传统框架中解放出来。那怎么解决呢？</p><ol><li>人们发现，把现实世界中的一些实际的例子抽象出来，搞出一些设计规则，更便于人们理解和实现程序，于是<strong>设计模式</strong>出现了。</li><li>之后人们又发现，前人归纳总结的设计模式并不适合“使用 Java 搞工程设计”这一特殊的领域。原因是面向对象编程过程中<code>对象的构造权</code>和<code>对象的依赖关系</code>的管理<code>还是很复杂</code>。于是人们就想，能不能开发一种“工具”——甭管叫什么吧，这种工具能够帮我们管理对象的构造权和对象的依赖关系，这样一来，程序员就可以只用去关注业务就行了。于是 <strong>Spring</strong> 登场。</li><li>既然要管理对象的构造权和对象的依赖关系，那就得知道什么是“使用 Java 搞工程设计”这一特殊的领域中的对象和对象的依赖关系是个啥吧？于是 <strong>JavaBean 的概念</strong>登场。</li><li>对象和对象的依赖关系的概念了解之后，就是要设计这个工具了吧。于是<strong>容器</strong>登场。要想完成容器的实现要解决以下几个问题： <ol><li>假设容器这个工具已经有了，那如何把对象和对象的依赖关系与容器联系起来呢？或者说怎么把对象和对象的依赖关系配置给容器呢？于是不同的<strong>配置方式</strong>登场。</li><li>配置信息给到容器后，容器要把配置信息中的 JavaBean 解析出来吧，那怎么解析呢？解析完了得保存着吧，于是<strong>解析过程</strong>（ BeanDefinite、BeanDefiniteReader……） 登场。</li><li>对象和对象的依赖关系给到容器后，下面就是业务代码用的时候，容器怎么反向查找业务代码所用到的 JavaBean，并构造出对应的对象和依赖关系，并给到业务代码呢？于是<strong>装配</strong>登场。至此，一个丐版的 容器 就算完成了。</li><li>丐版的容器完成后要看看 Spring 到底是怎么实现的吧，于是 <strong>BeanFactory 和 ApplicationContext</strong> 登场。</li><li>人们在实践演绎过程中又发现——Spring 实际上管理的是整个<strong>JavaBean 的生命周期</strong>呀。于是 JavaBean 生命周期登场。</li><li>JavaBean 生命周期有了之后，人们发现在 JavaBean 的生命周期中有很多个阶段，每个阶段完成后都可以看作是这个事件完成了，于是人们就想，能不能基于这些事件做一些事情，这样一来不但能实现对生命周期更细粒度的控制，还能使 Spring 适用更丰富的业务场景。但是如何实现这种期望呢，幸好有字节码增强技术。于是<strong>事件机制</strong>和<strong>面向切面编程</strong>登场。</li><li>人们又深入了解，发现容器事实上也可以看作是一个 JavaBean 呀，只不过这个 JavaBean 比较特殊而已，这样的话，容器也应该有生命周期的概念，容器的生命周期就是应用上下文。好吧，<strong>应用上下文</strong>登场了。</li></ol></li><li>至此，<strong>一个支持更加丰富特性的“豪华版”Spring 登场了</strong>，也似乎把程序员从复杂繁重的编码工作中解放出来了，但是这就够了嘛？答案是：还是不够。因为程序员还要应付更多复杂的业务场景，如通用的远程调用、国际化的支持、Web、测试等。于是 Spring 的<strong>高级特性</strong>登场。</li><li>这样就够了嘛？还是不够！那就接着演绎，于是“铂金版”的 Spring 登场——<strong>SpringBoot</strong>。</li><li>这样还不够？那就接着演绎，给你来个全家桶总可以了吧？于是 <strong>SpringCloud</strong> 登场。</li></ol></div><blockquote><p>上面导学指引指出了一种学习和理解 Spring 相关知识点的逻辑树，但为了便于归纳和总结，下面的文档并不完全按照上面👆的逻辑顺序。特此说明。 此外，由于 Spring 是由 Java 实现的，在面试时很多情况下会问到源码的部分。因此，在下面的文档里面，涉及到的源码部分就分散到各个文档中，不会再单独开篇解读。</p></blockquote><h2 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景" aria-hidden="true">#</a> 1. 背景</h2><blockquote><p>EJB 开发模式【POJO、JavaBean、对象的状态、RMI 和 RPC、多个 Bean】 EJB 的困境 两个示例证明“没有 Spring 的困境” DIP 设计模式原则之 DI 与 IoC 的区别、依赖注入和依赖查找、IoC 和 Spring Spring 的特点、相关组件、版本更新、SpringBoot 和 SpringCloud 等；</p></blockquote><h3 id="ejb概述" tabindex="-1"><a class="header-anchor" href="#ejb概述" aria-hidden="true">#</a> EJB概述</h3><blockquote><p>EJB 开发模式【POJO、JavaBean、对象的状态、RMI 和 RPC、多个 Bean】 EJB 的困境 两个示例证明“没有 Spring 的困境” DIP 设计模式原则之 DI 与 IoC 的区别、依赖注入和依赖查找、IoC 和 Spring Spring 的特点、相关组件、版本更新、SpringBoot 和 SpringCloud 等；</p></blockquote><ol><li>什么是EJB以及和Spring Framework的区别</li></ol>',9),X={href:"https://cloud.tencent.com/developer/article/2337614",target:"_blank",rel:"noopener noreferrer"},N=e('<h3 id="spring-1" tabindex="-1"><a class="header-anchor" href="#spring-1" aria-hidden="true">#</a> Spring</h3><ol><li>依赖倒置原则</li><li>控制反转</li></ol><ul><li>Spring产生的背景及其特点</li><li>组件及其各自作用</li><li>容器高级视图</li><li>IOC容器的实现（BeanFactory）及其子类</li><li>ApplicationFactory及其子类</li><li>WebApplicationContext功能</li><li>注解及其作用</li><li>标准事件分类（5种）</li><li>Bean <ul><li>属性</li><li>5种作用域</li><li>在Spring应用上下文中的生命周期</li><li>装配方式（手工装配、自动装配）</li><li>Bean后置处理器作用及用法</li></ul></li><li>AOP定义及相关术语、实现方式、基本原理、相关设计模式</li><li>事务管理、隔离级别、传播机制</li></ul><blockquote><p>软件研发过程： 背景描述，需求设计，概要设计，详细设计……因此在学习Spring时，可以把Spring看作是一个业务需求，只不过这个业务需求是要完成对我们写的各种各样的Java类的管理。</p></blockquote><ul><li>【背景】EJB开发模式及其弊端</li><li>【愿景】造一个能帮助程序员管理各种JavaBean组件的容器</li><li>【实现】Spring框架 <ul><li>功能特性</li><li>简单使用过程</li><li>模块及其各自功能特性： Core、Context、AOP、Web、DAO、MVC、ORM</li><li>原理</li><li>好处</li></ul></li><li>Bean相关 <ul><li>概念： 什么是POJO、组件、Bean等；</li><li>元信息： <ul><li>基本信息</li><li>行为信息</li><li>依赖信息</li><li>延伸 对bean元信息的讲解</li></ul></li><li>描述Bean的元信息的方式 <ul><li>xml</li><li>Java直接编码 <ul><li>基于注解</li><li>基于SpringAPI方式</li></ul></li><li>GroovyDSL方式</li><li>【待定】使用 Spring 官方提供的注解 <ul><li>有哪些注解，这些注解的功能是什么</li></ul></li></ul></li><li>如何实现依赖关系 <ul><li>基于Spring： Spring的自动装配</li><li>自行实现： 构造方法，set方法，简单工厂方法、静态工厂方法</li></ul></li><li>Bean的生命周期</li><li>面试题 <ul><li>如何解决循环依赖？</li><li>Spring中同名Bean的处理方式？</li><li>单例Bean的线程同步问题？</li><li>为什么要有Bean的生命周期，基于Bean的生命周期能完成什么企业级功能？</li></ul></li></ul></li></ul><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h3><p>在没有出现Spring之前，EJB是Java领域大型企业级应用的主要技术选型。但EJB有着很大的问题：</p><ol><li>整个软件过程中，非业务相关的技术步骤过于复杂与重复。比如每开发一个模块就都需要创建servlet、web.xml等，还需要重量级容器作为支撑等；</li><li>EJB并没有对Bean的管理和维护设置统一标准，这使得Bean的管理和维护极其混乱；</li><li>EJB的交叉业务实现过程复杂。比如安全控制、日志记录、事务控制等交叉业务，需要在每个需求中都要进行实现；</li><li>由于框架的复杂性，导致很多业务模块的开发过程并不能很好的遵守设计模式中的 OCP 原则和 DIP 原则，这导致项目模块耦合性较强，耦合性越强，可扩展性就越差；</li><li>程序员技术专业素养参差不齐及对 EJB 开发技术的理解不同，造成基于 EJB 的软件过程实现方式多种多样，最终导致软件危机</li><li>......</li></ol><p>EJB的技术，重点在于想方设法实现一个又一个的可复用的JavaBean组件。但是这个过程中需要程序员自行实现，而由于<code>程序员技术素养的差别</code>以及<code>Java语言的灵活性特点</code>，这又导致Bean的实现过程千差万别，最终导致软件系统难以维护。</p><p>以上问题，最终抽象并总结起来就是： <code>Bean的构造权和Bean的依赖关系的控制权</code> 的归属问题。即传统的软件开发过程中，<code>Bean的构造权和Bean的依赖关系的控制权</code>等均由负责开发的程序员来完成，由于每个程序员的专业素养的不同以及Java语言的灵活性，就导致Bean的实现方式各式各样，最终导致软件系统失去控制。</p><p>因此，人们就想，能不能造出一种工具，这种工具能让程序员从复杂而又灵活的实现方式中解脱出来。于是Spring应运而生。事实上，随着时间的发展，Spring也逐渐成为Java企业级应用的“事实标准”。</p><hr><p>早期的面向对象的软件过程中，类的管理完全是需要程序员自定义去实现的，随着系统的迭代，类就会膨胀，也会变得越来越复杂，最终导致软件系统失去控制。</p><p>计算机大神们研发了一款软件，可以管理程序员自定义的各种类，这款软件产品就是Spring。</p><p>这款软件产品完成了本来需要程序员完成的功能，例如：</p><ol><li>单个Bean的生命周期管理；</li><li>多个Bean的组织和装配，说白了就是能够处理多个Bean之间的相互依赖关系，何时构造、何时组织和装配；</li></ol><blockquote><p>组织和装配： 比如 Student 类中有一个 Class 类，表明学生所属的班级信息，我们自定义实现时，会new一个class对象，然后把这个class对象传给student作为student的构造参数。有了Spring之后就只需要写Student类和Class类，这二者之间的组织过程和装配过程就交给Spring来处理了。</p></blockquote><h2 id="ejb的困境" tabindex="-1"><a class="header-anchor" href="#ejb的困境" aria-hidden="true">#</a> EJB的困境</h2><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>上面问题总结和抽象一下就是： 没有一个能够管理对象的构造以及对象与对象之间依赖关系的组件。我们试想，如果我们设计并实现一个能够完成这样功能的组件，那我们是不是就可以从上面这些繁重的开发工作中解脱出来，并且我们也能够规范我们的开发流程，到最后我们剩下的工作就真正实现“只专注生成 JavaBean 以及处理这些 Bean 之间的关系”的目标了。</p><p>幸运的是，有这样的组件——Spring。核心原理分成几个步骤：</p><ol><li>把Bean简单化，简单到只完成具体的业务功能，简单的实现思路就是把通用功能和具体的业务功能进行剥离，然后形成一个个独立的Bean。结果就涉及到另外一个问题： 如何管理这些单个独立的Bean，答案是： 构造一个管理所有Bean的组件并实现控制反转（IoC），即实现一个组件，让这个组件具有管理所有Bean的功能，并且这个组件能够控制Bean的生命周期（即Bean的构造和销毁，以及中间的使用过程）。</li><li>完成上面的步骤后，还涉及到另外两个问题： <ol><li>如何把剥离出来的通用功能（如日志管理功能、安全控制功能）重新组织回Bean；</li><li>如何组织和管理不同Bean复用； 解决上面两个问题的思路是： 依赖注入（DI），即把这些通用的功能使用某种技术注入到Bean中，具体的实现技术是： 动态代理，思路是在运行期动态生成新的Java代码，让Java代码重新具有完成所有的功能。</li></ol></li></ol><blockquote><p>动态代理 vs 静态代理：</p></blockquote><h1 id="spring特点" tabindex="-1"><a class="header-anchor" href="#spring特点" aria-hidden="true">#</a> Spring特点</h1><ul><li>轻量级 、非侵入</li><li>实现了<strong>控制反转和容器</strong></li><li>支持<strong>面向切面编程</strong></li><li>支持<strong>事物管理</strong></li><li>组件化、模块化、一站式</li><li>......</li></ul><figure><img src="'+p+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h1 id="组件" tabindex="-1"><a class="header-anchor" href="#组件" aria-hidden="true">#</a> 组件</h1>',27),U={href:"https://docs.spring.io/spring-framework/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#dependency-management",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://docs.spring.io/spring-framework/docs/",target:"_blank",rel:"noopener noreferrer"},Z=e('<figure><img src="'+i+'" alt="5.0" tabindex="0" loading="lazy"><figcaption>5.0</figcaption></figure><p><strong>①Spring Core（核心容器）</strong> spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。</p><ul><li>spring-core ：IOC和DI的基本实现</li><li>spring-beans：BeanFactory和Bean的装配管理(BeanFactory)</li><li>spring-context：Spring context上下文，即IOC容器(AppliactionContext)</li><li>spring-expression：spring表达式语言</li></ul><p><strong>②Spring AOP</strong></p><ul><li>spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy</li><li>spring-aspects：集成AspectJ，AOP应用框架</li><li>spring-instrument：动态Class Loading模块</li></ul><p><strong>③Spring Data Access</strong></p><ul><li>spring-jdbc：spring对JDBC的封装，用于简化jdbc操作</li><li>spring-orm：java对象与数据库数据的映射框架</li><li>spring-oxm：对象与xml文件的映射框架</li><li>spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信</li><li>spring-tx：spring jdbc事务管理</li></ul><p><strong>④Spring Web</strong></p><ul><li>spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器</li><li>spring-webmvc：实现web mvc</li><li>spring-websocket：与前端的全双工通信协议</li><li>spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务</li></ul><p><strong>⑤Spring Message</strong></p><ul><li>Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务</li></ul><p><strong>⑥Spring test</strong></p><ul><li>spring-test：集成测试支持，主要是对junit的封装</li></ul><h2 id="jar包" tabindex="-1"><a class="header-anchor" href="#jar包" aria-hidden="true">#</a> Jar包</h2><p><strong>Table 2.1. Spring Framework Artifacts</strong></p><table><thead><tr><th><strong>ArtifactId</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>spring-aop</strong></td><td>Proxy-based AOP support</td></tr><tr><td><strong>spring-aspects</strong></td><td>AspectJ based aspects</td></tr><tr><td><strong>spring-beans</strong></td><td>Beans support, including Groovy</td></tr><tr><td><strong>spring-context</strong></td><td>Application context runtime, including scheduling and remoting abstractions</td></tr><tr><td>spring-context-support</td><td>Support classes for integrating common third-party libraries into a Spring application context</td></tr><tr><td><strong>spring-core</strong></td><td>Core utilities, used by many other Spring modules</td></tr><tr><td>spring-expression</td><td>Spring Expression Language (SpEL)</td></tr><tr><td>spring-instrument</td><td>Instrumentation agent for JVM bootstrapping</td></tr><tr><td>spring-instrument-tomcat</td><td>Instrumentation agent for Tomcat</td></tr><tr><td><strong>spring-jdbc</strong></td><td>JDBC support package, including DataSource setup and JDBC access support</td></tr><tr><td>spring-jms</td><td>JMS support package, including helper classes to send and receive JMS messages</td></tr><tr><td>spring-messaging</td><td>Support for messaging architectures and protocols</td></tr><tr><td><strong>spring-orm</strong></td><td>Object/Relational Mapping, including JPA and Hibernate support</td></tr><tr><td>spring-oxm</td><td>Object/XML Mapping</td></tr><tr><td>spring-test</td><td>Support for unit testing and integration testing Spring components</td></tr><tr><td>spring-tx</td><td>Transaction infrastructure, including DAO support and JCA integration</td></tr><tr><td>spring-web</td><td>Web support packages, including client and web remoting</td></tr><tr><td>spring-webmvc</td><td>REST Web Services and model-view-controller implementation for web applications</td></tr><tr><td>spring-websocket</td><td>WebSocket and SockJS implementations, including STOMP support</td></tr></tbody></table>',16),$={href:"https://docs.spring.io/spring-framework/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#dependency-management",target:"_blank",rel:"noopener noreferrer"},Y=e('<table><thead><tr><th><strong>JAR文件</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>spring-aop-5.3.9.jar</td><td><strong>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类</strong></td></tr><tr><td>spring-aspects-5.3.9.jar</td><td><strong>提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中</strong></td></tr><tr><td>spring-beans-5.3.9.jar</td><td><strong>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion ofControl / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。</strong></td></tr><tr><td>spring-context-5.3.9.jar</td><td><strong>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。</strong></td></tr><tr><td>spring-context-indexer-5.3.9.jar</td><td>虽然类路径扫描非常快，但是Spring内部存在大量的类，添加此依赖，可以通过在编译时创建候选对象的静态列表来提高大型应用程序的启动性能。</td></tr><tr><td>spring-context-support-5.3.9.jar</td><td>用来提供Spring上下文的一些扩展模块,例如实现邮件服务、视图解析、缓存、定时任务调度等</td></tr><tr><td>spring-core-5.3.9.jar</td><td><strong>Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。</strong></td></tr><tr><td>spring-expression-5.3.9.jar</td><td>Spring表达式语言。</td></tr><tr><td>spring-instrument-5.3.9.jar</td><td>Spring3.0对服务器的代理接口。</td></tr><tr><td>spring-jcl-5.3.9.jar</td><td>Spring的日志模块。JCL，全称为&quot;Jakarta Commons Logging&quot;，也可称为&quot;Apache Commons Logging&quot;。</td></tr><tr><td>spring-jdbc-5.3.9.jar</td><td><strong>Spring对JDBC的支持。</strong></td></tr><tr><td>spring-jms-5.3.9.jar</td><td>这个jar包提供了对JMS 1.0.2/1.1的支持类。JMS是Java消息服务。属于JavaEE规范之一。</td></tr><tr><td>spring-messaging-5.3.9.jar</td><td>为集成messaging api和消息协议提供支持</td></tr><tr><td>spring-orm-5.3.9.jar</td><td><strong>Spring集成ORM框架的支持，比如集成hibernate，mybatis等。</strong></td></tr><tr><td>spring-oxm-5.3.9.jar</td><td>为主流O/X Mapping组件提供了统一层抽象和封装，OXM是Object Xml Mapping。对象和XML之间的相互转换。</td></tr><tr><td>spring-r2dbc-5.3.9.jar</td><td>Reactive Relational Database Connectivity (关系型数据库的响应式连接) 的缩写。这个jar文件是Spring对r2dbc的支持。</td></tr><tr><td>spring-test-5.3.9.jar</td><td>对Junit等测试框架的简单封装。</td></tr><tr><td>spring-tx-5.3.9.jar</td><td><strong>为JDBC、Hibernate、JDO、JPA、Beans等提供的一致的声明式和编程式事务管理支持。</strong></td></tr><tr><td>spring-web-5.3.9.jar</td><td><strong>Spring集成MVC框架的支持，比如集成Struts等。</strong></td></tr><tr><td>spring-webflux-5.3.9.jar</td><td><strong>WebFlux是 Spring5 添加的新模块，用于 web 的开发，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流程响应式编程出现的框架。</strong></td></tr><tr><td>spring-webmvc-5.3.9.jar</td><td><strong>SpringMVC框架的类库</strong></td></tr><tr><td>spring-websocket-5.3.9.jar</td><td>Spring集成WebSocket框架时使用</td></tr></tbody></table><h1 id="版本命名规范" tabindex="-1"><a class="header-anchor" href="#版本命名规范" aria-hidden="true">#</a> 版本命名规范</h1><figure><img src="'+o+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li>GA： GA (general availability)</li><li>Snapshot</li><li>M： milestone</li><li>RC： release candidate</li></ul><p>企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p><ul><li><p>JDK：Java17+<strong>（Spring6要求JDK最低版本是Java17）</strong></p></li><li><p>Maven：3.6+</p></li><li><p>Spring：6.0.2</p></li><li><p>JavaBean： Spring 的容器所管理的对象就是 JavaBean，有时候也称为 SpringBean（没毛病！）</p></li><li><p>设计模式原则 DIP 和 IoC 的区别</p><ul><li>DIP（<strong>依赖倒置原则</strong>，Dependence Inversion Principle）是设计模式中的一种设计原则，主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让<strong>上层</strong>不再依赖<strong>下层</strong>，下面改动了，上面的代码不会受到牵连，属于GoF 的一种；</li><li>IoC（<strong>控制反转</strong>， Inversion of Control ）： 不是一项技术，而是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中，作用是帮助我们进行解耦；主要作用是 Bean 的管理； <ul><li>Bean 管理是什么？ <ul><li><strong>Bean对象的创建</strong></li><li><strong>Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）</strong></li></ul></li><li>反转的是什么？ <ul><li>将对象的创建权利交出去，交给第三方容器负责。</li><li>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</li></ul></li></ul></li><li>DI是实现了IoC的一种常见的技术实现方式，另一种方式是依赖查找；</li><li>Spring框架就是一个实现了IoC思想的框架；接口注入会使类之间形成一定的依赖关系，产生侵入性，所以Spring不支持接口注入，这不是Spring的缺点，而应该是优点。</li></ul></li></ul><p><strong>DIP 和 IoC 都是一种建模时采用的设计原则，DI 是实现 IoC 的一种实现思路（另一种是依赖查找），Spring 是实现了 DI 的一种 Java 领域的一个框架。</strong></p><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>IoC 与 DI 


控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则。
控制反转的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。
控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI），狭义上讲，依赖注入就是指对象A依赖于对象B的情况；广义上讲，依赖注入也指某一类对象依赖于某一种特定功能的情况，比如项目中所有的接口中都需要添加安全控制的功能。
通常，依赖注入的实现由包括两种方式：
● set方法注入
● 构造方法注入
而Spring框架就是一个实现了IoC思想的框架。
IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。（GoF指的是23种设计模式）

● 控制反转是一种思想。
● 控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。
● 控制反转，反转的是什么？
  ○ 将对象的创建权利交出去，交给第三方容器负责。
  ○ 将对象和对象之间关系的维护权交出去，交给第三方容器负责。
● 控制反转这种思想如何实现呢？
  ○ DI（Dependency Injection）：依赖注入

依赖注入 (Dependency Injection) 和自动装配 (Autowiring) 是 Java 程序开发中常用的两种设计模式，它们的作用是解决对象之间的依赖关系。

依赖注入是一种设计模式，可以将对象的依赖关系从对象本身解耦出来，并使用外部组件来注入依赖关系。这样，对象本身不再需要知道其他对象的细节，也不需要手动创建依赖关系，从而提高了代码的可读性、可维护性和可测试性。

自动装配是 Spring 框架中的一个特性，它可以自动创建并维护依赖关系，使得开发者不需要手动配置。自动装配可以使用 @Autowired 注解或者 XML 配置方式进行配置，它会自动选择合适的 Bean 用于装配。

总的来说，依赖注入是一种设计模式，而自动装配是在依赖注入基础上的一种实现方式，它们的目的都是解决对象之间的依赖关系，但自动装配比依赖注入更易于使用。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从两个例子中来说明 Spring 没出现之前的“黑夜”。</p><ol><li>从 EJB 部署方式上</li><li>从构造方法的灵活性上</li><li>从基于设计模式建模上面（不断地给已有功能添加新需求）</li></ol></blockquote><h1 id="例子-1-设计模式角度" tabindex="-1"><a class="header-anchor" href="#例子-1-设计模式角度" aria-hidden="true">#</a> 例子 1: 设计模式角度</h1><blockquote><p>例子中说明并解释 DIP 。</p></blockquote><h3 id="使用设计模式建模" tabindex="-1"><a class="header-anchor" href="#使用设计模式建模" aria-hidden="true">#</a> 使用设计模式建模</h3><figure><img src="`+l+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h1 id="例子-2-构造方法的灵活性" tabindex="-1"><a class="header-anchor" href="#例子-2-构造方法的灵活性" aria-hidden="true">#</a> 例子 2: 构造方法的灵活性</h1><p>我们想要使用上面的技术来完成某个业务功能时，可能会有这样的情况：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class A{
    public void m1(){}
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如，我们想要在B中调用A中的m1()方法，那么我们可以这样做：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class B{
    private A a; // @1
    public B(){
        this.a = new A(); //@2 此时，A的构造过程是由B控制的
    }
    public void m1(){
        this.a.m1(); //@3
    }
}

// 使用的过程是这样的：
test(){
    B b = new B();
    b.m1();
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是随着业务的发展，我们会发现上面这种方式不利于扩展，于是我们把原来在A的构造过程交出去，让使用B的使用者随意的组织A的构造过程，于是我们这样实现：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class B{
    private A a;
    public B(A a){
        this.a = a;
    }
    public void m1(){
        this.a.m1(); 
    }
}

test(){
    A a = new A();  // 把A的构造过程交给了使用者test()
    B b = new B(a);
    b.m1();
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是随着业务的发展，我们又发现，上面这种方式也不利于扩展，例如如果B中依赖很多的类似于A的对象，比如需要依赖于C、D、E、F或者更多对象，那么我们首先要调整B的构造方法，其次还要调整test()的使用过程，于是代码又变成这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class B{
    private A a;
    private C c;
    
    private D d;
    private E e;
    public B(A a, C c, D d, E e){
        this.a = a;
        this.c = c;
        this.d = d;
        this.e = e;
    }
    public void m1(){
        this.a.m1(); 
    }
}

test(){
    // A/C/D/E 的构造过程仍然在使用者test()手里
    A a = new A(); 
    C c = new C();
    D d = new D();
    E e = new E();
    B b = new B(a, c, d, e);
    b.m1();
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，我们会发现，在Spring还没有出现之前的第二个软件危机，<strong>编程语言特性决定的bean的构造过程的灵活特性，同时也导致bean的管理与维护不够标准和规范。</strong> 传统的软件工程中存在“危机”：</p><ul><li><strong>软件过程中，非业务相关的技术步骤过于复杂与重复。</strong></li><li><strong>编程语言特性决定的bean的构造过程的灵活特性，同时也导致bean的管理与维护不够标准和规范。</strong></li></ul><p><strong>而Spring的出现，彻底解决了上面的这些问题。</strong></p><h3 id="防止di的滥用" tabindex="-1"><a class="header-anchor" href="#防止di的滥用" aria-hidden="true">#</a> 防止DI的滥用</h3><h4 id="原则一" tabindex="-1"><a class="header-anchor" href="#原则一" aria-hidden="true">#</a> 原则一</h4><p>建模时辨别清楚<code>对象生命周期</code>就不难选择采用DI还是创建对象：</p><ul><li>依赖关系不需要DI也不需要创建对象；</li><li>关联关系和聚合关系需要采用DI方式；</li><li>组合关系需要创建对象方式；</li></ul><h4 id="原则二" tabindex="-1"><a class="header-anchor" href="#原则二" aria-hidden="true">#</a> 原则二</h4><p>在决定采用DI设计后，马上要考虑的是注入方式问题。DI中注入方式主要有构造函数注入和Setter注入（还有接口注入较少使用，本文不讨论）。“人与身份证的依赖关系”适合采用Setter注入，因为人不是一出生就有身份证，而是到了法定年龄才有，用构造函数注入表达的语义与此相违背。相反“人与父母的依赖关系”则适合采用构造函数注入，因为亲子关系是从人一出生就建立的，用Setter注入必然使得对象创建后有一段时间处于非法状态，按契约式设计的术语即破坏了对象的不变量(invariant)。</p><h1 id="ejb-部署" tabindex="-1"><a class="header-anchor" href="#ejb-部署" aria-hidden="true">#</a> EJB 部署</h1><p>例如，使用早期的Java技术来实现Web应用时，我们会这样实现：</p><ol><li>使用idea创建一个web项目</li><li>创建servlet，servlet中写业务代码，组装需要数据，将数据以json格式输出</li><li>在web.xml中配置servlet信息</li><li>将项目部署到tomcat中</li></ol><p>分析一下上面这种开发方式：</p><ul><li>与业务相关的只有第2步中的“业务代码”部分，其余步骤均为非业务相关的技术步骤——非业务相关的技术步骤过于复杂；</li><li>当有很多个web模块时，每个模块都要重复1/3/4步骤——非业务相关的技术步骤过于重复；</li></ul><p>因此，我们会发现，在Spring还没有出现之前的第一个软件危机，即： <strong>软件过程中，非业务相关的技术步骤过于复杂与重复。</strong></p><hr><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 下面是对上面的做了一个总结</label></li></ul><h3 id="ejb前置知识" tabindex="-1"><a class="header-anchor" href="#ejb前置知识" aria-hidden="true">#</a> EJB前置知识</h3><ol><li>背景知识：互联网产品的发展历程</li><li>RMI+网络处理=RPC</li><li>POJO、Java 语言的缺陷并由此衍生出来的 javaBean 的概念、为满足软件复用而提出来的「组件」的概念</li><li>为满足「工程化开发」的需求而设计出的软件实现形式：EJB</li></ol><h4 id="互联网产品的服务模式的发展与迭代" tabindex="-1"><a class="header-anchor" href="#互联网产品的服务模式的发展与迭代" aria-hidden="true">#</a> 互联网产品的服务模式的发展与迭代</h4><ul><li>singleton应用模式： 把完成企业各项任务的互联网产品进行封装，然后把封装后的这个互联网产品放到客户端运行，这样的互联网产品的构建模式就是狭义上的“单体应用”。【现在广义上的“单体应用”是指，各个功能模块没有拆分，还是聚合在一起的应用】</li><li>CS模式： 后来人们发现上面的单体应用模式会产生一些问题，比如上面的这种产品多是一锤子买卖，不会有后续更新的可能性。于是人们就想，把一些核心功能放到某一台主机上，让这台主机来完成核心功能，其余非核心功能就放到客户端。这样就产生了cs模式的应用。</li><li>BS模式： 后来人们又发现cs模式也不太行，因为互联网产品更新迭代过程太快了，可能连客户端也需要经常来更新和维护了。于是人们就又基于网络开发出BS模式的互联网产品。就是把原来直接安装到客户端主机上的客户端软件，直接简化，简化成只有一个域名的互联网入口，所有的企业级服务都通过网络来提供。</li></ul><h4 id="rpc、rmi" tabindex="-1"><a class="header-anchor" href="#rpc、rmi" aria-hidden="true">#</a> RPC、RMI</h4><ul><li>RPC（Remote Procedure Call）： <s>说白了，就是本地计算机调用远程计算机上的一个函数。在 Java 之前的大多数编程语言，如，Fortran、C、COBOL 等等，都是过程性的语言，而不是面向对象的。所以，这些编程语言非常自然地用过程表示工作。也就是 RPC 并不是Java的专有名词。但是这种开发模式，需要程序员关注网络部分，也就是说除了要编写远程计算机上的任务函数外，在本地计算机上调用远程计算机上的任务函数时，还要关注如何使用网络问题（如网络传输的协议、数据传输的格式、网络的异常处理等）。</s></li><li>RMI（Remote Method Invocation）： <s>由于 RPC 过程需要额外处理网络的问题，在发展过程中人们发现网络问题是通用的，人们可以把网络问题的处理过程抽象出来，让程序员只关注实际的业务处理部分。于是，这种实现方式就变成了本地主机直接调用远程主机的方法。于是 RMI 出现。</s></li></ul><p>可以理解为： RMI + 网络处理 = RPC。</p><h4 id="java语言的设计缺陷" tabindex="-1"><a class="header-anchor" href="#java语言的设计缺陷" aria-hidden="true">#</a> Java语言的设计缺陷</h4>`,47),nn={href:"https://www.zhihu.com/question/19773379/answer/31625054",target:"_blank",rel:"noopener noreferrer"},an=e('<p>比如有这样一个场景：我们要设计一个List类并且需要保存这个List的大小。那么，我们的实现方式可能是这样的：我们直接把size直接设置成pulic的形式，然后通过“对象.size”的方式进行访问，并通过“对象.size”的方式进行设值。</p><p>但是这种方式会有两个问题：</p><ul><li>那就是每一个new出来的对象都有一个size变量，如果很多list对象，那就需要有很多的内存空间来保存这个size变量；</li><li>随着业务的发展，list可能需要增加多个属性，比如name等，也就是说每一个list对象所占用的内存空间可能就不固定，会根据属性的增多而变大；</li></ul><p>于是人们就使用另外一种方式来实现上面的这个场景：把属性设置成private的形式，然后通过添加对属性的get、set方法，实现对这个属性的控制。这种设计方式就解决了上面可能会遇到的两个问题。</p><p>从这件事情上得到一个结论： <strong>Java语言的设计是有缺陷的</strong>。并由此，人们又得出一个结论： 人们在使用Java时需要有一些规范或规约。比如上面的例子中，对属性的控制是通过添加针对属性的 get、set 方来控制而不是通过「对象.属性」的方式。于是，JavaBean登场。</p><h4 id="pojo、组件、javabean" tabindex="-1"><a class="header-anchor" href="#pojo、组件、javabean" aria-hidden="true">#</a> POJO、组件、JavaBean</h4><p>POJO 的全称是 Plain Old Java Object, 简单又老的 Java 对象。那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。2005年11月时，“POJO”主要<strong>用来指代那些没用遵从特定的Java对象模型，约定或框架（如EJB）的Java对象</strong>。 POJO（Plain Old Java Object, 简单又老的 Java 对象）<strong>： 不继承任何类、也不实现任何接口、更不遵循任何约定、也不被任何框架侵入的Java对象</strong>，理想情况下，<strong>POJO是一个只遵循Java语言规范的Java对象</strong>。</p><p>所谓<strong>组件</strong>就是一个由可以自行进行内部管理的一个或几个类所组成、外界不了解其内部信息和运行方式的群体。使用它的对象只能通过接口来操作。</p><p>人们把满足下面特征的Java对象统称为<strong>JavaBean</strong>：</p><ul><li><strong>提供默认的构造方法；</strong></li><li><strong>所有属性的访问范围为private；</strong></li><li><strong>提供针对属性的get、set方法；</strong></li><li><strong>实现序列化接口；</strong></li></ul><p>简而言之，当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean。（没毛病！） Bean的含义是可重复使用的Java组件。</p><p><strong>EJB 2.x 的 Entity Beans 比较重量，需要实现 javax.ejb 的一些接口</strong>。而 POJO 就比较轻量，就是一个 Java 对象，不需要实现任何的接口。 有了这个概念（惯例），Spring, Hibernate 这些框架交流、实现起来，都大量使用 Bean 这个概念。比如“注入一个 Bean“，“声明一个 Bean”，你就知道这里的这个 Bean 必须要有无参数的构造函数，必须要有 setter/getter 等等。这些框架在使用的时候，会采用初始化出来 Bean 然后 setXX() 这种方式，构造出来最终的 Bean.</p><h4 id="对象的状态" tabindex="-1"><a class="header-anchor" href="#对象的状态" aria-hidden="true">#</a> 对象的状态</h4><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。</p></blockquote><p>对象的状态： 有状态 VS 无状态</p><ul><li>有状态：有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</li><li>无状态：无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。</li></ul><h4 id="ejb" tabindex="-1"><a class="header-anchor" href="#ejb" aria-hidden="true">#</a> EJB</h4><p>EJB（Enterprise Java Bean）： EJB 的官方解释是“商务软件的核心部分是它的业务逻辑。业务逻辑抽象了整个商务过程的流程，并使用计算机语言将他们实现。”变成大白话就是，“把你编写的软件中那些须要执行制定的任务的类，不放到client软件上了，而是给他打成包放到一个server上了”。通过RMI 技术，J2EE 将EJB 组件创建为远程对象，EJB 尽管用了RMI 技术，可是却仅仅需要定义远程接口而无需生成他们的实现类，这样就将RMI 技术中的一些细节问题屏蔽了。但无论怎么说，EJB 的基础仍然是RMI，所以，假设你想了解EJB 的原理，仅仅要把RMI的原理搞清楚即可了。</p><hr><h3 id="ejb概述-1" tabindex="-1"><a class="header-anchor" href="#ejb概述-1" aria-hidden="true">#</a> EJB概述</h3><ol><li>jdk只完成了基于Java语言实现简单的功能，如科学计算等；</li><li>商业软件中需要很多的特性，于是Java语言开发出适合企业使用的功能，实现这些功能的Java语言称为J2EE；</li><li>基于J2EE实现企业级功能的实现方式有一种事实上的规范，这种规范就是EJB，它最大的特点就是<strong>把核心的商业功能拆分成server端</strong>和<strong>非核心的商业功能拆分成client端</strong>，然后client端和server端通过RMI方式连接，并为了实现算力最大化，在server端实现了服务集群的过程。即EJB最大特点是：<code>**cs模式+RMI+服务集群**</code>。所以EJB逐渐成为J2EE的一部分。</li><li>在EJB中，<strong>把具有某种可重复使用功能的Java组件叫做Bean</strong>。Java Bean是基于Java的组件模型，由属性、方法和事件3部分组成。在该模型中，JavaBean可以被修改或与其他组件结合以生成新组件或完整的程序。它是一种Java类，通过封装成为具有某种功能或者处理某个业务的对象。</li><li>除了这种bean以外，还有一种Java类，这种类不继承任何类、也不实现任何接口、更不会使用任何框架，这种类就称为 POJO 。</li><li>后来EJB中的Bean发展成为一个软件开发标准，人们又总结发展出另外一个概念： JavaBean，即<code>凡是具有默认构造函数、属性私有化、提供针对属性的get和set方法并实现序列化接口的POJO统称为JavaBean</code>。</li><li>PO、VO、DTO、DO、BO等是后续发展过程中不断添加的一些概念。</li></ol><p>在没有出现Spring之前，EJB是Java领域大型企业级应用的主要技术选型。但EJB有着很大的问题：</p><ol><li>整个软件过程中，非业务相关的技术步骤过于复杂与重复。比如每开发一个模块就都需要创建servlet、web.xml等，还需要重量级容器作为支撑等；</li><li>EJB并没有对Bean的管理和维护设置统一标准，这使得Bean的管理和维护极其混乱；</li><li>EJB的交叉业务实现过程复杂。比如安全控制、日志记录、事务控制等交叉业务，需要在每个需求中都要进行实现；</li><li>由于框架的复杂性，导致很多业务模块的开发过程并不能很好的遵守设计模式中的 OCP（开闭原则，Open Closed Principle） 原则和 DIP（依赖倒置原则，Dependence Inversion Principle） 原则，这导致项目模块耦合性较强，耦合性越强，可扩展性就越差；</li><li>程序员技术专业素养参差不齐及对 EJB 开发技术的理解不同，造成基于 EJB 的软件过程实现方式多种多样，最终导致软件危机</li><li>......</li></ol><p>EJB的技术，重点在于想方设法实现一个又一个的可复用的JavaBean组件。但是这个过程中需要程序员自行实现，而由于<code>程序员技术素养的差别</code>以及<code>Java语言的灵活性特点</code>，这又导致Bean的实现过程千差万别；再者，随着系统的迭代，类就会膨胀，也会变得越来越复杂，最终导致软件系统失去控制。</p><div class="hint-container tip"><p class="hint-container-title">传统软件过程的噩梦</p><p>以上问题，最终抽象并总结起来就是： <code>Bean的构造权和Bean的依赖关系的控制权</code> 的归属问题。即传统的软件开发过程中，<code>Bean的构造权和Bean的依赖关系的控制权</code>等均由负责开发的程序员来完成，由于每个程序员的专业素养的不同以及Java语言的灵活性，就导致Bean的实现方式各式各样，最终导致软件系统失去控制。</p></div><h3 id="spring前夕的挣扎" tabindex="-1"><a class="header-anchor" href="#spring前夕的挣扎" aria-hidden="true">#</a> Spring前夕的挣扎</h3><blockquote><p>在Spring未出现之前，为了解决上面的问题，提出了按照设计原则的方式，有效缓解了上面的问题。但是依旧仍然存在问题： 程序员需要实现业务以外的额外的功能。</p></blockquote><ul><li>JavaBean： Spring 的容器所管理的对象就是 JavaBean，有时候也称为 SpringBean（没毛病！）</li><li>设计模式原则 DIP 和 IoC 的区别 <ul><li>DIP（<strong>依赖倒置原则</strong>，Dependence Inversion Principle）是设计模式中的一种设计原则，主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让<strong>上层</strong>不再依赖<strong>下层</strong>，下面改动了，上面的代码不会受到牵连，属于 GoF 的一种；</li><li>IoC（<strong>控制反转</strong>， Inversion of Control ）： 不是一项技术，而是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中，作用是帮助我们进行解耦；主要作用是 Bean 的管理； <ul><li>Bean 管理是什么？ <ul><li><strong>Bean对象的创建</strong></li><li><strong>Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）</strong></li></ul></li><li>反转的是什么？ <ul><li>将对象的创建权利交出去，交给第三方容器负责。</li><li>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</li></ul></li></ul></li><li>DI（依赖注入 Dependence Inversion）是实现了IoC的一种常见的技术实现方式，另一种方式是依赖查找；</li><li>Spring框架就是一个实现了IoC思想的框架；接口注入会使类之间形成一定的依赖关系，产生侵入性，所以Spring不支持接口注入，这不是Spring的缺点，而应该是优点。</li></ul></li></ul><p><strong>DIP 和 IoC 都是一种建模时采用的设计原则，DI 是实现 IoC 的一种实现思路（另一种是依赖查找），Spring 是实现了 DI 的一种 Java 领域的一个框架。</strong></p><figure><img src="'+l+'" alt="1697994094493.png" tabindex="0" loading="lazy"><figcaption>1697994094493.png</figcaption></figure><h3 id="spring诞世" tabindex="-1"><a class="header-anchor" href="#spring诞世" aria-hidden="true">#</a> Spring诞世</h3><p>因此，人们就想，能不能造出一种工具，这种工具能让程序员从复杂而又灵活的实现方式中解脱出来。于是Spring应运而生。事实上，随着时间的发展，Spring也逐渐成为Java企业级应用的“事实标准”。</p><p>这款软件产品完成了本来需要程序员完成的功能，例如：</p><ol><li>单个Bean的生命周期管理；</li><li>多个Bean的组织和装配，说白了就是能够处理多个Bean之间的相互依赖关系，何时构造、何时组织和装配；</li></ol><blockquote><p>组织和装配： 比如 Student 类中有一个 Class 类，表明学生所属的班级信息，我们自定义实现时，会new一个class对象，然后把这个class对象传给student作为student的构造参数。有了Spring之后就只需要写Student类和Class类，这二者之间的组织过程和装配过程就交给Spring来处理了。</p></blockquote><p>上面问题总结和抽象一下就是： 没有一个能够管理对象的构造以及对象与对象之间依赖关系的组件。我们试想，如果我们设计并实现一个能够完成这样功能的组件，那我们是不是就可以从上面这些繁重的开发工作中解脱出来，并且我们也能够规范我们的开发流程，到最后我们剩下的工作就真正实现“只专注生成 JavaBean 以及处理这些 Bean 之间的关系”的目标了。</p><p>幸运的是，有这样的组件——Spring。核心原理分成几个步骤：</p><ol><li>把Bean简单化，简单到只完成具体的业务功能，简单的实现思路就是把通用功能和具体的业务功能进行剥离，然后形成一个个独立的Bean。结果就涉及到另外一个问题： 如何管理这些单个独立的Bean，答案是： 构造一个管理所有Bean的组件并实现控制反转（IoC），即实现一个组件，让这个组件具有管理所有Bean的功能，并且这个组件能够控制Bean的生命周期（即Bean的构造和销毁，以及中间的使用过程）。</li><li>完成上面的步骤后，还涉及到另外两个问题： <ol><li>如何把剥离出来的通用功能（如日志管理功能、安全控制功能）重新组织回Bean；</li><li>如何组织和管理不同Bean复用； 解决上面两个问题的思路是： 依赖注入（DI），即把这些通用的功能使用某种技术注入到Bean中，具体的实现技术是： 动态代理，思路是在运行期动态生成新的Java代码，让Java代码重新具有完成所有的功能。</li></ol></li></ol><h4 id="相关特性" tabindex="-1"><a class="header-anchor" href="#相关特性" aria-hidden="true">#</a> 相关特性</h4><ul><li>轻量级 、非侵入</li><li>实现了<strong>控制反转和容器</strong></li><li>支持<strong>面向切面编程</strong></li><li>支持<strong>事物管理</strong></li><li>组件化、模块化、一站式</li><li>......</li></ul><figure><img src="'+p+'" alt="1699281071220.png" tabindex="0" loading="lazy"><figcaption>1699281071220.png</figcaption></figure><h4 id="组件-1" tabindex="-1"><a class="header-anchor" href="#组件-1" aria-hidden="true">#</a> 组件</h4><figure><img src="'+i+'" alt="1697786119443" tabindex="0" loading="lazy"><figcaption>1697786119443</figcaption></figure><ul><li><strong>①Spring Core（核心容器）</strong> spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。 <ul><li>spring-core ：IOC和DI的基本实现</li><li>spring-beans：BeanFactory和Bean的装配管理(BeanFactory)</li><li>spring-context：Spring context上下文，即IOC容器(AppliactionContext)</li><li>spring-expression：spring表达式语言</li></ul></li><li><strong>②Spring AOP</strong><ul><li>spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy</li><li>spring-aspects：集成AspectJ，AOP应用框架</li><li>spring-instrument：动态Class Loading模块</li></ul></li><li><strong>③Spring Data Access</strong><ul><li>spring-jdbc：spring对JDBC的封装，用于简化jdbc操作</li><li>spring-orm：java对象与数据库数据的映射框架</li><li>spring-oxm：对象与xml文件的映射框架</li><li>spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信</li><li>spring-tx：spring jdbc事务管理</li></ul></li><li><strong>④Spring Web</strong><ul><li>spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器</li><li>spring-webmvc：实现web mvc</li><li>spring-websocket：与前端的全双工通信协议</li><li>spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务</li></ul></li><li><strong>⑤Spring Message</strong><ul><li>Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务</li></ul></li><li><strong>⑥Spring test</strong><ul><li>spring-test：集成测试支持，主要是对junit的封装</li></ul></li></ul><table><thead><tr><th><strong>JAR文件</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>spring-aop-5.3.9.jar</td><td><strong>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类</strong></td></tr><tr><td>spring-aspects-5.3.9.jar</td><td><strong>提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中</strong></td></tr><tr><td>spring-beans-5.3.9.jar</td><td><strong>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion ofControl / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。</strong></td></tr><tr><td>spring-context-5.3.9.jar</td><td><strong>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。</strong></td></tr><tr><td>spring-context-indexer-5.3.9.jar</td><td>虽然类路径扫描非常快，但是Spring内部存在大量的类，添加此依赖，可以通过在编译时创建候选对象的静态列表来提高大型应用程序的启动性能。</td></tr><tr><td>spring-context-support-5.3.9.jar</td><td>用来提供Spring上下文的一些扩展模块,例如实现邮件服务、视图解析、缓存、定时任务调度等</td></tr><tr><td>spring-core-5.3.9.jar</td><td><strong>Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。</strong></td></tr><tr><td>spring-expression-5.3.9.jar</td><td>Spring表达式语言。</td></tr><tr><td>spring-instrument-5.3.9.jar</td><td>Spring3.0对服务器的代理接口。</td></tr><tr><td>spring-jcl-5.3.9.jar</td><td>Spring的日志模块。JCL，全称为&quot;Jakarta Commons Logging&quot;，也可称为&quot;Apache Commons Logging&quot;。</td></tr><tr><td>spring-jdbc-5.3.9.jar</td><td><strong>Spring对JDBC的支持。</strong></td></tr><tr><td>spring-jms-5.3.9.jar</td><td>这个jar包提供了对JMS 1.0.2/1.1的支持类。JMS是Java消息服务。属于JavaEE规范之一。</td></tr><tr><td>spring-messaging-5.3.9.jar</td><td>为集成messaging api和消息协议提供支持</td></tr><tr><td>spring-orm-5.3.9.jar</td><td><strong>Spring集成ORM框架的支持，比如集成hibernate，mybatis等。</strong></td></tr><tr><td>spring-oxm-5.3.9.jar</td><td>为主流O/X Mapping组件提供了统一层抽象和封装，OXM是Object Xml Mapping。对象和XML之间的相互转换。</td></tr><tr><td>spring-r2dbc-5.3.9.jar</td><td>Reactive Relational Database Connectivity (关系型数据库的响应式连接) 的缩写。这个jar文件是Spring对r2dbc的支持。</td></tr><tr><td>spring-test-5.3.9.jar</td><td>对Junit等测试框架的简单封装。</td></tr><tr><td>spring-tx-5.3.9.jar</td><td><strong>为JDBC、Hibernate、JDO、JPA、Beans等提供的一致的声明式和编程式事务管理支持。</strong></td></tr><tr><td>spring-web-5.3.9.jar</td><td><strong>Spring集成MVC框架的支持，比如集成Struts等。</strong></td></tr><tr><td>spring-webflux-5.3.9.jar</td><td><strong>WebFlux是 Spring5 添加的新模块，用于 web 的开发，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流程响应式编程出现的框架。</strong></td></tr><tr><td>spring-webmvc-5.3.9.jar</td><td><strong>SpringMVC框架的类库</strong></td></tr><tr><td>spring-websocket-5.3.9.jar</td><td>Spring集成WebSocket框架时使用</td></tr></tbody></table><figure><img src="'+o+'" alt="版本命名规范" tabindex="0" loading="lazy"><figcaption>版本命名规范</figcaption></figure><ul><li>GA： GA (general availability)</li><li>Snapshot</li><li>M： milestone</li><li>RC： release candidate</li></ul><p>企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p><ul><li>JDK：Java17+<strong>（Spring6要求JDK最低版本是Java17）</strong></li><li>Maven：3.6+</li><li>Spring：6.0.2</li></ul><h4 id="套装" tabindex="-1"><a class="header-anchor" href="#套装" aria-hidden="true">#</a> 套装</h4><ul><li>SpringBoot</li><li>SpringCloud</li></ul><h2 id="_2-bean" tabindex="-1"><a class="header-anchor" href="#_2-bean" aria-hidden="true">#</a> 2. Bean</h2><blockquote><p>思路：容器中保存的内容就是Bean -&gt; 那何为bean -&gt; 如何描述Bean -&gt; Bean注册到容器的方式 -&gt; 在Bean中使用另一个Bean -&gt; Bean的装配【何为装配、装配的分类】 -&gt; Bean的生命周期 -&gt; 针对生命周期的扩展使用 -&gt; 实际的业务场景作为佐例 常用 Bean</p></blockquote><h2 id="_3-容器" tabindex="-1"><a class="header-anchor" href="#_3-容器" aria-hidden="true">#</a> 3. 容器</h2><blockquote><p>使用工厂模式实现自定义的容器 高层视图 BeanFactory Application FactoryBean BeanDefinition BeanDefinitionReader 常见容器、父子容器</p></blockquote><p>关键api： beanDefinition \\ PropertiesBeanDefinitionReader \\ BeanFactory \\ ApplicationContext \\</p><h3 id="高层视图" tabindex="-1"><a class="header-anchor" href="#高层视图" aria-hidden="true">#</a> 高层视图</h3><figure><img src="'+k+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="什么是容器" tabindex="-1"><a class="header-anchor" href="#什么是容器" aria-hidden="true">#</a> 什么是容器</h3><p>利用控制反转（IoC）的设计思想，剥夺程序员对Bean的部分控制权，并把这些被剥夺的控制权给到Spring。于是，Spring就要提供管理这些控制权的解决方案，这个解决方案就是容器。</p><p>所谓容器，就是说Spring提供了一个类似于数据库的功能，只不过这个功能保存的是JavaBean。</p><figure><img src="'+g+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>如上图，步骤解析如下：</p><ol><li>读取各种各样的配置文件，从中获取各种各样的pojo；</li><li>Spring容器就从这些配置文件中，获得pojo的文件所在位置，并生成一个 Bean 的注册表；</li><li>Spring容器会根据 Bean的注册表 实例化Bean，并把实例化后的bean放入 Bean 缓存池里面，以便后续的使用；</li></ol><h3 id="启动流程" tabindex="-1"><a class="header-anchor" href="#启动流程" aria-hidden="true">#</a> 启动流程</h3><p>Spring的IOC容器工作的过程，其实可以划分为两个阶段**： 容器启动阶段<strong>和</strong>Bean实例化阶段**。</p><p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的Bean定义中。</p><figure><img src="'+v+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>容器启动开始，首先会通过某种途径加载Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Congiguration MetaData进行解析和分析，并将分析后的信息组为相应的BeanDefinition。</p><p>最后把这些保存了Bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动就完成了。</p><p>父子容器</p><h3 id="beanfactory-vs-applicationcontext" tabindex="-1"><a class="header-anchor" href="#beanfactory-vs-applicationcontext" aria-hidden="true">#</a> BeanFactory vs ApplicationContext</h3><h4 id="beanfactory" tabindex="-1"><a class="header-anchor" href="#beanfactory" aria-hidden="true">#</a> BeanFactory</h4><figure><img src="'+m+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>BeanFactory是类的通用工厂，可以创建并管理各种类的对象。 Spring为BeanFactory提供了很多种实现，最常用的是XmlBeanFactory，但在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory。</p><p>BeanFactory接口位于类结构树的顶端，它最主要的方法就是getBean(String var1)，这个方法从容器中返回特定名称的Bean。 BeanFactory的功能通过其它的接口得到了不断的扩展，比如AbstractAutowireCapableBeanFactory定义了将容器中的Bean按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。</p><h4 id="applicationcontext" tabindex="-1"><a class="header-anchor" href="#applicationcontext" aria-hidden="true">#</a> ApplicationContext</h4><figure><img src="'+b+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。可以这么说，使用BeanFactory就是手动档，使用ApplicationContext就是自动档。 ApplicationContext 继承了HierachicalBeanFactory和ListableBeanFactory接口，在此基础上，还通过其他的接口扩展了BeanFactory的功能，包括：</p><ul><li>Bean instantiation/wiring</li><li>Bean 的实例化/串联</li><li>自动的 BeanPostProcessor 注册</li><li>自动的 BeanFactoryPostProcessor 注册</li><li>方便的 MessageSource 访问（i18n）</li><li>ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化</li></ul><p><img src="'+h+'" alt="image.png" loading="lazy"> 主要实现类有哪些？</p><table><thead><tr><th><strong>类型名</strong></th><th><strong>简介</strong></th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>ConfigurableApplicationContext</td><td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h4><ul><li>BeanFactory（Bean工厂） <ul><li>是Spring框架的基础设施，面向Spring本身。</li><li>主要方法getBean(String var1)，这个方法从容器中返回特定名称的Bean。</li></ul></li><li>ApplicantContext（应用上下文） <ul><li>建立在BeanFactoty基础上，面向使用Spring框架的开发者。</li><li>提供了更多面向实际应用的功能。</li><li>常见的实现有 ClassPathXmlApplicationContext 、 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext</li></ul></li></ul><p>FactoryBean</p><h2 id="_4-aop" tabindex="-1"><a class="header-anchor" href="#_4-aop" aria-hidden="true">#</a> 4. AOP</h2><blockquote><ol><li>实际业务开发过程中遇到的一些问题，引出代理模式</li><li>代理模式的基本概念、分类、实现原理</li><li>基于代理模式发展出面向切面编程（AOP）的相关概念</li><li>Spring技术栈中的面向切面编程示例</li><li>AOP的常见应用场景【统计方法执行耗时等】</li></ol></blockquote><ol><li>模拟传统开发过程，体会过程中遇到的困难；</li><li>实现一个简易版的Spring，只完成Bean的注册与获取；</li><li>需求变更，要求为每一个接口都提供运行时间的统计功能： <ol><li>通过自行编程的方式实现此需求，体会其中的弊端；</li><li>通过JDK代理技术实现此需求，并分析优缺点；</li><li>通过CGLib代理技术实现此需求，并分析优缺点；</li></ol></li><li>体会基于Spring实现上述需求的实现过程，并分析优缺点；</li></ol><h3 id="业务开发时碰到的程序扩展性问题" tabindex="-1"><a class="header-anchor" href="#业务开发时碰到的程序扩展性问题" aria-hidden="true">#</a> 业务开发时碰到的程序扩展性问题</h3><blockquote><ol><li>兼顾开闭原则对 service 进行扩展；</li><li>问题升级： 假设有多个实现类或实现类中有多个方法；</li><li>问题再次升级： 假设提供给我们的是 jar 包，没办法直接操作源代码；</li></ol></blockquote><p>假设有这样一个场景，有一个 IService 接口，里面有三个方法，然后有三个具体的实现类： ServiceA 、 ServiceB 、 ServiceC ：</p><ol><li>如果想要在每一个方法中都添加上统计时间的业务代码，那么我们就需要修改三个具体实现类的每一个方法，这就不符合“开闭原则”；</li><li>如果 IService 接口中有很多方法，并且也有很多的具体的实现类，想要实现统计代码耗时的功能，那代码的改动量会更大；</li><li>如果上面的接口和具体的实现类均有第三方jar包的形式提供给我们，我们是无法修改源码的；</li><li>……</li></ol><p>基于上面的问题，我们可以采用继承的方式来解决，即让 ServiceLowA 继承 ServiceA ， ServiceLowB 继承 ServiceB ， ServiceLowC 继承 ServiceC ，然后重写每一个方法的时候添加上统计耗时的代码。这种方式依然不符合“开闭原则”。那我们应该采用那种方式呢？</p><p>答案是： 代理模式。</p><h3 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式" aria-hidden="true">#</a> 代理模式</h3><blockquote><ol><li>代理模式的含义、分类；</li><li>静态代理模式分析： 原理、优缺点；</li><li>动态代理模式分析： 原理、实现途径、优缺点、几种模式的对比</li><li>AOP 概念及原理、SpringAOP 与 AsceptJ 的区别；</li></ol></blockquote><h4 id="含义" tabindex="-1"><a class="header-anchor" href="#含义" aria-hidden="true">#</a> 含义</h4><p>代理模式（有些地方也称“委托模式”）是GoF23里面的一种，属于结构型模式。它的基本原理是： 提供一个代理类，让原本是对目标方法的直接调用，变成通过代理类的间接调用。从而达到代码的解耦，也有利于附加功能的统计集中管理。 它包括三个角色：</p><ul><li>代理类（代理主题）</li><li>目标类（真实主题）</li><li>代理类和目标类的公共接口（抽象主题）</li></ul><blockquote><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：交叉业务。</p></blockquote><figure><img src="'+f+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h4>',102),sn={href:"https://juejin.cn/post/6844903744954433544",target:"_blank",rel:"noopener noreferrer"},tn=e('<p>根据<code>代理对象的字节码的创建时机</code>来分类，可以分为静态代理和动态代理。</p><ul><li><p><code>静态代理</code>就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了；使用的实现技术是基于jdk-api的，所以需要程序员自行控制代理类的代码逻辑；</p></li><li><p><code>动态代理</code>的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件；使用一些框架技术，如反射包的proxy、cglib等，不需要程序员自行控制代理类的代码逻辑，只需要程序员关注目标对象及其功能即可。</p><ul><li>JDK 动态代理 <ul><li>实际上是利用了反射包下面的proxy和InvocationHandler接口，为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例，最后由这个代理实例来完成方法增强；</li><li>过延迟代理关系或代理对象构造过程到运行期，解决了静态代理在扩展时需要同时修改目标类和代理类的扩展性问题，实现了进一步解耦的目的，但是 jdk动态代理只能为接口创建代理，还是具有一定的局限性；</li></ul></li><li>CGLib 动态代理 <ul><li>是基于CGLib来完成的，CGLib是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）</li><li>Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对final类进行代理操作；由于CGLib是对字节码做了增强，因此其性能也比JDK动态代理高；</li></ul></li></ul></li><li><p>AsceptJ 动态代理</p></li></ul><div class="hint-container tip"><p class="hint-container-title">Spring AOP 和 **AspectJ**</p><p>Spring AOP 属于运行时增强，主要具有如下特点：</p><ol><li>基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</li><li>Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</li><li>在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</li><li>Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</li></ol><p>AspectJ 是一个易用的功能强大的 AOP 框架，属于编译时增强， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。 AspectJ 属于<strong>静态织入</strong>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p><ol><li>编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</li><li>编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</li><li>类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</li></ol><figure><img src="'+S+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+y+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></div><h3 id="静态代理" tabindex="-1"><a class="header-anchor" href="#静态代理" aria-hidden="true">#</a> 静态代理</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 实现过程：</span>
<span class="token comment">//    1. 创建代理类，代理类实现共同接口，并在代理类中持有共同接口的一个代理对象；</span>
<span class="token comment">//    2. 在代理类中的重写的方法中添加具体的交叉业务代码，完成代码的扩展；</span>
<span class="token comment">//    3. 使用时，构造一个代理类对象，并传入一个实际的目标类的代理对象，然后再由共同的接口完成方法的调用；</span>

<span class="token comment">// 创建IService的代理类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">IService</span> target<span class="token punctuation">;</span>  <span class="token comment">//目标对象，被代理的对象</span>

    <span class="token keyword">public</span> <span class="token class-name">ServiceProxy</span><span class="token punctuation">(</span><span class="token class-name">IService</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> starTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.m1()方法耗时(纳秒):&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> starTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> starTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.m1()方法耗时(纳秒):&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> starTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> starTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.m1()方法耗时(纳秒):&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> starTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serviceProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">IService</span> serviceA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建目标对应的代理对象</span>
    <span class="token class-name">IService</span> serviceB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建目标对应的代理对象</span>

    <span class="token comment">// 由代理对象发起实际的调用</span>
    serviceA<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceA<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceA<span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceB<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceB<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceB<span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种方式就是静态代理的实现方式。静态代理的方式实际上应用了“向上转型”的原理，即利用“向上转型”的原理。代理对象的类型和目标对象的类型是在编译期就已经确定了的，因为传入的是 ServiceA 和 ServiceB 的对象，并不是 IService 对象；</p><h4 id="不适合静态代理的" tabindex="-1"><a class="header-anchor" href="#不适合静态代理的" aria-hidden="true">#</a> 不适合静态代理的</h4><p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><ol><li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式： <ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大</li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类</li></ul></li><li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。</li></ol><h4 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h4><ul><li>优点： 实现简单，不侵入源代码，只需要依赖JDK即可完成；</li><li>缺点： 在进行扩展时，需要目标对象和代理对象同时进行修改，具有一定的耦合性；也就是说相比于动态代理，静态代理还是要程序员自行控制代理类代码的编写。</li></ul><h3 id="动态代理" tabindex="-1"><a class="header-anchor" href="#动态代理" aria-hidden="true">#</a> 动态代理</h3>`,12),en={href:"https://www.throwx.cn/2018/12/08/java-reflection-dynamic-proxy/",target:"_blank",rel:"noopener noreferrer"},pn=e(`<p>动态代理主要分为两类： JDK动态代理 和 CGLib动态代理。</p><h4 id="jdk-动态代理" tabindex="-1"><a class="header-anchor" href="#jdk-动态代理" aria-hidden="true">#</a> JDK 动态代理</h4><ol><li><p>代码示例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 需求： 实现上面添加代码耗时的功能</span>
<span class="token comment">// 实现过程：</span>
<span class="token comment">//    1. 创建调用处理器，并实现 java.lang.reflect.InvocationHandler 接口，之后在 invoke() 方法中添加具体的交叉业务逻辑；</span>
<span class="token comment">//    2. 使用时，使用 java.lang.reflect.Proxy#newProxyInstance() 静态方法构造一个代理对象【需要传入三个参数：目标对象、目标方法以及以目标方法的参数】；</span>
<span class="token comment">//    3. 最后由代理对象发起方法的实际调用</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CostTimeInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">CostTimeInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
    * proxy： 代理对象
    * method： 代理对象需要实现的方法，即其中需要重写的方法
    * args： method所对应方法的参数
    */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> starTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用目标对象的方法</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.m1()方法耗时(纳秒):&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> starTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serviceProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">IService</span> serviceA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">IService</span> serviceAProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IService</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
        serviceA<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        serviceA<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">CostTimeInvocationHandler</span><span class="token punctuation">(</span>serviceA<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    serviceA<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceA<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceA<span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">IService</span> serviceB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">IService</span> serviceBProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IService</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
        serviceB<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        serviceB<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">CostTimeInvocationHandler</span><span class="token punctuation">(</span>serviceB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceB<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceB<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serviceB<span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>原理解析</p><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> TODO： 源码阅读</label></li></ul><p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。</p><p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><p>【在运行时构建一个class字节码数组，并将其转换成一个运行时的Class对象，然后构造其实例】</p></li><li><p>优缺点</p><p>动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</p><p>缺点： 代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。</p><p>只能代理接口，不能代理类。</p></li><li><p>静态代理与 jdk 动态代理</p><p>静态代理关键是需要程序员自己构建代理类，这样就会导致代理类的膨胀，还是有一定的耦合性，动态代理就解决了这个问题，它是利用jdk反射包里面的proxy类和invocation接口等，相当于jdk提供了一个代理模式的实现框架，让我们不用关注代理类的构建过程，只需要关注需要实现的额外的功能。</p></li></ol><h4 id="cglib-动态代理" tabindex="-1"><a class="header-anchor" href="#cglib-动态代理" aria-hidden="true">#</a> CGLib 动态代理</h4><ol><li><p>什么是 CGLib</p><figure><img src="`+x+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>cglib弥补了jdk动态代理的不足，jdk动态代理只能为接口创建代理，而cglib非常强大，不管是接口还是类，都可以使用cglib来创建代理</p><p>cglib创建代理的过程，相当于创建了一个新的类，可以通过cglib来配置这个新的类需要实现的接口，以及需要继承的父类</p><p>cglib可以为类创建代理，但是这个类不能是final类型的，cglib为类创建代理的过程，实际上为通过继承来实现的，相当于给需要被代理的类创建了一个子类，然后会重写父类中的方法，来进行增强，继承的特性大家应该都知道，final修饰的类是不能被继承的，final修饰的方法不能被重写，static修饰的方法也不能被重写，private修饰的方法也不能被子类重写，而其他类型的方法都可以被子类重写，被重写的这些方法可以通过cglib进行拦截增强</p><p>使用CGLib的方式有两种，一种是直接引入相关的jar或者坐标，另一种是结合Spring使用，org.springframework.cglib。</p><p>使用方法：</p><p>实现MethodInterceptor接口，在intercept方法中实现代理内容（如日志输出）</p><p>使用Enhancer及委托类生成代理类</p><p>使用代理类执行函数，就会动态调用intercept方法的实现</p></li><li><p>代码示例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 示例一</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>cglib<span class="token operator">/</span>cglib <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>cglib<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>cglib<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">3.2</span><span class="token number">.12</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span> 



<span class="token doc-comment comment">/**
 * 日志动态代理：cglib实现
 **/</span>
publicclass <span class="token class-name">CglibLogProxyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; cglib dynamic proxy log begin &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; cglib dynamic proxy log begin &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 动态创建代理
     *
     * <span class="token keyword">@param</span> <span class="token parameter">cls</span> 委托类
     * <span class="token keyword">@return</span>
     */</span>
    publicstatic <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> cls<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CglibLogProxyInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">testLogProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CglibService</span> proxy <span class="token operator">=</span> <span class="token class-name">CglibLogProxyInterceptor</span><span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token class-name">CglibService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    proxy<span class="token punctuation">.</span><span class="token function">doAction1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;############&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    proxy<span class="token punctuation">.</span><span class="token function">doAction2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 示例二</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProxyByGclib</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>
    
    <span class="token comment">//维护目标对象</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>
    

    <span class="token keyword">public</span> <span class="token class-name">MyProxyByGclib</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//1. 实例化工具类</span>
        <span class="token class-name">Enhancer</span> en <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2. 设置父类对象</span>
        en<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3. 设置回调函数</span>
        en<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//4. 创建子类，也就是代理对象</span>
        <span class="token keyword">return</span> en<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> arg0<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> arg3<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Begin Transaction&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//执行目标对象的方法</span>
        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;End Transaction&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//目标对象</span>
        <span class="token class-name">MyServiceImpl</span> myService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//生成代理对象</span>
        <span class="token class-name">MyServiceImpl</span> myProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyServiceImpl</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">MyProxyByGclib</span><span class="token punctuation">(</span>myService<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用对象方法</span>
        myProxy<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myProxy<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><figure><img src="`+w+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+B+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>CGLib动态代理使用注意事项： cglib弥补了jdk动态代理的不足，jdk动态代理只能为接口创建代理，而cglib非常强大，不管是接口还是类，都可以使用cglib来创建代理 cglib创建代理的过程，相当于创建了一个新的类，可以通过cglib来配置这个新的类需要实现的接口，以及需要继承的父类 cglib可以为类创建代理，但是这个类不能是final类型的，cglib为类创建代理的过程，实际上为通过继承来实现的，相当于给需要被代理的类创建了一个子类，然后会重写父类中的方法，来进行增强，继承的特性大家应该都知道，final修饰的类是不能被继承的，final修饰的方法不能被重写，static修饰的方法也不能被重写，private修饰的方法也不能被子类重写，而其他类型的方法都可以被子类重写，被重写的这些方法可以通过cglib进行拦截增强</p><figure><img src="'+A+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+_+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><figure><img src="'+C+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理 如果目标对象实现了接口，且强制使用cglib代理，则会使用cglib代理</p><p>AOP是指面向切面编程，是计算机科学中的一种程序设计思想，旨在将<code>交叉切入关注点</code>与作为业务主体的<code>核心关注点</code>进行分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通告（Advice）机制，能够对被声明为“点切入”（Pointcut）的代码块进行统一管理与装饰，比如说：“对所有方法名以set*开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。</p><p>它有以下几个概念：</p>',14),on=n("li",null,"连接点 Joinpoint： 在程序的整个执行流程中，可以织入切面的位置。方法的执行前后，异常抛出之后等位置。",-1),ln=n("li",null,"切点 Pointcut： 在程序执行流程中，真正织入切面的方法。（一个切点对应多个连接点）",-1),cn={href:"/Before",target:"_blank",rel:"noopener noreferrer"},rn={href:"/AfterReturning",target:"_blank",rel:"noopener noreferrer"},un={href:"/Around",target:"_blank",rel:"noopener noreferrer"},dn={href:"/AfterThrowing",target:"_blank",rel:"noopener noreferrer"},kn={href:"/After",target:"_blank",rel:"noopener noreferrer"},gn=n("li",null,[a("执行顺序： "),n("ul",null,[n("li",null,"Spring版本5.3.x以前： 前置通知 > 目标操作 > 后置通知 > 返回通知或异常通知"),n("li",null,"Spring版本5.3.x以后： 前置通知 > 目标操作 > 返回通知或异常通知 > 后置通知")])],-1),vn=n("li",null,"切面 Aspect ： 切点 + 通知就是切面。",-1),mn=n("li",null,"织入 Weaving： 把通知应用到目标对象上的过程。",-1),bn=n("li",null,"代理对象 Proxy： 一个目标对象被织入通知后产生的新对象。",-1),hn=n("li",null,"目标对象 Target： 被织入通知的对象。",-1),fn=e('<figure><img src="'+J+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li>用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限</li><li>在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。 <ul><li>例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello</li></ul></li><li>在包名的部分，使用“*..”表示包名任意、包的层次深度任意</li><li>在类名的部分，类名部分整体用*号代替，表示类名任意</li><li>在类名的部分，可以使用*号代替类名的一部分 <ul><li>例如：*Service匹配所有名称以Service结尾的类或接口</li></ul></li><li>在方法名部分，可以使用*号表示方法名任意</li><li>在方法名部分，可以使用*号代替方法名的一部分 <ul><li>例如：*Operation匹配所有方法名以Operation结尾的方法</li></ul></li><li>在方法参数列表部分，使用(..)表示参数列表任意</li><li>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</li><li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的 <ul><li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li></ul></li><li>在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符 <ul><li>例如：execution(public int ..Service.<em>(.., int)) 正确例如：execution(</em> int ..Service.*(.., int)) 错误</li></ul></li></ul><div class="language-log line-numbers-mode" data-ext="log"><pre class="language-log"><code>连接点表示方法的调用过程，内部包含了方法调用过程中的所有信息，比如被调用的方法、目标、代理对象、执行拦截器链等信息。

上面定义都是一些接口，最终有<span class="token number">2</span>个实现。

ReflectiveMethodInvocation
当代理对象是采用jdk动态代理创建的，通过代理对象来访问目标对象的方法的时，最终过程是由ReflectiveMethodInvocation来处理的，内部会通过递归调用方法拦截器，最终会调用到目标方法。

CglibMethodInvocation
功能和上面的类似，当代理对象是采用cglib创建的，通过代理对象来访问目标对象的方法的时，最终过程是由CglibMethodInvocation来处理的，内部会通过递归调用方法拦截器，最终会调用到目标方法。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="asceptj-动态代理" tabindex="-1"><a class="header-anchor" href="#asceptj-动态代理" aria-hidden="true">#</a> AsceptJ 动态代理</h4><ol><li><p>使用示例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
<span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
<span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>aop<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>


<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">WebLog</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebLogAspect</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Logger</span> logger         <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">WebLogAspect</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 以自定义 @WebLog 注解为切点， 这里事实上是做了简化的，原来的应该是在下面的 doBefore() 方法上添加 
     *    @Before(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;) 注解的，但是考虑到每个通知上都需要这样写，
     *    因此，干脆把这个 切点表达式 标记成一个方法webLog()，下面的每一个通知只需要写成 webLog() 方法即可。
     **/</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">webLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 在切点之前织入
     */</span>
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">&quot;webLog()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">// 开始打印请求日志</span>
        <span class="token class-name">ServletRequestAttributes</span> attributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span> <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> attributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印请求相关参数</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;========================================== Start ==========================================&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印请求 url</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;URL            : {}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印 Http method</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;HTTP Method    : {}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印调用 controller 的全路径以及执行方法</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Class Method   : {}.{}&quot;</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaringTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印请求的 IP</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;IP             : {}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印请求入参</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Request Args   : {}&quot;</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 在切点之后织入
     * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">Throwable</span></span>
     */</span>
    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">&quot;webLog()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">// 结束后打个分隔线，方便查看</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;=========================================== End ===========================================&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 环绕
     */</span>
    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;webLog()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> proceedingJoinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">//开始时间</span>
        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> proceedingJoinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印出参</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Response Args  : {}&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行耗时</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Time-Consuming : {} ms&quot;</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>


<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebLog</span><span class="token punctuation">(</span>desc <span class="token operator">=</span> <span class="token string">&quot;这是一个欢迎接口&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">return</span> <span class="token string">&quot;Hello &quot;</span><span class="token operator">+</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><ul><li>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 <ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul></li><li>使用@Order注解可以控制切面的优先级： <ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul></li></ul><h3 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h3><blockquote><ol><li>应用的思路： 一个是为了给某类行为添加共同逻辑，一个是利用代理机制主动执行某些行为；</li><li>Spring 中由 AOP 实现的功能有哪些</li><li>实际业务开发过程中使用 AOP 的业务场景</li></ol></blockquote><div class="language-log line-numbers-mode" data-ext="log"><pre class="language-log"><code>记录跟踪：对函数执行前后统一输出日志跟踪执行情况
计时：统一对函数执行用时进行计算（前后时间记录之差）
权限校验：统一在函数执行前进行权限校验
事务：统一对函数作为事务处理
异常处理：对某一类函数执行输出的异常进行统一捕获处理
动态切换数据源：多数据源切换或动态添加数据源

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2" aria-hidden="true">#</a> 总结</h3><ol><li>代码程序的扩展性问题</li><li>代理模式是GoF23里面的一种，属于结构性设计模式；旨在通过构建一个代理对象来完成对目标对象的增强，目的就是为了解耦；主要有三个角色的类： 代理类、目标类和公共类</li><li>我们知道 Java 程序的运行过程可大概分为编译期和运行期，因此根据代理类的构建时机来划分，把代理模式划分为两种： 静态代理和动态代理；</li><li>静态代理： 在编译期即可生成代理类的字节码文件；基于JDK API来实现，对原有代码的侵入性小、实现过程简单，但扩展时需要同时修改目标类和代理类，具有一定的耦合性；</li><li>动态代理： 运行期动态确定代理类；多是基于框架来实现，如jdk反射包下的proxy框架、第三方的CGLib、JavaAssist等，动态代理的优势在于把代理关系或代理对象延迟到运行期；</li><li>JDK动态代理模式，这种方式实际上是利用了反射包下面的proxy和InvocationHandler接口，为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例，最后由这个代理实例来完成方法增强；JDK动态代理通过延迟代理关系或代理对象构造过程到运行期，解决了静态代理在扩展时需要同时修改目标类和代理类的扩展性问题，实现了进一步解耦的目的，但是 jdk动态代理只能为接口创建代理，还是具有一定的局限性；</li><li>CGLib动态代理模式，是基于CGLib来完成的，CGLib是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。基于同样的道理，Enhancer也不能对final类进行代理操作；由于CGLib是对字节码做了增强，因此其性能也比JDK动态代理高；</li><li>代理模式逐渐演化出AOP，即面向切面编程的设计思想；AOP包括很多概念，如连接点、切入点、通知（或称增强）、切面等；</li><li>Spring框架中除支持JDK动态代理模式、CGLib动态代理模式外，还支持AspectJ代理模式；其中JDK动态代理模式、CGLib动态代理模式是Spring AOP支持的，而AspectJ代理模式是Spring框架中AspectJ包所支持的；</li><li>Spring AOP代理模式 与 AspectJ代理模式 的区别如下： 【重要区别： 一个是为了给某类行为添加共同逻辑，一个是利用代理机制执行某些行为】</li><li>Spring中的哪些功能是基于AOP来完成的：事务、异步、缓存等；</li><li>应用AOP的实际业务场景有哪些： 日志、权限校验、执行时间统计、异常处理、动态数据源切换等；</li></ol><ul><li>动态代理分为JDK动态代理和cglib动态代理</li><li>当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理</li><li>JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口</li><li>cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类</li><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）。</li><li>cglib：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</li><li>AspectJ：是AOP思想的一种实现。本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</li></ul><div class="hint-container tip"><p class="hint-container-title">向上转型、向下转型</p><ul><li>向上转型</li></ul><p>向上转型： 类似于 Pet myPet = new Dog(); mypet.speech(); 的方式，就是向上转型，特点是父类对象持有子类对象的引用，即属于父类对象的 myPet 持有子类 Dog 的一个引用。这种方式属于“动态链接”的方式，即被调用的方法类型，在编译期无法确定，只能在运行期才能被确定下来，如编译期并不能确定 mypet 调用的 speech() 方法到底是Pet类中的方法还是Dog类中的方法，只能等到运行期时才能确定下来是Dog类中方法；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Pet</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pet</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
pets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//多态引用</span>
pets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setNickname</span><span class="token punctuation">(</span><span class="token string">&quot;小白&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

pets<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//多态引用</span>
pets<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setNickname</span><span class="token punctuation">(</span><span class="token string">&quot;雪球&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>pets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Dog</span> dog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span> pets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">watchHouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> pets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        cat<span class="token punctuation">.</span><span class="token function">catchMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>向下转型</p><p>类似于 Dog dog = (Dog) pets[i]; dog.watchHouse(); 的方式，就是向下转型， pets 本身属于Pet类，但是子类的对象持有了一个父类对象的引用。这种方式也属于“动态链接”的方式。</p></li><li><p>总结</p><ul><li>向上转型： 父类 父类对象 = new 子类 ，编译期处理的类型是 父类 的类型，运行期是 子类 的类型，因此编译期不能调用 独属于 子类的方法和变量，这个过程是JVM自动完成的；</li><li>向下转型： 子类 子类对象 = new 父类 ，编译期处理的类型是 子类 的类型，此时当然可以调用 独属于 子类的方法了，运行期仍然是 父类 的类型。但由于并不是所有的向下转型都是正确的，因此在向下转型的时候有可能会抛出 ClassCastException 异常，因此需要使用 instanceof 来判断“是否属于子类类型” 。</li><li><code>静态链接（或早起绑定）</code>：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。</li><li><code>动态链接（或晚期绑定）</code>：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。</li></ul></li></ul></div><h3 id="spring中aop的相关概念" tabindex="-1"><a class="header-anchor" href="#spring中aop的相关概念" aria-hidden="true">#</a> Spring中AOP的相关概念</h3><ol><li>面向切面编程，是一种软件设计思想，是面向对象编程的一种补充和完善；</li><li>它通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态地统一添加额外功能；</li><li>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率；</li></ol><h4 id="切面-aspect" tabindex="-1"><a class="header-anchor" href="#切面-aspect" aria-hidden="true">#</a> 切面（Aspect）</h4><p>通知（Advice）和切入点（Pointcut）的组合。切面来定义在哪些地方（Pointcut）执行什么操作（Advice）。</p><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级：</p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><h4 id="目标对象-target" tabindex="-1"><a class="header-anchor" href="#目标对象-target" aria-hidden="true">#</a> 目标对象(target)</h4><p>目标对象指将要被增强的对象，即包含主业务逻辑的类对象。</p><h4 id="代理对象-proxy" tabindex="-1"><a class="header-anchor" href="#代理对象-proxy" aria-hidden="true">#</a> 代理对象(Proxy)</h4><p>AOP中会通过代理的方式，对目标对象生成一个代理对象，代理对象中会加入需要增强功能，通过代理对象来间接的方式目标对象，起到增强目标对象的效果。</p><h4 id="连接点-joinpoint" tabindex="-1"><a class="header-anchor" href="#连接点-joinpoint" aria-hidden="true">#</a> 连接点(JoinPoint)</h4><p>连接点，程序运行的某一个点，比如执行某个方法，在Spring AOP中Join Point总是表示一个方法的执行 <strong>通俗点理解：连接点表示方法的调用过程，内部包含了方法调用过程中的所有信息，比如被调用的方法、目标、代理对象、执行拦截器链等信息。</strong></p><figure><img src="`+j+'" alt="1726528805453" tabindex="0" loading="lazy"><figcaption>1726528805453</figcaption></figure><p>上面定义都是一些接口，最终有2个实现。</p><h4 id="reflectivemethodinvocation" tabindex="-1"><a class="header-anchor" href="#reflectivemethodinvocation" aria-hidden="true">#</a> ReflectiveMethodInvocation</h4><p>当代理对象是采用jdk动态代理创建的，通过代理对象来访问目标对象的方法的时，最终过程是由ReflectiveMethodInvocation来处理的，内部会通过递归调用方法拦截器，最终会调用到目标方法。</p><h4 id="cglibmethodinvocation" tabindex="-1"><a class="header-anchor" href="#cglibmethodinvocation" aria-hidden="true">#</a> CglibMethodInvocation</h4><p>功能和上面的类似，当代理对象是采用cglib创建的，通过代理对象来访问目标对象的方法的时，最终过程是由CglibMethodInvocation来处理的，内部会通过递归调用方法拦截器，最终会调用到目标方法。</p><h3 id="通知-advice" tabindex="-1"><a class="header-anchor" href="#通知-advice" aria-hidden="true">#</a> 通知(Advice)</h3><p>需要在目标对象中增强的功能，如上面说的：业务方法前验证用户的功能、方法执行之后打印方法的执行日志。 通知中有2个重要的信息**： 方法的什么地方**，<strong>执行什么操作</strong>，这2个信息通过通知来指定。 方法的什么地方？之前、之后、包裹目标方法、方法抛出异常后等。 如： 在方法执行之前验证用户是否有效。 在方法执行之后，打印方法的执行耗时。 在方法抛出异常后，记录异常信息发送到mq。</p><figure><img src="'+I+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="通知包装器" tabindex="-1"><a class="header-anchor" href="#通知包装器" aria-hidden="true">#</a> 通知包装器</h4><p><strong>Aop中所有的Advice最终都会转换为MethodInterceptor类型的，组成一个方法调用链，然后执行。</strong></p><p><strong>负责将各种非MethodInterceptor类型的通知(Advice)包装为MethodInterceptor类型。</strong></p><h4 id="methodbeforeadviceinterceptor类" tabindex="-1"><a class="header-anchor" href="#methodbeforeadviceinterceptor类" aria-hidden="true">#</a> MethodBeforeAdviceInterceptor类</h4><p>这个类实现了MethodInterceptor接口，负责将MethodBeforeAdvice方法前置通知包装为MethodInterceptor类型，创建这个类型的对象的时候需要传递一个MethodBeforeAdvice类型的参数，重点是invoke方法</p><h4 id="afterreturningadviceinterceptor类" tabindex="-1"><a class="header-anchor" href="#afterreturningadviceinterceptor类" aria-hidden="true">#</a> AfterReturningAdviceInterceptor类</h4><p>这个类实现了MethodInterceptor接口，负责将AfterReturningAdvice方法后置通知包装为MethodInterceptor类型，创建这个类型的对象的时候需要传递一个AfterReturningAdvice类型的参数，重点是invoke方法</p><h4 id="throwsadviceinterceptor类" tabindex="-1"><a class="header-anchor" href="#throwsadviceinterceptor类" aria-hidden="true">#</a> ThrowsAdviceInterceptor类</h4><p>这个类实现了MethodInterceptor接口，负责将ThrowsAdvice异常通知包装为MethodInterceptor类型，创建这个类型的对象的时候需要传递一个Object类型的参数，通常这个参数是ThrowsAdvice类型的，重点是invoke方法</p><p>各种通知的执行顺序：</p><ul><li>Spring版本5.3.x以前： <ul><li>前置通知</li><li>目标操作</li><li>后置通知</li><li>返回通知或异常通知</li></ul></li><li>Spring版本5.3.x以后： <ul><li>前置通知</li><li>目标操作</li><li>返回通知或异常通知</li><li>后置通知</li></ul></li></ul><h3 id="切入点-pointcut" tabindex="-1"><a class="header-anchor" href="#切入点-pointcut" aria-hidden="true">#</a> 切入点(Pointcut )</h3><p>用来指定需要将通知使用到哪些地方，比如需要用在哪些类的哪些方法上，切入点就是做这个配置的。</p><figure><img src="'+D+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><blockquote><p>连接点 和 切入点的区别</p><ol><li>切入点告诉 Spring 框架，增强代码逻辑入口位置；就是面向切面编程时，增强代码插入核心业务代码的位置，这个位置只是把增强代码和核心业务代码联系起来，而我们很自然的想到，想要把我们的增强代码插入到核心代码中，就需要知道插入的位置，而插入的位置就是哪些类的哪些方法；</li><li>连接点告诉 Spring 框架，增强代码具体执行的位置；面向切面编程时，我们可能想要在一个方法执行前后执行某些增强代码，但是有时候需要在方法内部执行某些操作，比如在传入参数是 XX 时执行增强业务、执行到方法名为 XX 时执行增强业务等，此时就需要知道方法的一些属性，如方法的参数、方法名、方法的代理对象等，因此在 JoinPoint 接口的两个重要实现类中均实现了获取方法的参数、方法名、方法的代理对象的相关方法；</li></ol></blockquote><h3 id="顾问-advisor" tabindex="-1"><a class="header-anchor" href="#顾问-advisor" aria-hidden="true">#</a> 顾问（Advisor)</h3><p>Advisor 其实它就是 Pointcut 与 Advice 的组合，Advice 是要增强的逻辑，而增强的逻辑要在什么地方执行是通过Pointcut来指定的，所以 Advice 必需与 Pointcut 组合在一起，这就诞生了 Advisor 这个类，spring Aop中提供了一个Advisor接口将Pointcut 与 Advice 的组合起来。 Advisor有好几个称呼：顾问、通知器。 其中这4个：连接点(JoinPoint)、通知(advise)、切入点(pointcut)、顾问（advisor)，在spring中都定义了接口和类来表示这些对象，下面我们一个个来看一下。</p><p>通知定义了需要做什么，切入点定义了在哪些类的哪些方法中执行通知，那么需要将他们2个组合起来才有效啊。 顾问（Advisor）就是做这个事情的。 在spring aop中，你可以将advisor理解为切面，切面中通常有2个关键信息：</p><ol><li>需要增强的目标方法列表，这个通过切入点(Pointcut)来指定</li><li>需要在目标方法中增强的逻辑，这个通过(Advice)通知来指定</li></ol><figure><img src="'+q+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="defaultpointcutadvisor类" tabindex="-1"><a class="header-anchor" href="#defaultpointcutadvisor类" aria-hidden="true">#</a> DefaultPointcutAdvisor类</h4><p>PointcutAdvisor的默认实现，这是最常用的Advisor实现，它可以用于任何Pointcut和Advice类型，代码相当简单，里面定义了2个属性：pointcut和advisor，由使用者指定。</p><h4 id="introductionadvisor接口" tabindex="-1"><a class="header-anchor" href="#introductionadvisor接口" aria-hidden="true">#</a> IntroductionAdvisor接口</h4><p>这个接口，估计大家比较陌生，干什么的呢？ <strong>一个Java类，没有实现A接口，在不修改Java类的情况下，使其具备A接口的功能。可以通过IntroductionAdvisor给目标类引入更多接口的功能，这个功能是不是非常牛逼。</strong></p><p><strong>我们知道 Spring AOP 的原理是</strong>： 主要就是使用jdk动态代理和cglib代理来创建代理对象，通过代理对象来访问目标对象，而代理对象中融入了增强的代码，最终起到对目标对象增强的效果。 所以，我们把 SpringAOP 的使用就可以分为两个步骤：</p><ol><li>由代理逻辑生成代理对象，也就是 Spring 框架帮我们生成代理对象；</li><li>我们调用目标对象的逻辑转化为调用代理对象的逻辑，实现增强的效果；</li></ol><p>第一步骤中，Spring 框架帮我们生成代理对象，就涉及到对 Spring 框架生成对象的这个过程进行一些配置，【把 Spring 帮我们生成代理对象 的过程看作一个组件，那么必然有其可配置的相关行为、属性等】。</p><h4 id="配置-spring-框架中的代理生成逻辑" tabindex="-1"><a class="header-anchor" href="#配置-spring-框架中的代理生成逻辑" aria-hidden="true">#</a> 配置 Spring 框架中的代理生成逻辑</h4><figure><img src="'+P+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li><p>TargetClassAware接口</p><p>比较简单的一个接口，定义了一个方法，用来获取目标对象类型。 所谓目标对象：就是被代理对象，</p></li><li><p>ProxyConfig类</p><p>这个类比较关键了，代理配置类，内部包含了创建代理时需要配置的各种参数。</p></li><li><p>Advised接口</p><p>这个接口中定义了操作Aop代理配置的各种方法（比如指定被代理的目标对象、添加通知、添加顾问等等）。 所有由spring aop创建的代理对象默认都会实现这个接口。</p></li><li><p>AdvisedSupport类</p><p>这个类是个重点，AOP代理配置管理器的基类，继承了ProxyConfig并且实现了Advised接口，创建aop代理之前，所有需要配置的信息都是通过这个类来操作的。 比如：设置是否为目标类创建代理、设置目标对象、配置通知列表等等。</p><figure><img src="'+T+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li><li><p>AopProxyFactory接口</p><p>通过名称就可以看出来，是一个工厂，负责创建AopProxy，使用的是简单工厂模式。 接口中定义了一个方法，会根据Aop的配置信息AdvisedSupport来获取AopProxy对象，主要是判断采用cglib的方式还是采用jdk动态代理的方式。</p></li><li><p>DefaultAopProxyFactory类</p><p>AopProxyFactory接口的默认实现，</p></li><li><p>AopProxy接口</p><p>这个接口定义了一个方法，用来创建最终的代理对象，这个接口有2个实现类</p><ul><li>CglibAopProxy：采用cglib的方式创建代理对象</li><li>JkdDynamicAopProxy：采用jdk动态代理的方式创建代理对象</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 创建AopProxy使用了简单工厂模式</span>
<span class="token class-name">AopProxyFactory</span> aopProxyFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAopProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//通过AopProxy工厂获取AopProxy对象</span>
<span class="token class-name">AopProxy</span> aopProxy <span class="token operator">=</span> aopProxyFactory<span class="token punctuation">.</span><span class="token function">createAopProxy</span><span class="token punctuation">(</span>advisedSupport<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="_5-web" tabindex="-1"><a class="header-anchor" href="#_5-web" aria-hidden="true">#</a> 5. Web</h2><blockquote><p>MVC 实现原理 扩展应用： 内容协商、过滤器、shiro、跨域等 WebFlux</p></blockquote><ol><li>Serverlet 机制和原理</li><li>MVC 原理</li><li>SpringMVC 原理</li></ol><figure><img src="`+E+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li>客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</li><li>DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</li><li>DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</li><li>HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。</li><li>DispatcherServlet将模型数据填充到视图中</li><li>DispatcherServlet将结果响应给客户端</li></ol><p>加入了 <strong>@ResponseBody</strong>这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：</p><figure><img src="'+M+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li>客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet</li><li>DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理</li><li>DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</li><li>Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理</li><li>HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程：5.1. 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例5.2.使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中5. 在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化</li><li>执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理</li></ol><p>那么接下来就简单介绍一下 DispatcherServlet 和九大组件（按使用顺序排序的）：</p><table><thead><tr><th><strong>组件</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>DispatcherServlet</td><td>Spring MVC 的核心组件，是请求的入口，负责协调各个组件工作</td></tr><tr><td>MultipartResolver</td><td>内容类型( Content-Type )为 multipart/* 的请求的解析器，例如解析处理文件上传的请求，便于获取参数信息以及上传的文件</td></tr><tr><td>HandlerMapping</td><td>请求的处理器匹配器，负责为请求找到合适的 HandlerExecutionChain 处理器执行链，包含处理器（handler）和拦截器们（interceptors）</td></tr><tr><td>HandlerAdapter</td><td>处理器的适配器。因为处理器 handler 的类型是 Object 类型，需要有一个调用者来实现 handler 是怎么被执行。Spring 中的处理器的实现多变，比如用户处理器可以实现 Controller 接口、HttpRequestHandler 接口，也可以用 @RequestMapping 注解将方法作为一个处理器等，这就导致 Spring MVC 无法直接执行这个处理器。所以这里需要一个处理器适配器，由它去执行处理器</td></tr><tr><td>HandlerExceptionResolver</td><td>处理器异常解析器，将处理器（ handler ）执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果</td></tr><tr><td>RequestToViewNameTranslator</td><td>视图名称转换器，用于解析出请求的默认视图名</td></tr><tr><td>LocaleResolver</td><td>本地化（国际化）解析器，提供国际化支持</td></tr><tr><td>ThemeResolver</td><td>主题解析器，提供可设置应用整体样式风格的支持</td></tr><tr><td>ViewResolver</td><td>视图解析器，根据视图名和国际化，获得最终的视图 View 对象</td></tr><tr><td>FlashMapManager</td><td>FlashMap 管理器，负责重定向时，保存参数至临时存储（默认 Session）</td></tr></tbody></table><p>Spring MVC 对各个组件的职责划分的比较清晰。DispatcherServlet 负责协调，其他组件则各自做分内之事，互不干扰。</p><h3 id="springmvc-拦截器如何使用" tabindex="-1"><a class="header-anchor" href="#springmvc-拦截器如何使用" aria-hidden="true">#</a> SpringMVC 拦截器如何使用？</h3><p>Spring的处理程序映射机制包括处理程序拦截器，当你希望将特定功能应用于某些请求时，例如，检查用户主题时，这些拦截器非常有用。拦截器必须实现org.springframework.web.servlet包的HandlerInterceptor。此接口定义了三种方法：</p><ul><li>preHandle：在执行实际处理程序之前调用。</li><li>postHandle：在执行完实际程序之后调用。</li><li>afterCompletion：在完成请求后调用。</li></ul><h3 id="常见注解" tabindex="-1"><a class="header-anchor" href="#常见注解" aria-hidden="true">#</a> 常见注解</h3><p>@Controller @RequestMapping @RestController @GetMapping @RequestParam @PathVariable @ResponseBody</p><h3 id="rest" tabindex="-1"><a class="header-anchor" href="#rest" aria-hidden="true">#</a> REST</h3><p>什么是 REST 有哪些操作？ 是无状态的吗？ 安全嘛？</p><h3 id="基于-servlet-开发的示例" tabindex="-1"><a class="header-anchor" href="#基于-servlet-开发的示例" aria-hidden="true">#</a> 基于 Servlet 开发的示例</h3>',85),Sn=e(`<li><p>pom 文件引入依赖，需要注意的是，package 属性要设置成 war 包，为了节省篇幅，这里没有列出 pom 完整的信息：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>war<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-lang3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.72<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在 src/main 下面新建文件夹 webapp/WEB-INF，然后在 WEB-INF 下面新建一个 web.xml 文件：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
 <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://java.sun.com/xml/ns/j2ee<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>javaee</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">&quot;</span></span>
 <span class="token attr-name"><span class="token namespace">xmlns:</span>web</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">&quot;</span></span>
 <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd<span class="token punctuation">&quot;</span></span>
 <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2.4<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">&gt;</span></span>Lonely Wolf Web Application<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>helloServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>com.lonely.wolf.mini.spring.servlet.HelloServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>helloServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/hello/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>新建一个 HelloServlet 类继承 HttpServlet：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 原始Servlet接口编写，一般需要实现GET和POST方法，其他方法可以视具体情况选择性继承
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">&quot;text/html;charset=utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;Hello：&quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>执行 maven 打包命令，确认成功打包成 war 包：</p><figure><img src="`+O+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li><li><p>RUN--&gt;Edit Configurations，然后点击左上角的 + 号，新建一个 Tomcat Server，如果是第一次配置，默认没有 Tomcat Server 选项，需要点击底部的 xx more items...：</p><figure><img src="'+R+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li><li><p>点击右边的 Deployment，然后按照下图依次点击，最后在弹框内找到上面打包好的 war 包文件：</p><figure><img src="'+L+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li><li><p>选中之后，需要注意的是，下面 Application Context 默认会带上 war 包名，为了方便，我们需要把它删掉，即不用上下文路径，只保留一个根路径 / （当然上下文也可以保留，但是每次请求都要带上这一部分）， 再选择 Apply，点击 OK，即可完成部署：</p><figure><img src="'+F+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure></li>',7),yn={href:"http://localhost:8080/hello?name=%E5%8F%8C%E5%AD%90%E5%AD%A4%E7%8B%BC%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%BE%97%E5%88%B0%E8%BF%94%E5%9B%9E%EF%BC%9AHello%EF%BC%9A%E5%8F%8C%E5%AD%90%E5%AD%A4%E7%8B%BC%E3%80%82",target:"_blank",rel:"noopener noreferrer"},xn=e(`<h3 id="todo" tabindex="-1"><a class="header-anchor" href="#todo" aria-hidden="true">#</a> TODO</h3><div class="language-log line-numbers-mode" data-ext="log"><pre class="language-log"><code>Spring <span class="token number">5.0</span> ： 拥抱反应式编程
到目前为止，无论是普通的form<span class="token operator">-</span>based的MVC，还是Restful风格的Web， 其核心都是Servlet <span class="token operator">!</span>

Web Container 会维护一个线程池， 当Web请求来了以后，从线程池取一个线程来处理，如果这个请求需要访问数据库，网络，那这个线程就得等着， 这就是所谓同步阻塞的模型。

当请求过多，线程池用光以后，连最基本的请求都无法处理了。为了解决这个问题，Java 世界开始呼唤新的IO模式。

<span class="token number">2017</span>年<span class="token number">9</span>月发布的Spring <span class="token number">5.0</span> 开始拥抱新的模型：异步非阻塞， 这就是Spring WebFlux。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h3>`,3),wn={href:"https://canvas.zut.edu.cn/courses/2138/pages/jiang-yi-1-spring-ge-javakuang-jia-15nian-de-yan-hua",target:"_blank",rel:"noopener noreferrer"},Bn={href:"https://blog.51cto.com/u_13929722/3411359",target:"_blank",rel:"noopener noreferrer"},An=e(`<h2 id="_6-事务" tabindex="-1"><a class="header-anchor" href="#_6-事务" aria-hidden="true">#</a> 6. 事务</h2><blockquote><p>事务特性 Spring 实现事务的两种编程模型 Spring 中事务的相关属性【传播机制、隔离级别、超时控制、回滚策略】 事务失效原因 长事务概念、最佳实践 <strong>事务的原理</strong></p></blockquote><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><p>满足 ACID 特性的一组数据看操作序列即可称为事务。下面是事务特性：</p><p><strong>A：原子性(Atomicity)</strong> 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 <strong>C：一致性(Consistency)</strong> 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。 如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。 如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。 <strong>I：隔离性(Isolation)</strong> 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。 <strong>D：持久性(Durability)</strong> 指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p><h3 id="spring事务的优点" tabindex="-1"><a class="header-anchor" href="#spring事务的优点" aria-hidden="true">#</a> Spring事务的优点</h3><ul><li>它提供了跨不同事务api（如JTA、JDBC、Hibernate、JPA和JDO）的一致编程模型。</li><li>它为编程事务管理提供了比JTA等许多复杂事务API更简单的API。</li><li>它支持声明式事务管理。</li><li>它很好地集成了Spring的各种数据访问抽象。</li></ul><h3 id="使用示例" tabindex="-1"><a class="header-anchor" href="#使用示例" aria-hidden="true">#</a> 使用示例</h3><h4 id="编程式事务" tabindex="-1"><a class="header-anchor" href="#编程式事务" aria-hidden="true">#</a> 编程式事务</h4><p>事务功能的相关操作全部通过自己编写代码来实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**

1、定义事务属性信息： TransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
2、定义事务管理器： PlatformTransactionManager platformTransactionManager = new DataSourceTransactionManager(dataSource);
3、获取事务： TransactionStatus transactionStatus = platformTransactionManager.getTransaction(transactionDefinition);
4、执行sql操作： 比如上面通过JdbcTemplate的各种方法执行各种sql操作
5、提交事务(platformTransactionManager.commit)或者回滚事务(platformTransactionManager.rollback)

**/</span>


<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">//定义一个数据源</span>
    <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>pool<span class="token punctuation">.</span></span>DataSource</span> dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>pool<span class="token punctuation">.</span></span>DataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dataSource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">&quot;com.mysql.jdbc.Driver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dataSource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://localhost:3306/javacode2018?characterEncoding=UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dataSource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;root123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dataSource<span class="token punctuation">.</span><span class="token function">setInitialSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//定义一个JdbcTemplate，用来方便执行数据库增删改查</span>
    <span class="token class-name">JdbcTemplate</span> jdbcTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcTemplate</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//1.定义事务管理器，给其指定一个数据源（可以把事务管理器想象为一个人，这个人来负责事务的控制操作）</span>
    <span class="token class-name">PlatformTransactionManager</span> platformTransactionManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceTransactionManager</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//2.定义事务属性：TransactionDefinition，TransactionDefinition可以用来配置事务的属性信息，比如事务隔离级别、事务超时时间、事务传播方式、是否是只读事务等等。</span>
    <span class="token class-name">TransactionDefinition</span> transactionDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//3.获取事务：调用platformTransactionManager.getTransaction开启事务操作，得到事务状态(TransactionStatus)对象</span>
    <span class="token class-name">TransactionStatus</span> transactionStatus <span class="token operator">=</span> platformTransactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>transactionDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">//4.执行业务操作，下面就执行2个插入操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;before:&quot;</span> <span class="token operator">+</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">queryForList</span><span class="token punctuation">(</span><span class="token string">&quot;SELECT * from t_user&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jdbcTemplate<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">&quot;insert into t_user (name) values (?)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test1-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jdbcTemplate<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">&quot;insert into t_user (name) values (?)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test1-2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//5.提交事务：platformTransactionManager.commit</span>
        platformTransactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>transactionStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
        <span class="token comment">//6.回滚事务：platformTransactionManager.rollback</span>
        platformTransactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>transactionStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;after:&quot;</span> <span class="token operator">+</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">queryForList</span><span class="token punctuation">(</span><span class="token string">&quot;SELECT * from t_user&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编程式事务管理使用 TransactionTemplate，需要显式执行事务。</p><p>编程式的实现方式存在缺陷：</p><ul><li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li><li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用</li></ul><h4 id="声明式事务" tabindex="-1"><a class="header-anchor" href="#声明式事务" aria-hidden="true">#</a> 声明式事务</h4><p><strong>①添加配置类</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>spring6<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>pool<span class="token punctuation">.</span></span><span class="token class-name">DruidDataSource</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">ComponentScan</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">JdbcTemplate</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span></span><span class="token class-name">DataSourceTransactionManager</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">EnableTransactionManagement</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DataSource</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">&quot;com.atguigu.spring6&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@EnableTransactionManagement</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DataSource</span> <span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">DruidDataSource</span> dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dataSource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;jdbcTemplate&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">JdbcTemplate</span> <span class="token function">getJdbcTemplate</span><span class="token punctuation">(</span><span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">JdbcTemplate</span> jdbcTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jdbcTemplate<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> jdbcTemplate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DataSourceTransactionManager</span> <span class="token function">getDataSourceTransactionManager</span><span class="token punctuation">(</span><span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">DataSourceTransactionManager</span> dataSourceTransactionManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceTransactionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSourceTransactionManager<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dataSourceTransactionManager<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// service中的方法添加注解： @Transactional</span>
<span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buyBook</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> bookId<span class="token punctuation">,</span> <span class="token class-name">Integer</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//查询图书的价格</span>
    <span class="token class-name">Integer</span> price <span class="token operator">=</span> bookDao<span class="token punctuation">.</span><span class="token function">getPriceByBookId</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//更新图书的库存</span>
    bookDao<span class="token punctuation">.</span><span class="token function">updateStock</span><span class="token punctuation">(</span>bookId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//更新用户的余额</span>
    bookDao<span class="token punctuation">.</span><span class="token function">updateBalance</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//System.out.println(1/0);</span>
<span class="token punctuation">}</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>②测试</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>spring6<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">SpringConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>spring6<span class="token punctuation">.</span>controller<span class="token punctuation">.</span></span><span class="token class-name">BookController</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ApplicationContext</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">AnnotationConfigApplicationContext</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span></span><span class="token class-name">SpringJUnitConfig</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TxByAllAnnotationTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTxAllAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">SpringConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BookController</span> accountService <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;bookController&quot;</span><span class="token punctuation">,</span> <span class="token class-name">BookController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        accountService<span class="token punctuation">.</span><span class="token function">buyBook</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</li><li>优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li></ol><ul><li>好处1：提高开发效率</li><li>好处2：消除了冗余的代码</li><li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化</li></ul><h3 id="事务属性" tabindex="-1"><a class="header-anchor" href="#事务属性" aria-hidden="true">#</a> 事务属性</h3><figure><img src="`+H+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="transactional注解标识的位置" tabindex="-1"><a class="header-anchor" href="#transactional注解标识的位置" aria-hidden="true">#</a> @Transactional注解标识的位置</h4><p>@Transactional标识在方法上，则只会影响该方法 @Transactional标识的类上，则会影响类中所有的方法</p><h4 id="只读-——-readonly" tabindex="-1"><a class="header-anchor" href="#只读-——-readonly" aria-hidden="true">#</a> 只读 —— readOnly()</h4><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 @Transactional(readOnly = true)</p><h4 id="超时-——-timeout" tabindex="-1"><a class="header-anchor" href="#超时-——-timeout" aria-hidden="true">#</a> 超时 —— timeout()</h4><p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 //超时时间单位秒 @Transactional(timeout = 3)</p><h4 id="回滚策略" tabindex="-1"><a class="header-anchor" href="#回滚策略" aria-hidden="true">#</a> 回滚策略</h4><p>声明式事务默认只针对运行时异常回滚，编译时异常不回滚。 可以通过@Transactional中相关属性设置回滚策略</p><ul><li>rollbackFor属性：需要设置一个Class类型的对象</li><li>rollbackForClassName属性：需要设置一个字符串类型的全类名</li><li>noRollbackFor属性：需要设置一个Class类型的对象</li><li>rollbackFor属性：需要设置一个字符串类型的全类名</li></ul><p>@Transactional(noRollbackFor = ArithmeticException.class) //@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)</p><p>事务失效就有关于回滚策略的最佳实践：</p><ol><li>在使用事务时，设置捕获具体的异常类型： Spring默认抛出了未检查unchecked异常（继承自 RuntimeException的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。</li><li>在使用事务时，业务代码中不可吞并异常，一定要抛出：业务代码中对异常进行吞并，导致事务代码部分未抛出异常；</li></ol><h4 id="隔离级别-——-isolation" tabindex="-1"><a class="header-anchor" href="#隔离级别-——-isolation" aria-hidden="true">#</a> 隔离级别 —— isolation()</h4><p><strong>①介绍</strong> 数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 隔离级别一共有四种：</p><ul><li>读未提交：READ UNCOMMITTED允许Transaction01读取Transaction02未提交的修改。</li><li>读已提交：READ COMMITTED、要求Transaction01只能读取Transaction02已提交的修改。</li><li>可重复读：REPEATABLE READ确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</li><li>串行化：SERIALIZABLE确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</li></ul><p>各个隔离级别解决并发问题的能力见下表：</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>有</td><td>有</td><td>有</td></tr><tr><td>READ COMMITTED</td><td>无</td><td>有</td><td>有</td></tr><tr><td>REPEATABLE READ</td><td>无</td><td>无</td><td>有</td></tr><tr><td>SERIALIZABLE</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><p>各种数据库产品对事务隔离级别的支持程度：</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>Oracle</strong></th><th><strong>MySQL</strong></th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>×</td><td>√</td></tr><tr><td>READ COMMITTED</td><td>√(默认)</td><td>√</td></tr><tr><td>REPEATABLE READ</td><td>×</td><td>√(默认)</td></tr><tr><td>SERIALIZABLE</td><td>√</td><td>√</td></tr></tbody></table><p><strong>②使用方式</strong><strong>org.springframework.transaction.annotation.Isolation</strong></p><figure><img src="'+z+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="传播行为-——-propagation" tabindex="-1"><a class="header-anchor" href="#传播行为-——-propagation" aria-hidden="true">#</a> 传播行为 —— propagation()</h4><p><strong>①介绍</strong></p><p>什么是事务的传播行为？ 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。 一共有七种传播行为：</p><ul><li>REQUIRED：支持当前事务，如果不存在就新建一个(<strong>默认</strong>)<strong>【没有就新建，有就加入】</strong></li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行**【有就加入，没有就不管了】**</li><li>MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常**【有就加入，没有就抛异常】**</li><li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起**【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】**</li><li>NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务**【不支持事务，存在就挂起】**</li><li>NEVER：以非事务方式运行，如果有事务存在，抛出异常**【不支持事务，存在就抛异常】**</li><li>NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。<strong>【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】</strong></li></ul><p>org.springframework.transaction.annotation.Propagation</p><figure><img src="`+G+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>@Transactional(propagation = Propagation.REQUIRED)</p><h3 id="事务原理" tabindex="-1"><a class="header-anchor" href="#事务原理" aria-hidden="true">#</a> 事务原理</h3><p>就是通过AOP/动态代理。</p><ul><li><strong>在Bean初始化阶段创建代理对象</strong>：Spring容器在初始化每个单例bean的时候，会遍历容器中的所有BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法，在执行AbstractAutoProxyCreator类的postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里会获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</li><li><strong>在执行目标方法时进行事务增强操作</strong>：当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为MethodInterceptor，事务增强对该接口的实现为TransactionInterceptor，类图如下：</li></ul><figure><img src="'+V+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>事务拦截器TransactionInterceptor在invoke方法中，通过调用父类TransactionAspectSupport的invokeWithinTransaction方法进行事务处理，包括开启事务、事务提交、异常回滚。</p><h4 id="事务失效及其原因" tabindex="-1"><a class="header-anchor" href="#事务失效及其原因" aria-hidden="true">#</a> 事务失效及其原因</h4><ol><li>配置不规范导致未生效；</li><li>使用不规范导致未生效； <ol><li>不通过代理对象调用；</li><li>在非 public 方法上使用事务；</li><li>不在同一个线程内使用事务；</li></ol></li><li>异常问题导致未生效： <ol><li>Spring默认抛出了未检查unchecked异常（继承自 RuntimeException的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。</li><li>业务代码中对异常进行吞并，导致事务代码部分未抛出异常；</li></ol></li></ol><h4 id="事务使用不规范" tabindex="-1"><a class="header-anchor" href="#事务使用不规范" aria-hidden="true">#</a> 事务使用不规范</h4><ol><li>未启用spring事务管理功能： @EnableTransactionManagement</li><li>数据源未配置事务管理器： dataSourceTransactionManager.setDataSource(dataSource);</li></ol><h4 id="方法不是public类型的" tabindex="-1"><a class="header-anchor" href="#方法不是public类型的" aria-hidden="true">#</a> 方法不是public类型的</h4><p>如果Transactional注解应用在非 public 修饰的方法上，Transactional将会失效。 是因为在Spring AOP 代理时，TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的intercept方法 或 JdkDynamicAopProxy的invoke方法会间接调用AbstractFallbackTransactionAttributeSource的 <strong>computeTransactionAttribute</strong>方法，获取Transactional 注解的事务配置信息。</p><h4 id="自身调用问题" tabindex="-1"><a class="header-anchor" href="#自身调用问题" aria-hidden="true">#</a> 自身调用问题</h4><blockquote><p>通过外部对象直接调用加了事务注解的方法是失效的，因为事务必须通过代理对象才能生效</p></blockquote><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。 那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p><h4 id="业务和spring事务代码必须在一个线程中" tabindex="-1"><a class="header-anchor" href="#业务和spring事务代码必须在一个线程中" aria-hidden="true">#</a> 业务和spring事务代码必须在一个线程中</h4><h4 id="异常类型错误" tabindex="-1"><a class="header-anchor" href="#异常类型错误" aria-hidden="true">#</a> 异常类型错误</h4><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。</p><h4 id="异常被吞了" tabindex="-1"><a class="header-anchor" href="#异常被吞了" aria-hidden="true">#</a> 异常被吞了</h4><h3 id="长事务" tabindex="-1"><a class="header-anchor" href="#长事务" aria-hidden="true">#</a> 长事务</h3><h3 id="源码分析" tabindex="-1"><a class="header-anchor" href="#源码分析" aria-hidden="true">#</a> 源码分析</h3>',72),_n={href:"http://www.itsoku.com/course/5/129",target:"_blank",rel:"noopener noreferrer"},Cn=n("h4",{id:"总结-3",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#总结-3","aria-hidden":"true"},"#"),a(" 总结")],-1),Jn=n("ol",null,[n("li",null,"根据在框架中使用事务的发展规律来看，最开始要想使用事务，就是程序员自己去编写事务的每一个步骤的控制逻辑，这种方式就是编程式事务；"),n("li",null,"所谓声明式事务就是把本来需要程序员自行编程控制的事务的每一个步骤声明出来，之后通过配置的方式给到Spring，让Spring容器自行管理，程序员只需要关注业务的具体执行；")],-1),jn={href:"https://juejin.cn/post/7106158883055353870#heading-0",target:"_blank",rel:"noopener noreferrer"},In=e('<h2 id="_7-事件机制" tabindex="-1"><a class="header-anchor" href="#_7-事件机制" aria-hidden="true">#</a> 7. 事件机制</h2><blockquote><p>观察者模式 基于 JDK 实现观察者模式 基于 Guaua 实现观察者模式 基于 Spring 实现观察者模式 Spring 中的内建事件类型 基于 SpringBoot 使用事件的示例【数据预热】</p></blockquote><blockquote><p>基于 jdk 的实现方式 基于 Guaua 实现 EventBus Spring 中的事件机制</p></blockquote><h3 id="背景-1" tabindex="-1"><a class="header-anchor" href="#背景-1" aria-hidden="true">#</a> 背景</h3><blockquote><p>现实中的例子，观察者模式的相关概念</p></blockquote><h3 id="现实生活中的例子" tabindex="-1"><a class="header-anchor" href="#现实生活中的例子" aria-hidden="true">#</a> 现实生活中的例子</h3><ol><li>行人等待红绿灯；</li><li>运动员-信号枪；</li><li>公众号订阅模式等；</li></ol><h3 id="aka" tabindex="-1"><a class="header-anchor" href="#aka" aria-hidden="true">#</a> AKA</h3><p>观察者模式，aka：发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents) 模式。</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h3 id="不好的例子" tabindex="-1"><a class="header-anchor" href="#不好的例子" aria-hidden="true">#</a> 不好的例子</h3><blockquote><p>在实际的业务开发中，由于种种原因，事实上我们并不会运用到设计模式，我们大多数都是针对具体的业务来实现，或许根本就不会考虑到扩展性。</p></blockquote><p>比如，我们在提交审核机制里面，我们就可以使用观察者模式。</p><h3 id="基于-jdk-实现方式" tabindex="-1"><a class="header-anchor" href="#基于-jdk-实现方式" aria-hidden="true">#</a> 基于 jdk 实现方式</h3><h3 id="基于-guava-实现-eventbus" tabindex="-1"><a class="header-anchor" href="#基于-guava-实现-eventbus" aria-hidden="true">#</a> 基于 Guava 实现 EventBus</h3><ul><li>同步方式</li><li>异步方式</li></ul><h3 id="spring-中的事件机制" tabindex="-1"><a class="header-anchor" href="#spring-中的事件机制" aria-hidden="true">#</a> Spring 中的事件机制</h3><ol><li>有哪些默认的事件机制</li><li>如何实现事件机制</li><li>基于事件机制可以完成哪些业务场景，即有哪些应用场景</li></ol><h2 id="_8-应用上下文" tabindex="-1"><a class="header-anchor" href="#_8-应用上下文" aria-hidden="true">#</a> 8. 应用上下文</h2><h2 id="_9-资源操作" tabindex="-1"><a class="header-anchor" href="#_9-资源操作" aria-hidden="true">#</a> 9. 资源操作</h2><h2 id="_10-高级特性" tabindex="-1"><a class="header-anchor" href="#_10-高级特性" aria-hidden="true">#</a> 10. 高级特性</h2><blockquote><p>基于 Spring 核心框架，Spring 开发团队实现的扩展性应用，类似于三方包的组件，以便实现开箱即用的效果。</p></blockquote><h2 id="_11-数据校验" tabindex="-1"><a class="header-anchor" href="#_11-数据校验" aria-hidden="true">#</a> 11. 数据校验</h2><blockquote><p>使用过程</p></blockquote><h2 id="_12-国际化" tabindex="-1"><a class="header-anchor" href="#_12-国际化" aria-hidden="true">#</a> 12. 国际化</h2><blockquote><p>使用过程</p></blockquote><h2 id="_13-远程方法调用" tabindex="-1"><a class="header-anchor" href="#_13-远程方法调用" aria-hidden="true">#</a> 13. 远程方法调用</h2><blockquote><p>RestTemplate</p></blockquote>',29),Dn={href:"https://doocs.github.io/source-code-hunter/#/docs/Spring/RMI/Spring-RMI?id=spring-rmi",target:"_blank",rel:"noopener noreferrer"},qn=e('<h2 id="_14-缓存操作" tabindex="-1"><a class="header-anchor" href="#_14-缓存操作" aria-hidden="true">#</a> 14. 缓存操作</h2><blockquote><p>缓存操作</p></blockquote><h2 id="_15-测试" tabindex="-1"><a class="header-anchor" href="#_15-测试" aria-hidden="true">#</a> 15. 测试</h2><blockquote><p>junit 的使用 版本迭代</p></blockquote><h2 id="_16-aot" tabindex="-1"><a class="header-anchor" href="#_16-aot" aria-hidden="true">#</a> 16. AOT</h2><blockquote><p>过程</p></blockquote><h2 id="_17-参考资料" tabindex="-1"><a class="header-anchor" href="#_17-参考资料" aria-hidden="true">#</a> 17. 参考资料</h2>',7),Pn={href:"https://github.com/wuyouzhuguli/SpringAll",target:"_blank",rel:"noopener noreferrer"},Tn={href:"https://doocs.github.io/source-code-hunter/#/",target:"_blank",rel:"noopener noreferrer"},En=n("li",null,"《字节大佬总结的面试题库.pdf》",-1),Mn={href:"https://docs.spring.io/spring-framework/docs/",target:"_blank",rel:"noopener noreferrer"},On={href:"https://github.com/spring-projects/spring-framework/wiki",target:"_blank",rel:"noopener noreferrer"},Rn={href:"https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98",target:"_blank",rel:"noopener noreferrer"},Ln={href:"https://www.cnblogs.com/three-fighter/p/16166891.html",target:"_blank",rel:"noopener noreferrer"},Fn={href:"https://www.cnblogs.com/huangwenjie/p/13945988.html#autoid-h2-0-0-0",target:"_blank",rel:"noopener noreferrer"},Hn={href:"https://dunwu.github.io/spring-tutorial/pages/53aedb/#aop-%E6%A6%82%E5%BF%B5",target:"_blank",rel:"noopener noreferrer"},zn={href:"https://pdai.tech/",target:"_blank",rel:"noopener noreferrer"},Gn={href:"https://github.com/geektime-geekbang/geektime-spring-family/tree/master",target:"_blank",rel:"noopener noreferrer"},Vn={href:"https://www.yuque.com/yguangbxiu/note/cfw98m0tg3k6a38d#QCP35",target:"_blank",rel:"noopener noreferrer"},Wn={href:"http://www.itsoku.com/course/5",target:"_blank",rel:"noopener noreferrer"},Kn={href:"https://www.yuque.com/dujubin/ltckqu/kipzgd",target:"_blank",rel:"noopener noreferrer"},Xn={href:"https://potoyang.gitbook.io/spring-in-action-v5/",target:"_blank",rel:"noopener noreferrer"},Nn={href:"https://zh.wikipedia.org/zh-hans/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC",target:"_blank",rel:"noopener noreferrer"},Un={href:"https://www.cnblogs.com/weidagang2046/archive/2009/12/10/1620587.html",target:"_blank",rel:"noopener noreferrer"},Qn={href:"https://cloud.tencent.com/developer/article/2048526",target:"_blank",rel:"noopener noreferrer"},Zn={href:"https://blog.51cto.com/u_3664660/3214556",target:"_blank",rel:"noopener noreferrer"},$n={href:"https://www.zhihu.com/question/19773379",target:"_blank",rel:"noopener noreferrer"},Yn={href:"https://blog.csdn.net/chenchunlin526/article/details/69939337",target:"_blank",rel:"noopener noreferrer"},na={href:"https://www.1024sky.cn/blog/article/3622",target:"_blank",rel:"noopener noreferrer"},aa={href:"https://cloud.tencent.com/developer/article/2048526",target:"_blank",rel:"noopener noreferrer"},sa={href:"https://www.cnblogs.com/three-fighter/p/16166891.html",target:"_blank",rel:"noopener noreferrer"},ta={href:"https://www.yuque.com/yguangbxiu/note/zxgf4q#rDMTv",target:"_blank",rel:"noopener noreferrer"};function ea(pa,ia){const s=d("ExternalLinkIcon");return r(),u("div",null,[K,n("p",null,[n("a",X,[a("什么是EJB以及和Spring Framework的区别"),t(s)])]),N,n("p",null,[n("a",U,[a("5.0官方文档"),t(s)])]),n("blockquote",null,[n("p",null,[n("a",Q,[a("官方帮助文档"),t(s)])])]),Z,n("p",null,[a("来源： "),n("a",$,[a("https://docs.spring.io/spring-framework/docs/5.0.0.M4/spring-framework-reference/htmlsingle/#dependency-management"),t(s)])]),Y,n("blockquote",null,[n("p",null,[a("Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。 ——来源："),n("a",nn,[a("杨博"),t(s)])])]),an,n("blockquote",null,[n("p",null,[a("代理模式的目的在于构建一个代理类对象，但由于代理类对象构建的时机以及交由谁来负责构建代理类对象的不同，导致代理模式具体的实现方式也略微有所差异。——来自"),n("a",sn,[a("这里"),t(s)])])]),tn,n("p",null,[a("Java动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。Java动态代理实际上通过反射技术，把代理对象和被代理对象(真实对象)的代理关系建立延迟到程序运行之后，动态创建新的代理类去完成对真实对象的代理操作(可以改变原来真实对象的方法行为)，这一点成为了当前主流的AOP框架和延迟加载功能的基础。 ———— 引自"),n("a",en,[a("这里"),t(s)])]),pn,n("ul",null,[on,ln,n("li",null,[a("通知 Advice： 通知又叫增强，就是具体你要织入的代码。 "),n("ul",null,[n("li",null,[a("分类： "),n("ul",null,[n("li",null,[a("前置通知："),n("a",cn,[a("@Before"),t(s)]),a(" 目标方法执行之前的通知")]),n("li",null,[a("后置通知："),n("a",rn,[a("@AfterReturning"),t(s)]),a(" 目标方法执行之后的通知")]),n("li",null,[a("环绕通知："),n("a",un,[a("@Around"),t(s)]),a(" 目标方法之前添加通知，同时目标方法执行之后添加通知。")]),n("li",null,[a("异常通知："),n("a",dn,[a("@AfterThrowing"),t(s)]),a(" 发生异常之后执行的通知")]),n("li",null,[a("最终通知："),n("a",kn,[a("@After"),t(s)]),a(" 放在finally语句块中的通知")])])]),gn])]),vn,mn,bn,hn]),fn,n("ol",null,[Sn,n("li",null,[n("p",null,[a("最后我们在浏览器输入请求路径"),n("a",yn,[a("http://localhost:8080/hello?name=双子孤狼，即可得到返回：Hello：双子孤狼。"),t(s)])])])]),xn,n("ol",null,[n("li",null,[n("a",wn,[a("https://canvas.zut.edu.cn/courses/2138/pages/jiang-yi-1-spring-ge-javakuang-jia-15nian-de-yan-hua"),t(s)])]),n("li",null,[n("a",Bn,[a("https://blog.51cto.com/u_13929722/3411359"),t(s)])])]),An,n("p",null,[n("a",_n,[a("专辑：Spring教程_Spring事务源码解析-Java充电社【公众号：Java充电社】"),t(s)])]),Cn,Jn,n("p",null,[n("a",jn,[a("深入浅出Spring事务的实现原理"),t(s)])]),In,n("p",null,[n("a",Dn,[a("Spring RMI"),t(s)])]),qn,n("p",null,[n("a",Pn,[a("https://github.com/wuyouzhuguli/SpringAll"),t(s)]),a(" 中关于Spring原理部分 "),n("a",Tn,[a("https://doocs.github.io/source-code-hunter/#/"),t(s)]),a(" 中关于Spring原理部分")]),n("ul",null,[n("li",null,[a("理论 "),n("ul",null,[En,n("li",null,[n("a",Mn,[a("Spring官方文档"),t(s)])]),n("li",null,[n("a",On,[a("Spring-Github-Wiki"),t(s)])]),n("li",null,[n("a",Rn,[a("面试小抄- Spring"),t(s)])]),n("li",null,[n("a",Ln,[a("面渣逆袭：Spring三十五问，四万字+五十图详解"),t(s)])]),n("li",null,[n("a",Fn,[a("小马哥讲Spring核心编程思想-笔记"),t(s)])]),n("li",null,[n("a",Hn,[a("SPRING TUTORIAL"),t(s)])]),n("li",null,[n("a",zn,[a("Java全栈知识体系"),t(s)])]),n("li",null,[n("a",Gn,[a("玩转Spring全家桶"),t(s)])])])]),n("li",null,[a("实战 "),n("ul",null,[n("li",null,[n("a",Vn,[a("Spring6(尚硅谷2023)"),t(s)])]),n("li",null,[n("a",Wn,[a("Java-充电社-Spring教程"),t(s)])]),n("li",null,[n("a",Kn,[a("动力节点2022-Spring6"),t(s)]),a(" 密码：mg9b")]),n("li",null,[n("a",Xn,[a("Spring 实战(第 5 版)"),t(s)])])])]),n("li",null,[a("散碎知识点 "),n("ul",null,[n("li",null,[n("a",Nn,[a("控制反转"),t(s)])]),n("li",null,[n("a",Un,[a("Programming.log - a place to keep my thoughts on programming"),t(s)]),a(" : 有助于理解依赖注入中的“依赖”与 UML 类图中的“依赖”之间的关系。")])])]),n("li",null,[a("【"),n("a",Qn,[a("EJB究竟是什么，真的那么神奇吗？？"),t(s)]),a("】")]),n("li",null,[a("【"),n("a",Zn,[a("EJB到底是什么，真的那么神秘吗？"),t(s)]),a("】")]),n("li",null,[n("a",$n,[a("https://www.zhihu.com/question/19773379"),t(s)])]),n("li",null,[n("a",Yn,[a("https://blog.csdn.net/chenchunlin526/article/details/69939337"),t(s)])])]),n("p",null,[n("a",na,[a("对比平台--EJB VS Spring之间的区别"),t(s)]),n("a",aa,[a("EJB究竟是什么，真的那么神奇吗？？"),t(s)])]),n("ol",null,[n("li",null,[n("a",sa,[a("面渣逆袭：Spring三十五问，四万字+五十图详解"),t(s)])]),n("li",null,[n("a",ta,[a("Spring系列课程（1）— 工厂"),t(s)])])])])}const la=c(W,[["render",ea],["__file","spring.html.vue"]]);export{la as default};
