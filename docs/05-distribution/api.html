<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zeanzai.github.io/cs-tips/cs-tips/docs/05-distribution/api.html"><meta property="og:site_name" content="cs-tips"><meta property="og:title" content="API（接口）"><meta property="og:description" content="1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC [ ] TODO ： API架构风格; Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC (https://www.altexsoft.com/blog/soap-vs-rest-v..."><meta property="og:type" content="article"><meta property="og:image" content="https://zeanzai.github.io/cs-tips/cs-tips/"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="API（接口）"><meta property="article:author" content="zeanzai"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"API（接口）","image":["https://zeanzai.github.io/cs-tips/cs-tips/"],"dateModified":null,"author":[{"@type":"Person","name":"zeanzai","url":"https://github.com/zeanzai"}]}</script><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/cs-tips/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><link rel="icon" href="/cs-tips/favicon.ico"><title>API（接口） | cs-tips</title><meta name="description" content="1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC [ ] TODO ： API架构风格; Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC (https://www.altexsoft.com/blog/soap-vs-rest-v...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/cs-tips/assets/style-37e20de6.css" as="style"><link rel="stylesheet" href="/cs-tips/assets/style-37e20de6.css">
    <link rel="modulepreload" href="/cs-tips/assets/app-fa4d50d2.js"><link rel="modulepreload" href="/cs-tips/assets/framework-16b96b76.js"><link rel="modulepreload" href="/cs-tips/assets/api.html-a1fcfa25.js"><link rel="modulepreload" href="/cs-tips/assets/api.html-fccda60d.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/cs-tips/" class="brand"><img class="logo" src="/cs-tips/logo.svg" alt="cs-tips"><!----><span class="site-name hide-in-pad">cs-tips</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/cs-tips/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/cs-tips/docs/01-csbase/" class="nav-link" aria-label="要点提示"><span class="font-icon icon iconfont icon-ability" style=""></span>要点提示<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://github.com/zeanzai/cs-tips/issues" rel="noopener noreferrer" target="_blank" aria-label="问题反馈" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>问题反馈<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/zeanzai/cs-tips" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="title">01-CS基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="title">02-Java编程语言</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-layout" style=""></span><span class="title">03-框架</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-api" style=""></span><span class="title">04-中间件</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-structure" style=""></span><span class="title">05-分布式</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="API（接口）"><!---->API（接口）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-api架构风格对比-soap-vs-rest-vs-graphql-vs-rpc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC"><!---->1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-remote-procedure-call-rpc-唤醒另一个系统的功能" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1. Remote Procedure Call (RPC):唤醒另一个系统的功能"><!---->1.1. Remote Procedure Call (RPC):唤醒另一个系统的功能<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-1-rpc如何工作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.1. RPC如何工作"><!---->1.1.1. RPC如何工作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-2-rpc的优点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.2. RPC的优点"><!---->1.1.2. RPC的优点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-3-rpc的缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.3. RPC的缺点"><!---->1.1.3. RPC的缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-4-rpc使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.4. RPC使用场景"><!---->1.1.4. RPC使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-simple-objects-access-protocol-soap-让数据作为服务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2. Simple Objects Access Protocol (SOAP): 让数据作为服务"><!---->1.2. Simple Objects Access Protocol (SOAP): 让数据作为服务<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-1-soap如何工作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.1. SOAP如何工作"><!---->1.2.1. SOAP如何工作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-2-soap的优点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.2. SOAP的优点"><!---->1.2.2. SOAP的优点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-3-soap的缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.3. SOAP的缺点"><!---->1.2.3. SOAP的缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-4-soap的使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.4. SOAP的使用场景"><!---->1.2.4. SOAP的使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-representational-state-transfer-rest-将数据作为资源" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3. Representational state transfer (REST): 将数据作为资源"><!---->1.3. Representational state transfer (REST): 将数据作为资源<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-1-rest如何工作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.1. REST如何工作"><!---->1.3.1. REST如何工作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-2-rest的优点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.2. REST的优点"><!---->1.3.2. REST的优点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-3-rest的缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.3. REST的缺点"><!---->1.3.3. REST的缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-4-rest的使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.4. REST的使用场景"><!---->1.3.4. REST的使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-graphql-仅请求需要的数据" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4. GraphQL：仅请求需要的数据"><!---->1.4. GraphQL：仅请求需要的数据<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-1-graphql如何工作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.1. GraphQL如何工作"><!---->1.4.1. GraphQL如何工作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-2-graphql-的优点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.2. GraphQL 的优点"><!---->1.4.2. GraphQL 的优点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-3-graphql-的缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.3. GraphQL 的缺点"><!---->1.4.3. GraphQL 的缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-4-graphql的使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.4. GraphQL的使用场景"><!---->1.4.4. GraphQL的使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-5-如何选择api模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5. 如何选择API模式"><!---->1.5. 如何选择API模式<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-接口攻防" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 接口攻防"><!---->2. 接口攻防<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-1-接口攻击" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1. 接口攻击"><!---->2.1. 接口攻击<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-2-接口防御" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2. 接口防御"><!---->2.2. 接口防御<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-3-接口防御之最佳实践" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3. 接口防御之最佳实践"><!---->2.3. 接口防御之最佳实践<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-接口的其他问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 接口的其他问题"><!---->3. 接口的其他问题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-接口重试" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1. 接口重试"><!---->3.1. 接口重试<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-1-实际场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.1. 实际场景"><!---->3.1.1. 实际场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-2-原因分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.2. 原因分析"><!---->3.1.2. 原因分析<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-常见实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3. 常见实现方案"><!---->3.1.3. 常见实现方案<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-1-手动实现重试逻辑" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3.1. 手动实现重试逻辑"><!---->3.1.3.1. 手动实现重试逻辑<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-2-使用spring-retry" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3.2. 使用Spring Retry"><!---->3.1.3.2. 使用Spring Retry<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-3-resilience4j" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3.3. Resilience4j"><!---->3.1.3.3. Resilience4j<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-4-hystrix-已进入维护模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3.4. Hystrix（已进入维护模式）"><!---->3.1.3.4. Hystrix（已进入维护模式）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-5-guava-retryer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3.5. Guava Retryer"><!---->3.1.3.5. Guava Retryer<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-6-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.3.6. 总结"><!---->3.1.3.6. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-4-最佳实践" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1.4. 最佳实践"><!---->3.1.4. 最佳实践<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-防刷" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2. 防刷"><!---->3.2. 防刷<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-1-基于令牌桶算法的限流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.1. 基于令牌桶算法的限流"><!---->3.2.1. 基于令牌桶算法的限流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-2-基于计数器的限流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.2. 基于计数器的限流"><!---->3.2.2. 基于计数器的限流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-3-基于redis的分布式限流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.3. 基于Redis的分布式限流"><!---->3.2.3. 基于Redis的分布式限流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-4-基于熔断器的限流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.4. 基于熔断器的限流"><!---->3.2.4. 基于熔断器的限流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-5-基于nginx的限流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.5. 基于Nginx的限流"><!---->3.2.5. 基于Nginx的限流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-6-基于网关的限流-如spring-cloud-gateway" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.6. 基于网关的限流（如Spring Cloud Gateway）"><!---->3.2.6. 基于网关的限流（如Spring Cloud Gateway）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-7-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2.7. 总结"><!---->3.2.7. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-3-调优" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3. 调优"><!---->3.3. 调优<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_4-todo" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. TODO"><!---->4. TODO<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_5-参考" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 参考"><!---->5. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/cs-tips/docs/05-distribution/distribution.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式系统"><!---->分布式系统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-like" style=""></span><span class="title">06-软件质量管理</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-editor" style=""></span><span class="title">07-工程设计</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->API（接口）</h1><!----><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-api架构风格对比-soap-vs-rest-vs-graphql-vs-rpc" class="router-link-active router-link-exact-active toc-link level2">1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-remote-procedure-call-rpc-唤醒另一个系统的功能" class="router-link-active router-link-exact-active toc-link level3">1.1. Remote Procedure Call (RPC):唤醒另一个系统的功能</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-1-rpc如何工作" class="router-link-active router-link-exact-active toc-link level4">1.1.1. RPC如何工作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-2-rpc的优点" class="router-link-active router-link-exact-active toc-link level4">1.1.2. RPC的优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-3-rpc的缺点" class="router-link-active router-link-exact-active toc-link level4">1.1.3. RPC的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-1-4-rpc使用场景" class="router-link-active router-link-exact-active toc-link level4">1.1.4. RPC使用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-simple-objects-access-protocol-soap-让数据作为服务" class="router-link-active router-link-exact-active toc-link level3">1.2. Simple Objects Access Protocol (SOAP): 让数据作为服务</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-1-soap如何工作" class="router-link-active router-link-exact-active toc-link level4">1.2.1. SOAP如何工作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-2-soap的优点" class="router-link-active router-link-exact-active toc-link level4">1.2.2. SOAP的优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-3-soap的缺点" class="router-link-active router-link-exact-active toc-link level4">1.2.3. SOAP的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-2-4-soap的使用场景" class="router-link-active router-link-exact-active toc-link level4">1.2.4. SOAP的使用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-representational-state-transfer-rest-将数据作为资源" class="router-link-active router-link-exact-active toc-link level3">1.3. Representational state transfer (REST): 将数据作为资源</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-1-rest如何工作" class="router-link-active router-link-exact-active toc-link level4">1.3.1. REST如何工作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-2-rest的优点" class="router-link-active router-link-exact-active toc-link level4">1.3.2. REST的优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-3-rest的缺点" class="router-link-active router-link-exact-active toc-link level4">1.3.3. REST的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-3-4-rest的使用场景" class="router-link-active router-link-exact-active toc-link level4">1.3.4. REST的使用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-graphql-仅请求需要的数据" class="router-link-active router-link-exact-active toc-link level3">1.4. GraphQL：仅请求需要的数据</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-1-graphql如何工作" class="router-link-active router-link-exact-active toc-link level4">1.4.1. GraphQL如何工作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-2-graphql-的优点" class="router-link-active router-link-exact-active toc-link level4">1.4.2. GraphQL 的优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-3-graphql-的缺点" class="router-link-active router-link-exact-active toc-link level4">1.4.3. GraphQL 的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-4-4-graphql的使用场景" class="router-link-active router-link-exact-active toc-link level4">1.4.4. GraphQL的使用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_1-5-如何选择api模式" class="router-link-active router-link-exact-active toc-link level3">1.5. 如何选择API模式</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-接口攻防" class="router-link-active router-link-exact-active toc-link level2">2. 接口攻防</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-1-接口攻击" class="router-link-active router-link-exact-active toc-link level3">2.1. 接口攻击</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-2-接口防御" class="router-link-active router-link-exact-active toc-link level3">2.2. 接口防御</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_2-3-接口防御之最佳实践" class="router-link-active router-link-exact-active toc-link level3">2.3. 接口防御之最佳实践</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-接口的其他问题" class="router-link-active router-link-exact-active toc-link level2">3. 接口的其他问题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-接口重试" class="router-link-active router-link-exact-active toc-link level3">3.1. 接口重试</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-1-实际场景" class="router-link-active router-link-exact-active toc-link level4">3.1.1. 实际场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-2-原因分析" class="router-link-active router-link-exact-active toc-link level4">3.1.2. 原因分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-常见实现方案" class="router-link-active router-link-exact-active toc-link level4">3.1.3. 常见实现方案</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-1-手动实现重试逻辑" class="router-link-active router-link-exact-active toc-link level5">3.1.3.1. 手动实现重试逻辑</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-2-使用spring-retry" class="router-link-active router-link-exact-active toc-link level5">3.1.3.2. 使用Spring Retry</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-3-resilience4j" class="router-link-active router-link-exact-active toc-link level5">3.1.3.3. Resilience4j</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-4-hystrix-已进入维护模式" class="router-link-active router-link-exact-active toc-link level5">3.1.3.4. Hystrix（已进入维护模式）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-5-guava-retryer" class="router-link-active router-link-exact-active toc-link level5">3.1.3.5. Guava Retryer</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-3-6-总结" class="router-link-active router-link-exact-active toc-link level5">3.1.3.6. 总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-1-4-最佳实践" class="router-link-active router-link-exact-active toc-link level4">3.1.4. 最佳实践</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-防刷" class="router-link-active router-link-exact-active toc-link level3">3.2. 防刷</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-1-基于令牌桶算法的限流" class="router-link-active router-link-exact-active toc-link level4">3.2.1. 基于令牌桶算法的限流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-2-基于计数器的限流" class="router-link-active router-link-exact-active toc-link level4">3.2.2. 基于计数器的限流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-3-基于redis的分布式限流" class="router-link-active router-link-exact-active toc-link level4">3.2.3. 基于Redis的分布式限流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-4-基于熔断器的限流" class="router-link-active router-link-exact-active toc-link level4">3.2.4. 基于熔断器的限流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-5-基于nginx的限流" class="router-link-active router-link-exact-active toc-link level4">3.2.5. 基于Nginx的限流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-6-基于网关的限流-如spring-cloud-gateway" class="router-link-active router-link-exact-active toc-link level4">3.2.6. 基于网关的限流（如Spring Cloud Gateway）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-2-7-总结" class="router-link-active router-link-exact-active toc-link level4">3.2.7. 总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_3-3-调优" class="router-link-active router-link-exact-active toc-link level3">3.3. 调优</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_4-todo" class="router-link-active router-link-exact-active toc-link level2">4. TODO</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/api.html#_5-参考" class="router-link-active router-link-exact-active toc-link level2">5. 参考</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="api-接口" tabindex="-1"><a class="header-anchor" href="#api-接口" aria-hidden="true">#</a> API（接口）</h1><h2 id="_1-api架构风格对比-soap-vs-rest-vs-graphql-vs-rpc" tabindex="-1"><a class="header-anchor" href="#_1-api架构风格对比-soap-vs-rest-vs-graphql-vs-rpc" aria-hidden="true">#</a> 1. API架构风格对比：SOAP vs REST vs GraphQL vs RPC</h2><ul class="task-list-container"><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> TODO ： API架构风格</label></p></li><li><p><a href="https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/" target="_blank" rel="noopener noreferrer">Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>翻译版： <a href="https://www.cnblogs.com/charlieroro/p/14570214.html" target="_blank" rel="noopener noreferrer">API架构风格对比：SOAP vs REST vs GraphQL vs RPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://dev.to/andreidascalu/soap-vs-rest-vs-grpc-vs-graphql-1ib6" target="_blank" rel="noopener noreferrer">SOAP vs REST vs gRPC vs GraphQL<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://blog.bytebytego.com/p/soap-vs-rest-vs-graphql-vs-rpc" target="_blank" rel="noopener noreferrer">SOAP vs REST vs GraphQL vs RPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener noreferrer">RESTful API 设计指南<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://www.cnblogs.com/wwr3569/p/14295779.html" target="_blank" rel="noopener noreferrer">HTTP请求向服务器传参方式<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li></ul><ol><li>从历史发展的角度来说 API 架构风格的迭代过程；主要分析每一种架构风格的优缺点</li><li>结合 HTTP 相关知识，着重介绍 RESTFul 风格的最佳实践经验，以及业内一些软件的实践应用等【ES】；</li><li>API 的其它内容：接口的幂等性保证、接口安全、接口文档的管理、接口限流（单体+分布式）；</li></ol><p>HTTP 报文格式 RPC RMI WebSocket postman 中的传参方式与 HTTP 传参方式的对应关系；【curl 与 idea 中的 api 测试窗口】 HTTPClient 的简单用法 Spring 框架中是如何接收参数的； <strong>RESTful API</strong> vs <strong>SOAP</strong> vs <strong>XML-RPC</strong></p><p>最近一段时间关于GraphQL的讨论很多，一些项目中也相继用到了这种风格，但使用是否合理，是否存在杀鸡用牛刀这样的问题，还有待商榷。</p><p>译自：<a href="https://levelup.gitconnected.com/comparing-api-architectural-styles-soap-vs-rest-vs-graphql-vs-rpc-84a3720adefa" target="_blank" rel="noopener noreferrer">Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><figure><img src="/cs-tips/assets/1725821401960-feee6043.png" alt="1725821401960" tabindex="0" loading="lazy"><figcaption>1725821401960</figcaption></figure><p>两个不同的应用需要一个中间程序才能互通，开发者通常会使用应用程序接口(API)进行搭桥，使一个系统能够访问另一个系统的信息或功能。</p><p>为了在扩容时快速集成应用，实际的API会使用协议或规范来定义消息传递的语义和语法。这些规范构成了API架构。</p><p>过去几年曾出现了几种不同的API架构风格，每种风格都有其特定的标准数据交互模式。而对API架构的选择引起了无休止的讨论。</p><figure><img src="/cs-tips/assets/1712975643837-d9809314.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><p>现在，很多API用户放弃REST，并拥抱GraphQL。而在十年之前，对于REST来说则是相反的情况，在于SOAP的竞争中，REST大获全胜。这种观念的问题在于用于单方面去选择一个技术，而没有考虑实际价值以及以与特定场景的匹配度。</p><p>本文将会按照API风格出现的顺序对它们进行讨论，对比各自的优劣势，并给出各自适合的场景。</p><figure><img src="/cs-tips/assets/1712975643865-4449aba3.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><h3 id="_1-1-remote-procedure-call-rpc-唤醒另一个系统的功能" tabindex="-1"><a class="header-anchor" href="#_1-1-remote-procedure-call-rpc-唤醒另一个系统的功能" aria-hidden="true">#</a> 1.1. Remote Procedure Call (RPC):唤醒另一个系统的功能</h3><p>RPC是一个规范，它允许在一个不同的上下文中远程执行功能。RPC将本地程序调用扩展到了HTTP API的上下文中(<em>RPC的最上层大部分都是HTTP</em>)。 一开始的XML-RPC问题比较多，它很难保证XML载体的数据类型。后来出现了一个基于<a href="https://www.jsonrpc.org/" target="_blank" rel="noopener noreferrer">JSON-RPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>的RPC API，由于JSON的规范更加具体，因此被认为是SOAP的替代品。 <a href="https://grpc.io/" target="_blank" rel="noopener noreferrer">gRPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是一个谷歌在2015年开发的全新RPC版本，插件化支持负载均衡、跟踪、健康检查以及身份认证等，gRPC非常适用于微服务间的通信。</p><h4 id="_1-1-1-rpc如何工作" tabindex="-1"><a class="header-anchor" href="#_1-1-1-rpc如何工作" aria-hidden="true">#</a> 1.1.1. RPC如何工作</h4><p>客户端唤醒远端程序，序列化参数，并在消息中添加额外的信息，然后将消息发送给服务端。在接收到客户端的消息后，服务端会反序列化消息中的内容，执行请求的操作，并将结果返回给客户端。服务端存根(stub)和客户端存根(stub)负责参数的序列化和反序列化。</p><figure><img src="/cs-tips/assets/1712975643733-103eaf2c.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><h4 id="_1-1-2-rpc的优点" tabindex="-1"><a class="header-anchor" href="#_1-1-2-rpc的优点" aria-hidden="true">#</a> 1.1.2. RPC的优点</h4><ul><li><strong>直接简单的交互方式</strong>：RPC使用GET获取信息，并使用POST处理其他功能。服务端和客户端的交互归结为对后端的调用，并获取响应结果。</li><li><strong>方便添加功能</strong>：如果我们对API有新的需求，可以通过简单地添加新的后端来满足该需求：1）编写一个新的功能，然后发布；2）然后客户端就可以通过这个后端来满足需求。</li><li><strong>高性能</strong>：轻量载体提升了网络传输的性能，这对于共享服务器以及在网络上进行并行计算的工作站来说非常重要。RCP可以优化网络层，使其可以每天在不同的服务间发送大量消息。</li></ul><h4 id="_1-1-3-rpc的缺点" tabindex="-1"><a class="header-anchor" href="#_1-1-3-rpc的缺点" aria-hidden="true">#</a> 1.1.3. RPC的缺点</h4><ul><li><strong>与底层系统的强耦合</strong>：API的抽象程度与其可复用性相关。与底层系统的耦合越高，API的可复用性就越低。RPC与底层系统的强耦合使其无法在系统和外部API之间进行抽象，同时也增加了安全风险，很容易在API中泄露底层系统的实现细节。RPC的强耦合使其很难实现需求扩展和团队解耦，客户要么会担心调用特定后端可能带来的副作用(<em>如安全问题</em>)，要么会因为无法理解服务端的功能命名规则而不知道调用哪个后端。</li></ul><blockquote><p>这里说的&quot;与底层系统&quot;的耦合，并不是说与内核等底层实现之间的耦合，而是与底层服务的耦合，如与日志服务，鉴权服务等耦合。</p></blockquote><ul><li><strong>可发现性低</strong>：RPC无法对API进行自省或无法通过发送的RPC请求来理解其调用的功能。</li></ul><blockquote><p>应该是RPC并没有像REST API那样相对严格的调用规范，因此有些调用会比较难以理解</p></blockquote><ul><li><strong>功能爆炸</strong>：由于很容易添加新的功能，因此相比编辑现有的功能，新增的功能可能会导致大量功能重叠，也很难去理解。</li></ul><h4 id="_1-1-4-rpc使用场景" tabindex="-1"><a class="header-anchor" href="#_1-1-4-rpc使用场景" aria-hidden="true">#</a> 1.1.4. RPC使用场景</h4><p>RPC模式始于80年代，但它一直没有过时。像Google，Facebook (<a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer">Apache Thrift<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>)和Twitch(<a href="https://twitchtv.github.io/twirp/docs/intro.html" target="_blank" rel="noopener noreferrer">Twirp<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>) 这样的大型公司利用RPC的高性能特性来获得高性能、低开销的消息处理能力(规模庞大的微服务使用短消息进行通信，需要保证通信的畅通)。</p><ul><li><strong>命令式API</strong>：RPC非常适合向远端系统发送命令。例如，Slack API就是重命令的接口：加入频道、离开频道、发送消息等。因此Slack API的设计者可以使用RPC风格的模型，使功能更简单、紧凑，也更方便使用。</li><li><strong>用于内部微服务客户API</strong>：在整合单个供应商和用户时，我们不希望(像REST API那样)花费大量时间来传输元数据。凭借高消息速率和消息性能，gRPC和Twirp是微服务使用RPC的典范。gRPC背后使用的是HTTP 2，因此能够优化网络层，每天可以在不同的服务间传送大量消息。但如果不关心高性能网络，转而期望团队间能够使用稳定的API来发布不同的微服务，那么可以选择使用REST。</li></ul><h3 id="_1-2-simple-objects-access-protocol-soap-让数据作为服务" tabindex="-1"><a class="header-anchor" href="#_1-2-simple-objects-access-protocol-soap-让数据作为服务" aria-hidden="true">#</a> 1.2. Simple Objects Access Protocol (SOAP): 让数据作为服务</h3><p><a href="https://www.altexsoft.com/blog/engineering/what-is-soap-formats-protocols-message-structure-and-how-soap-is-different-from-rest/?utm_source=MediumCom&amp;utm_medium=referral&amp;utm_campaign=shared#soap-use-cases" target="_blank" rel="noopener noreferrer">SOAP<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是一种XML格式的，高度标准化的web通信协议。在XML-RPC面世一年之后，Microsoft发布了SOAP，SOAP继承了XML-RPC的很多特性。而后出现了REST，二者并驾齐驱，但很快REST就后来居上。</p><h4 id="_1-2-1-soap如何工作" tabindex="-1"><a class="header-anchor" href="#_1-2-1-soap如何工作" aria-hidden="true">#</a> 1.2.1. SOAP如何工作</h4><p>XML数据格式多种多样，加上大量消息结构，使得SOAP称为一种最冗长的API样式。</p><p>一个SOAP消息包含：</p><ul><li>每个消息的开始和结束都要包含一个信封标签</li><li>包含请求或响应的消息体</li><li>标头(如果消息必须确定某些具体要求或额外要求)</li><li>请求过程中的错误信息</li></ul><figure><img src="/cs-tips/assets/1712975643919-92815e96.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><p>SOAP API的逻辑是用Web服务描述语言(WSDL)编写的，该API描述语言定义了后端并描述了可执行的流程。它允许使用不同的编程语言和IDEs快速配置通信。</p><p>SOAP同时支持有状态和无状态消息。在有状态场景中，服务端会保存接收到的信息，该过程可能比较繁重，但对于涉及多方和复杂交易的操作来说是合理的。</p><h4 id="_1-2-2-soap的优点" tabindex="-1"><a class="header-anchor" href="#_1-2-2-soap的优点" aria-hidden="true">#</a> 1.2.2. SOAP的优点</h4><ul><li><strong>语言和平台无关</strong>： 支持创建基于Web的服务内置功能使SOAP能够处理独立于语言和平台的通信，并作出响应。</li><li><strong>适用于各种传输协议</strong>：SOAP支持大量传输协议，可以用于多种场景。</li><li><strong>内置错误处理</strong>： SOAP API规范可以返回Retry XML消息(携带错误码和错误解释)</li><li><strong>大量安全扩展</strong>： 集成了WS-Security，SOAP符合企业级事务质量。它为事务提供了隐私和完整性，并可以在消息层面进行加密</li></ul><figure><img src="/cs-tips/assets/1712975643755-c3dca74f.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><h4 id="_1-2-3-soap的缺点" tabindex="-1"><a class="header-anchor" href="#_1-2-3-soap的缺点" aria-hidden="true">#</a> 1.2.3. SOAP的缺点</h4><p>如今，由于多种原因，很多开发人员对必须集成SOAP API的想法感到不安。</p><ul><li><strong>仅支持XML</strong>：SOAP消息包含大量元数据，且请求和响应仅支持使用冗长的XML结构。</li><li><strong>厚重</strong>： 由于XML文件的大小，SOAP服务需要比较大的带宽。</li><li><strong>狭窄的专业知识</strong>：构建SOAP API需要深刻理解各种协议，以及严格的协议规则。</li><li><strong>乏味的消息更新</strong>： 在添加和移除消息属性时需要额外的工作量，这导致SOAP的采用率下降。</li></ul><h4 id="_1-2-4-soap的使用场景" tabindex="-1"><a class="header-anchor" href="#_1-2-4-soap的使用场景" aria-hidden="true">#</a> 1.2.4. SOAP的使用场景</h4><p>目前，SOAP架构大部分用于内部集成企业或其他可信任的伙伴。</p><ul><li><strong>高度安全的数据传输</strong>：SOAP的刚性结构、安全和授权能力使其特别适用于在遵守API提供者和API使用者之间的契约的同时，在API和客户端之间履行正式的软件契约。这也是为什么金融机构和其他企业用户选择SOAP的原因。</li></ul><h3 id="_1-3-representational-state-transfer-rest-将数据作为资源" tabindex="-1"><a class="header-anchor" href="#_1-3-representational-state-transfer-rest-将数据作为资源" aria-hidden="true">#</a> 1.3. Representational state transfer (REST): 将数据作为资源</h3><p>REST是一个自解释的、由一组架构约束定义的API架构风格，并被很多API使用者广泛采用。</p><p>作为当今最通用的API风格，它最初出现在2000年的Roy Fielding 的<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener noreferrer">博士论文<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中。REST使用简单格式(通常是JSON和XML)来表达服务侧的数据。</p><h4 id="_1-3-1-rest如何工作" tabindex="-1"><a class="header-anchor" href="#_1-3-1-rest如何工作" aria-hidden="true">#</a> 1.3.1. REST如何工作</h4><p>REST没有像SOAP那样严格。RESTful架构应该遵循以下六个架构约束：</p><ul><li><strong>统一接口</strong>： 为一个给定的服务(无论是设备还是应用类型)提供统一的接口。</li><li><strong>无状态</strong>：处理请求本身所包含的请求状态，而服务器不会存储与会话相关的任何内容</li><li><strong>缓存</strong></li><li><strong>客户端-服务端架构</strong>:允许两端独立演进</li><li>应用<strong>系统分层</strong></li><li>服务端可以给客户端提供<strong>可执行的代码</strong></li></ul><p>实际上，某些服务仅在一定程度上是RESTful的，而核心使用了RPC风格，将大型服务分割成多个资源，并有效地利用HTTP基础设施。但关键部分使用的是超媒体(又称HATEOAS，<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener noreferrer">Hypertext As The Engine of Application State<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>)，意味着对于每个响应，REST API提供了如何使用API的所有元数据信息。REST使用这种方式来解耦客户端和服务端，这样，API提供者和消费者就可以独立演进，且不会妨碍它们的通信。</p><figure><img src="/cs-tips/assets/1712975644223-047f0c66.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><p><em>Richardson Maturity Model as a goalpost to achieving truly complete and useful APIs, Source:</em><a href="https://nordicapis.com/what-is-the-richardson-maturity-model/" target="_blank" rel="noopener noreferrer">Kristopher Sandoval<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>&quot;<em>HATEOAS</em> 是REST的关键特性，这也是REST之所以称为_REST_的原因。但由于很多人并不使用HATEOAS，导致他们实际上用的是HTTP RPC&quot;，这是<a href="https://www.reddit.com/r/golang/comments/7qvi0w/twirp_a_sweet_new_rpc_framework_for_go_twitch_blog/dstkrnm/" target="_blank" rel="noopener noreferrer">Reddit<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>上的一些激进意见。确实，HATEOAS是最成熟的REST版本，但很难实现比通常使用和构建的API客户端更加高级和智能的API客户端。因此，即使是如今非常好的REST API也不能保证面面俱到。这也是为什么HATEOAS主要作为RESTful API设计的长期开发愿景。</p><p>REST和RPC之间有一些灰色区域，特别是当一个服务具有一部分REST特性，一部分RPC特性时。REST基于资源，而不是基于动作或动词。</p><figure><img src="/cs-tips/assets/1712975644228-aeb0ae14.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><p>在REST中，会用到像GET, POST, PUT, DELETE, OPTIONS, PATCH这样的HTTP方法。</p><figure><img src="/cs-tips/assets/1712975644380-7853c517.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><h4 id="_1-3-2-rest的优点" tabindex="-1"><a class="header-anchor" href="#_1-3-2-rest的优点" aria-hidden="true">#</a> 1.3.2. REST的优点</h4><ul><li><strong>解耦客户端和服务端</strong>： REST的抽象比RPC更好，可以更好地解耦客户端和服务端。具有一定抽象的系统可以更好地封装其细节并维持其属性。这使得REST API足够灵活，可以在保持系统稳定的同时，随时间进行演化。</li><li><strong>可发现性</strong>： 客户端和服务端的通信描述了所有细节，因此无需额外的文档来理解如何使用REST API进行交互。</li><li><strong>缓存友好</strong>： 重用了大量HTTP工具，REST是唯一一种允许在HTTP层缓存数据的风格。相比之下，要在其他API风格中实现缓存，则要求配置额外的缓存模块。</li><li><strong>支持多种格式</strong>： 支持多种格式的数据存储和交互功能也是使REST成为当前流行的构建公共APIs的原因之一。</li></ul><h4 id="_1-3-3-rest的缺点" tabindex="-1"><a class="header-anchor" href="#_1-3-3-rest的缺点" aria-hidden="true">#</a> 1.3.3. REST的缺点</h4><ul><li><strong>没有单一的REST结构</strong>： 不存在正确地构建REST API的方式。如何对资源进行建模，以及对哪些资源建模取决于具体场景，这使得REST在理论上是简单的，但实践上是困难的。</li><li><strong>载荷较大</strong>： REST会返回大量元数据，因此客户端可以从响应的信息中了解到应用的状态。对于具有大容量带宽的大型网络通道来说，这种交互方式没有问题。但实际情况并不总是这样，这也是Facebook在2012年推出GraphQL风格的主要驱动因素。</li><li><strong>过度获取和不足获取问题</strong>：由于有时候会出现包含的数据过多或过少的情况，导致在接收到REST的响应之后，通常还会需要另一个请求。</li></ul><h4 id="_1-3-4-rest的使用场景" tabindex="-1"><a class="header-anchor" href="#_1-3-4-rest的使用场景" aria-hidden="true">#</a> 1.3.4. REST的使用场景</h4><ul class="task-list-container"><li><p><strong>管理API</strong>： 专注于管理系统中的对象，并面向多个消费者是最常见的API风格。REST可以帮助这类APIs实现强大的发现能力，良好的文档记录，并符合对象模型。</p></li><li><p><strong>简单资源驱动的APPs</strong>： REST是一种非常有用的方法，可用于连接不需要灵活查询的资源驱动型应用。</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 设计restful接口的一些最佳实践</label></p></li></ul><h3 id="_1-4-graphql-仅请求需要的数据" tabindex="-1"><a class="header-anchor" href="#_1-4-graphql-仅请求需要的数据" aria-hidden="true">#</a> 1.4. GraphQL：仅请求需要的数据</h3><p>它需要多次调用REST API才能返回所需的内容。 因此，GraphQL被认为是一种改变API规则的风格。</p><p><a href="https://www.altexsoft.com/blog/engineering/graphql-core-features-architecture-pros-and-cons/?utm_source=MediumCom&amp;utm_medium=referral&amp;utm_campaign=shared" target="_blank" rel="noopener noreferrer">GraphQL<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 的语法描述了如何发起精确的数据请求。GraphQL适合那些相互之间具有复杂实体引用关系的应用数据模型。</p><figure><img src="/cs-tips/assets/1712975644397-09ac7c2b.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><p>现在，GraphQL生态扩展了相关的库，并出现了很多强大的工具，如Apollo, GraphiQL, and GraphQL Explorer。</p><h4 id="_1-4-1-graphql如何工作" tabindex="-1"><a class="header-anchor" href="#_1-4-1-graphql如何工作" aria-hidden="true">#</a> 1.4.1. GraphQL如何工作</h4><p>一开始，GraphQL会创建一个_schema_(模式)，它描述了在一个GraphQL API中的所有请求以及这些请求返回的所有_types_。构建模式会比较困难，它需要使用模式定义语言(DSL)进行强类型输入。</p><p>由于在请求前已经构建好了模式，因此客户端可以对请求进行校验，确保服务器能够进行响应。在到达后端应用后，会有一个GraphQL操作，负责使用前端应用的数据来解析整个模式。在给服务端发送包含大量查询的请求之后，API会返回一个JSON响应，内容正对应请求的资源。</p><figure><img src="/cs-tips/assets/1712975644332-dae04da3.png" alt="image.jpg" tabindex="0" loading="lazy"><figcaption>image.jpg</figcaption></figure><p>除RESTful CRUD操作外，GraphQL还有订阅功能，允许接收服务端的实时通知。</p><h4 id="_1-4-2-graphql-的优点" tabindex="-1"><a class="header-anchor" href="#_1-4-2-graphql-的优点" aria-hidden="true">#</a> 1.4.2. GraphQL 的优点</h4><ul><li><strong>类型化的模式</strong>： GraphQL 会提前发布它可以做的事情，这种方式提升了可发现性。通过将客户端指向GraphQL API，我们可以知道哪些查询是可用的。</li><li><strong>非常适合类似图形的数据</strong>： 适合深度关联的数据，不适合扁平数据。</li><li><strong>没有版本控制</strong>： 最好的版本控制就是不对API进行版本控制。</li></ul><p>REST提供了多种API版本，而GraphQL是一种单一的、演化的版本，可以持续访问新的特性，方便服务端代码的维护。</p><ul><li><strong>详细的错误消息</strong>： 与SOAP类似，GraphQL提供了详细的错误信息，错误信息包括所有的解析器以及特定的查询错误。</li><li><strong>灵活的权限</strong>： GraphQL允许在暴露特定的功能的同时保留隐私信息。而REST架构不能部分展示数据(要么全部显示，要么全部隐藏)。</li></ul><h4 id="_1-4-3-graphql-的缺点" tabindex="-1"><a class="header-anchor" href="#_1-4-3-graphql-的缺点" aria-hidden="true">#</a> 1.4.3. GraphQL 的缺点</h4><ul><li><strong>性能问题</strong>： GraphQL用复杂度换来功能上的提升。在一个请求中包含太多封装的字段可能会导致系统过载。因此，即时对于复杂的查询，REST仍然是一个比较好的选择。</li><li><strong>缓存复杂</strong>： GraphQL 没有使用HTTP缓存语义，需要客户自定义。</li><li><strong>需要大量开发前培训</strong>：由于没有足够的时间弄清楚GraphQL 的基本操作和SDL，很多项目决定沿用REST方式。</li></ul><h4 id="_1-4-4-graphql的使用场景" tabindex="-1"><a class="header-anchor" href="#_1-4-4-graphql的使用场景" aria-hidden="true">#</a> 1.4.4. GraphQL的使用场景</h4><ul><li><strong>手机端API</strong>： 这种情况下，对网络性能和单个消息载体的优化非常重要。因此GraphQL为移动设备提供了一种更有效的数据载体。</li><li><strong>复杂系统和微服务</strong>： GraphQL能够将复杂的系统集成隐藏在API背后。从不同的地方聚合数据，并将它们合并成一个全局模式。这对于扩展遗留基础设施或第三方API尤为重要。</li></ul><h3 id="_1-5-如何选择api模式" tabindex="-1"><a class="header-anchor" href="#_1-5-如何选择api模式" aria-hidden="true">#</a> 1.5. 如何选择API模式</h3><p>每种API项目都有不同的要求，通常基于如下几点进行选择：</p><ul><li>使用的编程语言</li><li>开发环境，以及</li><li>涉及的人力和财务资源等</li></ul><p>在了解到每种API设计风格之后，API设计者就可以根据项目的需要选择最合适的API模式。</p><p>由于强耦合特性，RPC通常用于内部微服务间的通信，不适用于外部API或API服务。</p><p>SOAP比较麻烦，但它本身丰富的安全特性仍然是交易操作、订单系统和支付等场景的不二之选。</p><p>REST具有高度抽象以及最佳的API模型。但往往会增加线路和聊天的负担--如果使用的是移动设备，这是不利的一面。</p><p>在获取数据方面，GraphQL迈出了一大步，但并不是所有人都有足够的时间和精力来处理这种模式。</p><p>归根结底，最好在一些小场景下尝试每种API风格，然后看是否满足需求，是否能够解决问题。如果可以，则可以尝试扩展到更多的场景。</p><blockquote><p>来自: <a href="https://www.cnblogs.com/charlieroro/p/14570214.html" target="_blank" rel="noopener noreferrer">api<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h2 id="_2-接口攻防" tabindex="-1"><a class="header-anchor" href="#_2-接口攻防" aria-hidden="true">#</a> 2. 接口攻防</h2><h3 id="_2-1-接口攻击" tabindex="-1"><a class="header-anchor" href="#_2-1-接口攻击" aria-hidden="true">#</a> 2.1. 接口攻击</h3><p>接口攻击手段多种多样，通常利用接口的漏洞或设计缺陷来破坏系统、窃取数据或进行其他恶意行为。以下是一些常见的接口攻击手段：</p><ul><li><strong><code>注入攻击</code></strong><ul><li><strong>SQL注入</strong>：攻击者在输入字段中插入SQL代码，以便绕过身份验证或访问未授权的数据。</li><li><strong>NoSQL注入</strong>：类似于SQL注入，但针对NoSQL数据库（如MongoDB），利用不安全的查询构造执行恶意操作。</li><li><strong>命令注入</strong>：攻击者通过输入字段注入操作系统命令，执行未授权的操作。</li></ul></li><li><strong><code>跨站脚本攻击（XSS）</code></strong><ul><li><strong>存储型XSS</strong>：恶意脚本存储在服务器上，并在用户浏览网页时执行。</li><li><strong>反射型XSS</strong>：恶意脚本在用户点击恶意链接时执行。</li><li><strong>DOM型XSS</strong>：恶意脚本通过修改网页DOM结构执行。</li></ul></li><li><strong><code>跨站请求伪造（CSRF）</code></strong><ul><li>攻击者诱导用户在已认证的会话中执行未授权的操作，例如提交表单或更改设置。</li></ul></li><li><strong><code>中间人攻击（MITM）</code></strong><ul><li>攻击者在客户端和服务器之间拦截并可能篡改数据传输，通过窃取或伪造数据包获取敏感信息。</li></ul></li><li><strong><code>分布式拒绝服务（DDoS）</code></strong><ul><li>攻击者通过大量请求淹没服务器，使其无法处理合法用户的请求，从而导致服务中断。</li></ul></li><li><strong><code>劫持会话</code></strong><ul><li>攻击者通过窃取用户的会话令牌（如Cookies、JWT等），冒充用户执行未授权操作。</li></ul></li><li><strong><code>API密钥滥用</code></strong><ul><li>攻击者获得API密钥后，滥用接口执行未授权操作，可能导致数据泄露或系统破坏。</li></ul></li><li><strong><code>参数篡改</code></strong><ul><li>攻击者修改API请求中的参数，尝试绕过安全检查或执行未授权操作。</li></ul></li><li><strong><code>路径遍历攻击</code></strong><ul><li>攻击者通过修改URL路径，访问未授权的文件或目录，获取敏感信息或执行未授权操作。</li></ul></li><li><strong><code>XML外部实体攻击（XXE）</code></strong><ul><li>攻击者在处理XML输入时注入恶意的外部实体，可能导致数据泄露、文件读取或远程代码执行。</li></ul></li><li><strong><code>不安全的API设计</code></strong><ul><li><strong>过度暴露</strong>：API暴露过多内部细节，提供了攻击者利用的机会。</li><li><strong>不必要的复杂性</strong>：复杂的API设计容易出现漏洞和错误，增加攻击面。</li></ul></li><li><strong><code>漏洞利用</code></strong><ul><li><strong>未修补的漏洞</strong>：利用已知但未修补的漏洞（如旧版库中的漏洞）进行攻击。</li><li><strong>零日漏洞</strong>：利用尚未公开或未修补的漏洞进行攻击。</li></ul></li></ul><h3 id="_2-2-接口防御" tabindex="-1"><a class="header-anchor" href="#_2-2-接口防御" aria-hidden="true">#</a> 2.2. 接口防御</h3><p>保证接口安全是现代软件开发中一个至关重要的环节，特别是在构建API时。接口的安全性可以通过多种方法和最佳实践来实现，以下是一些关键措施：</p><ul><li><strong><code>身份验证和授权</code></strong><ul><li><strong>身份验证</strong>：确保访问接口的每个用户或系统都经过验证。常见的方法包括： <ul><li><strong>API密钥</strong>：通过分配唯一的API密钥给每个客户端进行身份验证。</li><li><strong>OAuth</strong>：使用OAuth2协议进行用户授权和认证。</li><li><strong>JWT（JSON Web Token）</strong>：使用JWT进行身份验证，确保请求来自可信任的用户。</li></ul></li><li><strong>授权</strong>：确保经过验证的用户只能访问他们被授权访问的资源。常见的授权方法包括基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。</li></ul></li><li><strong><code>数据加密</code></strong><ul><li><strong>传输层加密</strong>：使用HTTPS加密传输数据，防止中间人攻击和数据窃听。</li><li><strong>数据加密</strong>：在存储和处理敏感数据时，使用加密技术保护数据。</li></ul></li><li><strong><code>输入验证和输出编码</code></strong><ul><li><strong>输入验证</strong>：验证和清理用户输入，防止注入攻击（如SQL注入、XSS）。</li><li><strong>输出编码</strong>：对输出数据进行编码，防止跨站脚本（XSS）攻击。</li></ul></li><li><strong><code>速率限制和请求限制</code></strong><ul><li><strong>速率限制</strong>：限制每个客户端在一定时间内的请求数量，防止滥用和DDoS攻击。</li><li><strong>请求限制</strong>：限制每个接口请求的大小和参数数量，防止资源耗尽攻击。</li></ul></li><li><strong><code>日志记录和监控</code></strong><ul><li><strong>日志记录</strong>：记录所有API请求和响应，特别是错误和异常情况，以便进行安全审计和问题排查。</li><li><strong>监控</strong>：实时监控API使用情况，检测异常行为和潜在攻击。</li></ul></li><li><strong><code>安全配置</code></strong><ul><li><strong>CORS（跨域资源共享）</strong>：配置CORS策略，限制哪些域可以访问API。</li><li><strong>防火墙和WAF（Web应用防火墙）</strong>：使用防火墙和WAF保护API免受常见的Web攻击。</li></ul></li><li><strong><code>安全设计和开发实践</code></strong><ul><li><strong>最小权限原则</strong>：确保每个组件和用户只拥有执行其任务所需的最低权限。</li><li><strong>安全编码实践</strong>：遵循安全编码标准和最佳实践，减少代码中的安全漏洞。</li><li><strong>定期安全测试</strong>：定期进行安全测试，如漏洞扫描、渗透测试，发现并修复安全漏洞。</li></ul></li><li><strong><code>安全性文档</code></strong><ul><li><strong>安全性文档</strong>：提供清晰的安全性文档，说明如何正确使用API，包括身份验证方法、加密要求和错误处理机制。</li></ul></li></ul><h3 id="_2-3-接口防御之最佳实践" tabindex="-1"><a class="header-anchor" href="#_2-3-接口防御之最佳实践" aria-hidden="true">#</a> 2.3. 接口防御之最佳实践</h3><ul><li>需求分析 <ul><li>最小权限原则</li></ul></li><li>实现 <ul><li>使用HTTPS协议</li><li>加验证码</li><li>对参数进行校验</li><li>身份验证及权限验证</li><li>限流</li><li>日志记录</li><li>转义</li><li>加密</li><li>CORS策略</li><li>统一的响应体</li></ul></li><li>代码审查 <ul><li>机查 <ul><li>SQL扫描</li><li>Sonar Qube</li></ul></li><li>人工走查 <ul><li>实现人员讲解</li><li>pr时review</li></ul></li></ul></li><li>测试 <ul><li>漏洞扫描</li><li>渗透测试</li><li>性能测试</li></ul></li><li>部署 <ul><li>防火墙</li><li>白名单</li></ul></li><li>维护 <ul><li>安全性文档</li><li>报警与监控</li></ul></li></ul><p>通过以上措施，可以有效地提高接口的安全性，防止未经授权的访问和潜在的攻击。根据具体应用场景和需求，可以选择适合的安全策略和工具，确保接口的安全性和可靠性。</p><h2 id="_3-接口的其他问题" tabindex="-1"><a class="header-anchor" href="#_3-接口的其他问题" aria-hidden="true">#</a> 3. 接口的其他问题</h2><h3 id="_3-1-接口重试" tabindex="-1"><a class="header-anchor" href="#_3-1-接口重试" aria-hidden="true">#</a> 3.1. 接口重试</h3><h4 id="_3-1-1-实际场景" tabindex="-1"><a class="header-anchor" href="#_3-1-1-实际场景" aria-hidden="true">#</a> 3.1.1. 实际场景</h4><p>接口重试多发生在调用三方接口的业务场景中。</p><h4 id="_3-1-2-原因分析" tabindex="-1"><a class="header-anchor" href="#_3-1-2-原因分析" aria-hidden="true">#</a> 3.1.2. 原因分析</h4><p>主要是由于网络不稳定，造成我们在调用三方接口时，没有请求成功，此时就需要在我们的系统中实现重试的逻辑，以确保调用三方接口成功。</p><h4 id="_3-1-3-常见实现方案" tabindex="-1"><a class="header-anchor" href="#_3-1-3-常见实现方案" aria-hidden="true">#</a> 3.1.3. 常见实现方案</h4><p>在Java领域，接口调用失败时进行重试是一种常见的错误处理方式，特别是在分布式系统、网络调用或与外部服务交互时。Java中有多种实现接口重试的方案，以下是一些常见的方法和库：</p><h5 id="_3-1-3-1-手动实现重试逻辑" tabindex="-1"><a class="header-anchor" href="#_3-1-3-1-手动实现重试逻辑" aria-hidden="true">#</a> 3.1.3.1. <strong>手动实现重试逻辑</strong></h5><p>最简单的方法是手动编写重试逻辑。可以在<code>try-catch</code>块中进行重试，通常会结合循环、递增等待时间（如指数回退）、最大重试次数等机制。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callWithRetry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> maxRetries <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> retryCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>retryCount <span class="token operator">&lt;</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 进行接口调用</span>
            <span class="token function">externalServiceCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 调用成功，退出循环</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            retryCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>retryCount <span class="token operator">==</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;最大重试次数已达&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 可设置等待时间，比如使用Thread.sleep()进行指数回退</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>控制权完全掌握在开发者手中，可以灵活实现。</li></ul></li><li><strong>缺点</strong>： <ul><li>代码重复度高，维护较为繁琐。</li><li>没有抽象和封装，代码容易变得复杂。</li></ul></li></ul><h5 id="_3-1-3-2-使用spring-retry" tabindex="-1"><a class="header-anchor" href="#_3-1-3-2-使用spring-retry" aria-hidden="true">#</a> 3.1.3.2. <strong>使用Spring Retry</strong></h5><p><a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="noopener noreferrer">Spring Retry<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是Spring生态系统中的一个模块，它提供了一个简单的方式来实现重试逻辑。它支持注解驱动和编程驱动的两种方式。</p><ol><li>使用注解方式</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>retry<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Backoff</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>retry<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Retryable</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Service</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Retryable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">RuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> maxAttempts <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> backoff <span class="token operator">=</span> <span class="token annotation punctuation">@Backoff</span><span class="token punctuation">(</span>delay <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">externalServiceCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 模拟接口调用</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li><strong>简洁</strong>：通过注解方式简化重试逻辑。</li><li><strong>灵活配置</strong>：支持自定义重试策略，如最大重试次数、回退策略（如指数回退）。</li></ul></li><li><strong>缺点</strong>： <ul><li>需要引入Spring的依赖。</li><li>对非常简单的场景可能显得过于复杂。</li></ul></li></ul><ol start="2"><li>使用编程方式</li></ol><p>Spring Retry也可以通过编程方式实现重试逻辑，不依赖注解。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>retry<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span><span class="token class-name">RetryTemplate</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">RetryTemplate</span> retryTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RetryTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callWithRetry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        retryTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>context <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">externalServiceCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3-1-3-3-resilience4j" tabindex="-1"><a class="header-anchor" href="#_3-1-3-3-resilience4j" aria-hidden="true">#</a> 3.1.3.3. <strong>Resilience4j</strong></h5><p><a href="https://resilience4j.readme.io/" target="_blank" rel="noopener noreferrer">Resilience4j<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是一个轻量级的容错库，支持多种容错模式，如重试、熔断、限流等。相比于Spring Retry，它更加现代化，适合响应式和函数式编程。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>resilience4j<span class="token punctuation">.</span>retry<span class="token punctuation">.</span></span><span class="token class-name">Retry</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>resilience4j<span class="token punctuation">.</span>retry<span class="token punctuation">.</span></span><span class="token class-name">RetryConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>resilience4j<span class="token punctuation">.</span>retry<span class="token punctuation">.</span></span><span class="token class-name">RetryRegistry</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">Duration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Supplier</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callWithRetry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">RetryConfig</span> config <span class="token operator">=</span> <span class="token class-name">RetryConfig</span><span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">maxAttempts</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">waitDuration</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">RetryRegistry</span> registry <span class="token operator">=</span> <span class="token class-name">RetryRegistry</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Retry</span> retry <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">retry</span><span class="token punctuation">(</span><span class="token string">&quot;myService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> retryableSupplier <span class="token operator">=</span> <span class="token class-name">Retry</span><span class="token punctuation">.</span><span class="token function">decorateSupplier</span><span class="token punctuation">(</span>retry<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">::</span><span class="token function">externalServiceCall</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            retryableSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;重试后仍失败: &quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">externalServiceCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">&quot;接口调用成功&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li><strong>功能丰富</strong>：Resilience4j不仅提供重试，还支持熔断、限流、降级等容错机制。</li><li><strong>响应式支持</strong>：支持Java 8的函数式编程风格和响应式编程（例如与Reactor结合使用）。</li></ul></li><li><strong>缺点</strong>： <ul><li>相对Spring Retry，Resilience4j的学习曲线可能稍微陡峭一些。</li></ul></li></ul><h5 id="_3-1-3-4-hystrix-已进入维护模式" tabindex="-1"><a class="header-anchor" href="#_3-1-3-4-hystrix-已进入维护模式" aria-hidden="true">#</a> <s>3.1.3.4. <strong>Hystrix（已进入维护模式）</strong></s></h5><p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener noreferrer">Hystrix<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是Netflix开源的一个容错库，主要用于处理分布式系统中的延迟和故障。它提供了熔断、隔离、降级和重试功能。</p><p>虽然Hystrix已经进入维护模式（不再新增功能），但它在许多遗留系统中仍然被使用。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span></span><span class="token class-name">HystrixCommand</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span></span><span class="token class-name">HystrixCommandGroupKey</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callWithRetry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExternalServiceCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ExternalServiceCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

        <span class="token keyword">protected</span> <span class="token class-name">ExternalServiceCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">&quot;MyGroup&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token string">&quot;接口调用成功&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;降级逻辑&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>提供了强大的熔断、隔离、重试和降级功能。</li><li>被Netflix等大型分布式系统广泛使用。</li></ul></li><li><strong>缺点</strong>： <ul><li>已进入维护模式，建议使用Resilience4j作为替代。</li><li>相对较重，过于复杂的小型应用可能不适用。</li></ul></li></ul><h5 id="_3-1-3-5-guava-retryer" tabindex="-1"><a class="header-anchor" href="#_3-1-3-5-guava-retryer" aria-hidden="true">#</a> 3.1.3.5. <strong>Guava Retryer</strong></h5><p><a href="https://github.com/rholder/retrying" target="_blank" rel="noopener noreferrer">Guava Retryer<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是Google的Guava库中的重试机制。它相对轻量且简单，支持自定义重试策略。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>rholder<span class="token punctuation">.</span>retry<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutionException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callWithRetry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">RetryException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Retryer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> retryer <span class="token operator">=</span> <span class="token class-name">RetryerBuilder</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">retryIfResult</span><span class="token punctuation">(</span>result <span class="token operator">-&gt;</span> <span class="token operator">!</span>result<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">retryIfException</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">withWaitStrategy</span><span class="token punctuation">(</span><span class="token class-name">WaitStrategies</span><span class="token punctuation">.</span><span class="token function">fixedWait</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">withStopStrategy</span><span class="token punctuation">(</span><span class="token class-name">StopStrategies</span><span class="token punctuation">.</span><span class="token function">stopAfterAttempt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        retryer<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">externalServiceCall</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Boolean</span> <span class="token function">externalServiceCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>轻量级，适合简单的重试场景。</li><li>灵活的重试策略配置。</li></ul></li><li><strong>缺点</strong>： <ul><li>功能相对有限，不支持复杂的容错机制。</li></ul></li></ul><h5 id="_3-1-3-6-总结" tabindex="-1"><a class="header-anchor" href="#_3-1-3-6-总结" aria-hidden="true">#</a> 3.1.3.6. 总结</h5><ul><li><strong>手动重试</strong>：适合简单场景，但容易导致代码重复，维护成本高。</li><li><strong>Spring Retry</strong>：集成Spring生态，适合Spring应用，简单易用。</li><li><strong>Resilience4j</strong>：功能全面，支持多种容错模式，适合现代化的分布式应用。</li><li><s><strong>Hystrix</strong>：虽然已进入维护模式，但仍有大量遗留系统使用。</s></li><li><strong>Guava Retryer</strong>：轻量、简单，适用于基本的重试需求。</li></ul><p>在选择重试方案时，需要根据项目的需求、复杂性以及团队的技术栈进行合理的取舍。如果项目已经基于Spring，可以优先选择Spring Retry或Resilience4j；如果需要更多的容错功能，Resilience4j是不错的选择。</p><h4 id="_3-1-4-最佳实践" tabindex="-1"><a class="header-anchor" href="#_3-1-4-最佳实践" aria-hidden="true">#</a> 3.1.4. 最佳实践</h4><ul><li>并不是所有的异常都代表要重试，因此注意下游接口返回的异常的类型，属于网络异常类的才进行重试；</li><li>只重试有限次数，不重试无线次数；重试有限次数后依然失败，就要进行补偿操作（比如日志记录）；</li><li>要考虑重试时间间隔，间隔时间一般是越来越长（如，第一次重试间隔1s，第二次5s，第三次10s，第四次30s……）</li><li>考虑下游接口的幂等性问题，一般是先查询，看是否成功，不成功才重试；</li><li>要考虑并发场景下的请求顺序混乱问题和重复发送问题，可以使用锁来解决；</li></ul><h3 id="_3-2-防刷" tabindex="-1"><a class="header-anchor" href="#_3-2-防刷" aria-hidden="true">#</a> 3.2. 防刷</h3><p>所谓接口防刷，意思就是少量请求接口时，是可以成功的，但是由于业务逻辑要求或者系统能能要求等，并不允许对接口的多次大量的请求。</p><p>因此防刷的本质就是限流。</p><p>在Java领域中，<strong>接口防刷</strong>（即防止接口被频繁或恶意调用）是一项重要的安全措施，尤其是在互联网应用中。接口防刷主要通过<strong>限流</strong>、<strong>速率限制</strong>、<strong>令牌桶</strong>、<strong>IP限制</strong>等技术手段来防止滥用或攻击。以下是几种常见的实现方案：</p><h4 id="_3-2-1-基于令牌桶算法的限流" tabindex="-1"><a class="header-anchor" href="#_3-2-1-基于令牌桶算法的限流" aria-hidden="true">#</a> 3.2.1. <strong>基于令牌桶算法的限流</strong></h4><p>令牌桶（Token Bucket）是一种常见的限流算法，能够有效控制请求的频率。它维护一个装有令牌的桶，接口每次请求都需要消耗一个令牌，如果桶中没有令牌，接口请求将被拒绝。</p><p>使用<code>Guava</code>库提供的<code>RateLimiter</code>类，它实现了令牌桶算法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">RateLimiter</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RateLimiter</span> rateLimiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每秒2个请求</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 允许调用接口</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 拒绝调用</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用被限流&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>实现简单，Guava内置支持。</li><li>高效控制请求速率。</li></ul></li><li><strong>缺点</strong>： <ul><li>不支持分布式场景，适合单机模式。</li></ul></li></ul><h4 id="_3-2-2-基于计数器的限流" tabindex="-1"><a class="header-anchor" href="#_3-2-2-基于计数器的限流" aria-hidden="true">#</a> 3.2.2. <strong>基于计数器的限流</strong></h4><p>计数器（Counter-based Throttling）是一种简单的限流方式，它通过记录单位时间内的请求次数来限制请求量。</p><p>在Java中可以使用<code>ConcurrentHashMap</code>来存储每个IP或用户的请求计数。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ConcurrentHashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> requestCounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callService</span><span class="token punctuation">(</span><span class="token class-name">String</span> clientId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 每分钟10次请求限制</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> requestCounts<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>clientId<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;=</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用被限流&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            requestCounts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>clientId<span class="token punctuation">,</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 定时清除请求计数（如每分钟清除一次）</span>
        <span class="token function">resetCounterPeriodically</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resetCounterPeriodically</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                requestCounts<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>实现简单。</li><li>适用于小规模限流场景。</li></ul></li><li><strong>缺点</strong>： <ul><li>精确度不高，单位时间内的高并发情况下可能不够灵活。</li><li>不适合分布式环境。</li></ul></li></ul><h4 id="_3-2-3-基于redis的分布式限流" tabindex="-1"><a class="header-anchor" href="#_3-2-3-基于redis的分布式限流" aria-hidden="true">#</a> 3.2.3. <strong>基于Redis的分布式限流</strong></h4><p>在分布式系统中，限流需要在多个节点之间共享状态。Redis是一种高效的键值存储，可以用作限流的存储介质。</p><p>在Redis中记录每个客户端的请求次数，并设置过期时间（TTL）来实现滑动窗口限流。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisRateLimiter</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">&quot;localhost&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAllowed</span><span class="token punctuation">(</span><span class="token class-name">String</span> clientId<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRequests<span class="token punctuation">,</span> <span class="token keyword">int</span> windowSeconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;rate_limit:&quot;</span> <span class="token operator">+</span> clientId<span class="token punctuation">;</span>
        <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 当前秒数</span>

        <span class="token comment">// 使用 Redis 的 INCR 和 EXPIRE 进行限流操作</span>
        <span class="token class-name">Long</span> count <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">incr</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            jedis<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> windowSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> maxRequests<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 限流</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 允许请求</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>适用于分布式场景。</li><li>通过Redis的分布式特性实现全局限流。</li></ul></li><li><strong>缺点</strong>： <ul><li>需要依赖Redis等外部存储。</li><li>需要注意Redis的性能瓶颈及高可用性。</li></ul></li></ul><h4 id="_3-2-4-基于熔断器的限流" tabindex="-1"><a class="header-anchor" href="#_3-2-4-基于熔断器的限流" aria-hidden="true">#</a> 3.2.4. <strong>基于熔断器的限流</strong></h4><p>熔断器（Circuit Breaker）主要用于防止服务过载，通过动态监测接口状态，如果接口的失败率超过阈值，则触发熔断，暂时拒绝所有请求。</p><p>使用<code>Resilience4j</code>库实现熔断限流。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>resilience4j<span class="token punctuation">.</span>circuitbreaker<span class="token punctuation">.</span></span><span class="token class-name">CircuitBreaker</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>resilience4j<span class="token punctuation">.</span>circuitbreaker<span class="token punctuation">.</span></span><span class="token class-name">CircuitBreakerConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>resilience4j<span class="token punctuation">.</span>circuitbreaker<span class="token punctuation">.</span></span><span class="token class-name">CircuitBreakerRegistry</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">Duration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Supplier</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircuitBreakerService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CircuitBreaker</span> circuitBreaker<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">CircuitBreakerService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">CircuitBreakerConfig</span> config <span class="token operator">=</span> <span class="token class-name">CircuitBreakerConfig</span><span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">failureRateThreshold</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token comment">// 失败率阈值</span>
                <span class="token punctuation">.</span><span class="token function">waitDurationInOpenState</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 熔断持续时间</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">CircuitBreakerRegistry</span> registry <span class="token operator">=</span> <span class="token class-name">CircuitBreakerRegistry</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>circuitBreaker <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">circuitBreaker</span><span class="token punctuation">(</span><span class="token string">&quot;serviceCircuitBreaker&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> supplier <span class="token operator">=</span> <span class="token class-name">CircuitBreaker</span><span class="token punctuation">.</span><span class="token function">decorateSupplier</span><span class="token punctuation">(</span>circuitBreaker<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">::</span><span class="token function">externalServiceCall</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用被熔断&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">externalServiceCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;接口调用失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">&quot;接口调用成功&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>优点</strong>： <ul><li>避免服务过载导致整体不可用。</li><li>动态调节，自动熔断与恢复。</li></ul></li><li><strong>缺点</strong>： <ul><li>主要用于服务的保护，限流的能力不如专门的限流算法精细。</li></ul></li></ul><h4 id="_3-2-5-基于nginx的限流" tabindex="-1"><a class="header-anchor" href="#_3-2-5-基于nginx的限流" aria-hidden="true">#</a> 3.2.5. <strong>基于Nginx的限流</strong></h4><p>Nginx是一种高性能的HTTP服务器和反向代理服务器，它提供了限流模块，可以在网关层面控制请求的速率。常用于前端限流，在请求到达应用之前，Nginx就会对其进行限流。</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">limit_req_zone</span> <span class="token variable">$binary_remote_addr</span> zone=one:10m rate=1r/s</span><span class="token punctuation">;</span>

    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
        <span class="token directive"><span class="token keyword">location</span> /api/</span> <span class="token punctuation">{</span>
            <span class="token directive"><span class="token keyword">limit_req</span> zone=one burst=5 nodelay</span><span class="token punctuation">;</span>
            <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>rate=1r/s</code>：每个客户端每秒最多允许1个请求。</p></li><li><p><code>burst=5</code>：允许最多5个突发请求。</p></li><li><p><code>nodelay</code>：不进行延迟处理，超出速率的请求立即返回错误。</p></li><li><p><strong>优点</strong>：</p><ul><li>对于高流量系统非常高效。</li><li>不需要修改应用代码，完全在Nginx层面控制。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>粒度较粗，无法针对特定的用户、IP、接口等进行细粒度限流。</li></ul></li></ul><h4 id="_3-2-6-基于网关的限流-如spring-cloud-gateway" tabindex="-1"><a class="header-anchor" href="#_3-2-6-基于网关的限流-如spring-cloud-gateway" aria-hidden="true">#</a> 3.2.6. <strong>基于网关的限流（如Spring Cloud Gateway）</strong></h4><p>Spring Cloud Gateway是一种常见的微服务网关解决方案，提供了限流功能，可以根据请求的路径、用户等进行限流控制。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> my_route
        <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//my<span class="token punctuation">-</span>service
        <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> Path=/api/<span class="token important">**</span>
        <span class="token key atrule">filters</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> RequestRateLimiter
          <span class="token key atrule">args</span><span class="token punctuation">:</span>
            <span class="token key atrule">redis-rate-limiter.replenishRate</span><span class="token punctuation">:</span> <span class="token number">10</span>
            <span class="token key atrule">redis-rate-limiter.burstCapacity</span><span class="token punctuation">:</span> <span class="token number">20</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>replenishRate</code>：每秒产生多少个请求令牌。</p></li><li><p><code>burstCapacity</code>：允许的最大突发请求数量。</p></li><li><p><strong>优点</strong>：</p><ul><li>集成在微服务架构中，适合大型分布式系统。</li><li>支持动态配置和调整。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>依赖于微服务架构和网关层，适用场景特定。</li></ul></li></ul><h4 id="_3-2-7-总结" tabindex="-1"><a class="header-anchor" href="#_3-2-7-总结" aria-hidden="true">#</a> 3.2.7. 总结</h4><table><thead><tr><th>实现方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>手动实现计数器限流</td><td>小规模、简单接口防刷场景</td><td>实现简单</td><td>精确度不高，无法分布式</td></tr><tr><td>Guava RateLimiter</td><td>单机限流</td><td>实现简单，代码简洁</td><td>只适用于单机环境</td></tr><tr><td>Redis限流</td><td>分布式系统，多个节点共享限流状态</td><td>适合分布式，性能高效</td><td>依赖Redis，需考虑Redis性能和高可用性</td></tr><tr><td>Resilience4j熔断限流</td><td>分布式系统，防止服务过载</td><td>动态熔断，支持服务保护</td><td>主要用于熔断，限流精度相对较低</td></tr><tr><td>Nginx限流</td><td>高并发、高流量系统，网关层面限流</td><td>高效，无需修改应用代码</td><td>细粒度控制有限</td></tr><tr><td>Spring Cloud Gateway限流</td><td>微服务架构，基于网关的动态限流</td><td>集成微服务体系，支持动态限流</td><td>依赖于微服务架构</td></tr></tbody></table><p>根据实际场景选择合适的限流方案非常重要。如果是小型应用，手动实现或者Guava <code>RateLimiter</code>可能已经足够；对于分布式系统，Redis限流和熔断器方案则更加合适；如果是高并发、高流量的互联网服务，使用Nginx或基于网关的限流是比较有效的选择。</p><h3 id="_3-3-调优" tabindex="-1"><a class="header-anchor" href="#_3-3-调优" aria-hidden="true">#</a> 3.3. 调优</h3><h2 id="_4-todo" tabindex="-1"><a class="header-anchor" href="#_4-todo" aria-hidden="true">#</a> 4. TODO</h2><ol><li>httpclient 原理</li><li>RPC RMI</li><li>Ouath2.0 原理</li></ol><h2 id="_5-参考" tabindex="-1"><a class="header-anchor" href="#_5-参考" aria-hidden="true">#</a> 5. 参考</h2><ul><li><p><a href="https://www.cnblogs.com/charlieroro/p/14570214.html" target="_blank" rel="noopener noreferrer">API架构风格对比：SOAP vs REST vs GraphQL vs RPC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener noreferrer">RESTful API 设计指南<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://www.zhihu.com/question/28557115/answer/48094438" target="_blank" rel="noopener noreferrer">怎样用通俗的语言解释REST，以及RESTful？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://blog.csdn.net/zhipengfang/article/details/117455598" target="_blank" rel="noopener noreferrer">面试四连问：API 接口如何设计？安全如何保证？防重如何实现？签名如何实现？...<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://mp.weixin.qq.com/s/62xMLKpKtOLr8Sy_2Cb78g" target="_blank" rel="noopener noreferrer">保证接口安全，就用这11招！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://mp.weixin.qq.com/s/8_NJiy2dtFpJgIWbbYUGbQ" target="_blank" rel="noopener noreferrer">接口请求重试的8种方法，你用哪种？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://mp.weixin.qq.com/s/8VI6u_5D0SyxtdpI1noWqg" target="_blank" rel="noopener noreferrer">防止接口被刷的8种方法！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rEzHIE-nK7PpCKG7KAB-Jw" target="_blank" rel="noopener noreferrer">实战总结！18种接口优化方案的总结<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li></ul></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zeanzai/cs-tips/edit/main/demo/theme-docs/src/docs/05-distribution/api.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="page-nav"><!----><a href="/cs-tips/docs/05-distribution/distribution.html" class="nav-link next" aria-label="分布式系统"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">分布式系统<!----></div></a></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">浪漫骑士的二流键盘</div><div class="copyright">Copyright © 2024 zeanzai</div></footer></div><!--]--><!----><!----><!----><!--]--></div>
    <script type="module" src="/cs-tips/assets/app-fa4d50d2.js" defer></script>
  </body>
</html>
