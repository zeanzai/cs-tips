<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zeanzai.github.io/cs-tips/cs-tips/docs/05-distribution/distribution.html"><meta property="og:site_name" content="cs-tips"><meta property="og:title" content="分布式系统"><meta property="og:description" content="1. 分布式系统的迭代过程（单体应用-分布式应用） 2. 分布式系统的特点： 分布性、对等性、自治性、并发性； 3. 分布式系统的挑战： 由于已经有非常成熟的解决方案，这些成熟的方案已经帮我们屏蔽掉底层所遇到的核心问题，因此我们只需要解决应用层面上的问题即可。事实上，我们只需要解决我们自己项目应用层面的问题和使用这些已有成熟方案的使用上的问题即可。 1..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="zeanzai"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"分布式系统","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"zeanzai","url":"https://github.com/zeanzai"}]}</script><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/cs-tips/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><link rel="icon" href="/cs-tips/favicon.ico"><title>分布式系统 | cs-tips</title><meta name="description" content="1. 分布式系统的迭代过程（单体应用-分布式应用） 2. 分布式系统的特点： 分布性、对等性、自治性、并发性； 3. 分布式系统的挑战： 由于已经有非常成熟的解决方案，这些成熟的方案已经帮我们屏蔽掉底层所遇到的核心问题，因此我们只需要解决应用层面上的问题即可。事实上，我们只需要解决我们自己项目应用层面的问题和使用这些已有成熟方案的使用上的问题即可。 1...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/cs-tips/assets/style-37e20de6.css" as="style"><link rel="stylesheet" href="/cs-tips/assets/style-37e20de6.css">
    <link rel="modulepreload" href="/cs-tips/assets/app-fa4d50d2.js"><link rel="modulepreload" href="/cs-tips/assets/framework-16b96b76.js"><link rel="modulepreload" href="/cs-tips/assets/distribution.html-009df836.js"><link rel="modulepreload" href="/cs-tips/assets/distribution.html-2dd8ab58.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/cs-tips/" class="brand"><img class="logo" src="/cs-tips/logo.svg" alt="cs-tips"><!----><span class="site-name hide-in-pad">cs-tips</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/cs-tips/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/cs-tips/docs/01-csbase/" class="nav-link" aria-label="要点提示"><span class="font-icon icon iconfont icon-ability" style=""></span>要点提示<!----></a></div><div class="nav-item hide-in-mobile"><a href="https://github.com/zeanzai/cs-tips/issues" rel="noopener noreferrer" target="_blank" aria-label="问题反馈" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>问题反馈<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/zeanzai/cs-tips" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="title">01-CS基础</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="title">02-Java编程语言</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-layout" style=""></span><span class="title">03-框架</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-api" style=""></span><span class="title">04-中间件</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-structure" style=""></span><span class="title">05-分布式</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/cs-tips/docs/05-distribution/api.html" class="nav-link sidebar-link sidebar-page" aria-label="API（接口）"><!---->API（接口）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="分布式系统"><!---->分布式系统<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-基础理论" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 基础理论"><!---->1. 基础理论<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-分布式应用的迭代过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 分布式应用的迭代过程"><!---->1. 分布式应用的迭代过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式应用的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 分布式应用的特点"><!---->2. 分布式应用的特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-分布式应用遇到的挑战" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 分布式应用遇到的挑战"><!---->3. 分布式应用遇到的挑战<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-如何做技术选型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 如何做技术选型？"><!---->4. 如何做技术选型？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-如何更好的使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 如何更好的使用？"><!---->5. 如何更好的使用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 总结"><!---->6. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-理论基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7. 理论基础"><!---->7. 理论基础<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-cap-理论" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8. CAP 理论"><!---->8. CAP 理论<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-内容" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9. 内容："><!---->9. 内容：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-三者之间的关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10. 三者之间的关系："><!---->10. 三者之间的关系：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_11-应用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11. 应用"><!---->11. 应用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_12-base-理论" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12. BASE 理论"><!---->12. BASE 理论<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_13-简介" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13. 简介"><!---->13. 简介<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_14-base-理论的核心思想" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14. BASE 理论的核心思想"><!---->14. BASE 理论的核心思想<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-base-理论三要素" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15. BASE 理论三要素"><!---->15. BASE 理论三要素<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-1-基本可用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15.1. 基本可用"><!---->15.1. 基本可用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-2-软状态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15.2. 软状态"><!---->15.2. 软状态<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-3-最终一致性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15.3. 最终一致性"><!---->15.3. 最终一致性<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_16-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16. 总结"><!---->16. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-常用算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17. 常用算法"><!---->17. 常用算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-1-paxos" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17.1. Paxos"><!---->17.1. Paxos<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-2-一致性-hash" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17.2. 一致性 Hash"><!---->17.2. 一致性 Hash<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-2-1-出现的背景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17.2.1. 出现的背景"><!---->17.2.1. 出现的背景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_18-分布式应用的性能指标" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18. 分布式应用的性能指标"><!---->18. 分布式应用的性能指标<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_18-1-简介" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18.1. 简介"><!---->18.1. 简介<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_18-2-提高性能的注意事项" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18.2. 提高性能的注意事项"><!---->18.2. 提高性能的注意事项<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_19-参考" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19. 参考"><!---->19. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 分布式锁"><!---->2. 分布式锁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-背景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 背景"><!---->1. 背景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式锁具有的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 分布式锁具有的特点"><!---->2. 分布式锁具有的特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 实现方案"><!---->3. 实现方案<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-1-关系型数据库实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1. 关系型数据库实现方案"><!---->3.1. 关系型数据库实现方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-2-redis实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2. redis实现方案"><!---->3.2. redis实现方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-3-redlock实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3. redlock实现"><!---->3.3. redlock实现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-4-zk实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4. zk实现方案"><!---->3.4. zk实现方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-5-memercached实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5. memercached实现方案"><!---->3.5. memercached实现方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-6-生产环境实现方案-小公司" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6. 生产环境实现方案（小公司）"><!---->3.6. 生产环境实现方案（小公司）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-7-生产环境实现方案-大公司" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.7. 生产环境实现方案（大公司）"><!---->3.7. 生产环境实现方案（大公司）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-总结-面试题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 总结（面试题）"><!---->4. 总结（面试题）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-参考" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 参考"><!---->5. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-分布式事务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 分布式事务"><!---->3. 分布式事务<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-分布式事务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 分布式事务"><!---->1. 分布式事务<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-1-背景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1. 背景"><!---->1.1. 背景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-2-xa理论" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2. XA理论"><!---->1.2. XA理论<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-3-2pc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3. 2PC"><!---->1.3. 2PC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-4-sagas方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4. SAGAS方案"><!---->1.4. SAGAS方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-5-3pc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5. 3PC"><!---->1.5. 3PC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-6-tcc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6. TCC"><!---->1.6. TCC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-7-本地消息表方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7. 本地消息表方案"><!---->1.7. 本地消息表方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-8-最大努力通知方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.8. 最大努力通知方案"><!---->1.8. 最大努力通知方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-9-可靠消息最终一致性方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.9. 可靠消息最终一致性方案"><!---->1.9. 可靠消息最终一致性方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-10-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.10. 总结"><!---->1.10. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-11-附言" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.11. 附言"><!---->1.11. 附言<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-seata的at、tcc、saga和xa事务模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. Seata的AT、TCC、SAGA和XA事务模式"><!---->2. Seata的AT、TCC、SAGA和XA事务模式<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-分布式-id" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 分布式 ID"><!---->4. 分布式 ID<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-主键id" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 主键ID"><!---->1. 主键ID<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-方案1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 方案1"><!---->2. 方案1<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-方案2" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 方案2"><!---->3. 方案2<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-方案3" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 方案3"><!---->4. 方案3<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-参考-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 参考"><!---->5. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-分布式缓存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 分布式缓存"><!---->5. 分布式缓存<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-出现的背景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 出现的背景"><!---->1. 出现的背景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式缓存特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 分布式缓存特性"><!---->2. 分布式缓存特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-技术选型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 技术选型"><!---->3. 技术选型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-1-中间件选型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1. 中间件选型"><!---->3.1. 中间件选型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-2-组件选型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2. 组件选型"><!---->3.2. 组件选型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-3-redis基本原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3. redis基本原理"><!---->3.3. redis基本原理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-面试题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 面试题"><!---->4. 面试题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-1-分布式系统中的多级缓存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1. 分布式系统中的多级缓存"><!---->4.1. 分布式系统中的多级缓存<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-2-redis如何调优" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2. redis如何调优？"><!---->4.2. redis如何调优？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-3-七大经典缓存问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3. 七大经典缓存问题"><!---->4.3. 七大经典缓存问题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-3-1-参考链接" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.1. 参考链接"><!---->4.3.1. 参考链接<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-分布式缓存与数据库一致性问题-应用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 分布式缓存与数据库一致性问题： 应用场景"><!---->5. 分布式缓存与数据库一致性问题： 应用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 问题"><!---->6. 问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-设计实现方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7. 设计实现方案"><!---->7. 设计实现方案<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-1-方案一-更新db时-连带更新cache" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.1. 方案一-更新DB时，连带更新Cache"><!---->7.1. 方案一-更新DB时，连带更新Cache<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-2-方案二-先删除cache-再更新db" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.2. 方案二-先删除Cache，再更新DB"><!---->7.2. 方案二-先删除Cache，再更新DB<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-3-方案三-更新db后-删除cache【优选】" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.3. 方案三-更新DB后，删除Cache【优选】"><!---->7.3. 方案三-更新DB后，删除Cache【优选】<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-4-方案四-延迟双删" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.4. 方案四-延迟双删"><!---->7.4. 方案四-延迟双删<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-5-方案五-基于消息队列删除cache" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.5. 方案五-基于消息队列删除Cache"><!---->7.5. 方案五-基于消息队列删除Cache<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-6-方案六-强一致性方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.6. 方案六-强一致性方案"><!---->7.6. 方案六-强一致性方案<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-方案七-read-write-through模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8. 方案七-Read/Write Through模式"><!---->8. 方案七-Read/Write Through模式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-1-方案八-write-behind-模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8.1. 方案八-Write Behind 模式"><!---->8.1. 方案八-Write Behind 模式<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9. 总结"><!---->9. 总结<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-实现过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10. 实现过程"><!---->10. 实现过程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-分布式消息" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 分布式消息"><!---->6. 分布式消息<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-分布式消息常见问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 分布式消息常见问题"><!---->1. 分布式消息常见问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-企业级消息队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 企业级消息队列"><!---->2. 企业级消息队列<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-1-rabbitmq" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1. rabbitmq"><!---->2.1. rabbitmq<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-2-rocketmq" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2. rocketmq"><!---->2.2. rocketmq<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-3-kafka" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3. kafka"><!---->2.3. kafka<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-生产实践——设备云基于rabbit-mq的消息模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 生产实践——设备云基于Rabbit MQ的消息模型"><!---->3. 生产实践——设备云基于Rabbit MQ的消息模型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-1-消息处理流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1. 消息处理流程"><!---->3.1. 消息处理流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-2-消息丢失" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2. 消息丢失"><!---->3.2. 消息丢失<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-3-消息重复消费" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3. 消息重复消费"><!---->3.3. 消息重复消费<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-4-消息积压" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4. 消息积压"><!---->3.4. 消息积压<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-5-实时命令时序图" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5. 实时命令时序图"><!---->3.5. 实时命令时序图<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-6-异步抄表时序图" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6. 异步抄表时序图"><!---->3.6. 异步抄表时序图<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-分布式存储-分库分表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7. 分布式存储（分库分表）"><!---->7. 分布式存储（分库分表）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-实验" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 实验"><!---->1. 实验<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分库分表带来的问题及解决方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 分库分表带来的问题及解决方案"><!---->2. 分库分表带来的问题及解决方案<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-id" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. id"><!---->3. id<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-分布式事务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 分布式事务"><!---->4. 分布式事务<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-跨库查询和分页" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 跨库查询和分页"><!---->5. 跨库查询和分页<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-为什么要分" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 为什么要分"><!---->6. 为什么要分<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-什么时候分" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7. 什么时候分"><!---->7. 什么时候分<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-理论基础" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8. 理论基础"><!---->8. 理论基础<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-1-数据切分" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8.1. 数据切分"><!---->8.1. 数据切分<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-2-分库分表带来的问题及解决方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8.2. 分库分表带来的问题及解决方案"><!---->8.2. 分库分表带来的问题及解决方案<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-中间件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9. 中间件"><!---->9. 中间件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-实践案例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10. 实践案例"><!---->10. 实践案例<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_11-分库分表演进过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11. 分库分表演进过程"><!---->11. 分库分表演进过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_12-参考" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12. 参考"><!---->12. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-布式会话" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8. 布式会话"><!---->8. 布式会话<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-参考" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 参考"><!---->1. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-分布式-job" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9. 分布式 Job"><!---->9. 分布式 Job<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-参考" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10. 参考"><!---->10. 参考<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-like" style=""></span><span class="title">06-软件质量管理</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-editor" style=""></span><span class="title">07-工程设计</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->分布式系统</h1><!----><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-基础理论" class="router-link-active router-link-exact-active toc-link level2">1. 基础理论</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-分布式应用的迭代过程" class="router-link-active router-link-exact-active toc-link level3">1. 分布式应用的迭代过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式应用的特点" class="router-link-active router-link-exact-active toc-link level3">2. 分布式应用的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-分布式应用遇到的挑战" class="router-link-active router-link-exact-active toc-link level3">3. 分布式应用遇到的挑战</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-如何做技术选型" class="router-link-active router-link-exact-active toc-link level3">4. 如何做技术选型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-如何更好的使用" class="router-link-active router-link-exact-active toc-link level3">5. 如何更好的使用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-总结" class="router-link-active router-link-exact-active toc-link level3">6. 总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-理论基础" class="router-link-active router-link-exact-active toc-link level3">7. 理论基础</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-cap-理论" class="router-link-active router-link-exact-active toc-link level3">8. CAP 理论</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-内容" class="router-link-active router-link-exact-active toc-link level3">9. 内容：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-三者之间的关系" class="router-link-active router-link-exact-active toc-link level3">10. 三者之间的关系：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_11-应用" class="router-link-active router-link-exact-active toc-link level3">11. 应用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_12-base-理论" class="router-link-active router-link-exact-active toc-link level3">12. BASE 理论</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_13-简介" class="router-link-active router-link-exact-active toc-link level3">13. 简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_14-base-理论的核心思想" class="router-link-active router-link-exact-active toc-link level3">14. BASE 理论的核心思想</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-base-理论三要素" class="router-link-active router-link-exact-active toc-link level3">15. BASE 理论三要素</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-1-基本可用" class="router-link-active router-link-exact-active toc-link level4">15.1. 基本可用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-2-软状态" class="router-link-active router-link-exact-active toc-link level4">15.2. 软状态</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_15-3-最终一致性" class="router-link-active router-link-exact-active toc-link level4">15.3. 最终一致性</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_16-总结" class="router-link-active router-link-exact-active toc-link level3">16. 总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-常用算法" class="router-link-active router-link-exact-active toc-link level3">17. 常用算法</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-1-paxos" class="router-link-active router-link-exact-active toc-link level4">17.1. Paxos</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-2-一致性-hash" class="router-link-active router-link-exact-active toc-link level4">17.2. 一致性 Hash</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_17-2-1-出现的背景" class="router-link-active router-link-exact-active toc-link level5">17.2.1. 出现的背景</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_18-分布式应用的性能指标" class="router-link-active router-link-exact-active toc-link level3">18. 分布式应用的性能指标</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_18-1-简介" class="router-link-active router-link-exact-active toc-link level4">18.1. 简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_18-2-提高性能的注意事项" class="router-link-active router-link-exact-active toc-link level4">18.2. 提高性能的注意事项</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_19-参考" class="router-link-active router-link-exact-active toc-link level3">19. 参考</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式锁" class="router-link-active router-link-exact-active toc-link level2">2. 分布式锁</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-背景" class="router-link-active router-link-exact-active toc-link level3">1. 背景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式锁具有的特点" class="router-link-active router-link-exact-active toc-link level3">2. 分布式锁具有的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-实现方案" class="router-link-active router-link-exact-active toc-link level3">3. 实现方案</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-1-关系型数据库实现方案" class="router-link-active router-link-exact-active toc-link level4">3.1. 关系型数据库实现方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-2-redis实现方案" class="router-link-active router-link-exact-active toc-link level4">3.2. redis实现方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-3-redlock实现" class="router-link-active router-link-exact-active toc-link level4">3.3. redlock实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-4-zk实现方案" class="router-link-active router-link-exact-active toc-link level4">3.4. zk实现方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-5-memercached实现方案" class="router-link-active router-link-exact-active toc-link level4">3.5. memercached实现方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-6-生产环境实现方案-小公司" class="router-link-active router-link-exact-active toc-link level4">3.6. 生产环境实现方案（小公司）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-7-生产环境实现方案-大公司" class="router-link-active router-link-exact-active toc-link level4">3.7. 生产环境实现方案（大公司）</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-总结-面试题" class="router-link-active router-link-exact-active toc-link level3">4. 总结（面试题）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-参考" class="router-link-active router-link-exact-active toc-link level3">5. 参考</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-分布式事务" class="router-link-active router-link-exact-active toc-link level2">3. 分布式事务</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-分布式事务" class="router-link-active router-link-exact-active toc-link level3">1. 分布式事务</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-1-背景" class="router-link-active router-link-exact-active toc-link level4">1.1. 背景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-2-xa理论" class="router-link-active router-link-exact-active toc-link level4">1.2. XA理论</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-3-2pc" class="router-link-active router-link-exact-active toc-link level4">1.3. 2PC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-4-sagas方案" class="router-link-active router-link-exact-active toc-link level4">1.4. SAGAS方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-5-3pc" class="router-link-active router-link-exact-active toc-link level4">1.5. 3PC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-6-tcc" class="router-link-active router-link-exact-active toc-link level4">1.6. TCC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-7-本地消息表方案" class="router-link-active router-link-exact-active toc-link level4">1.7. 本地消息表方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-8-最大努力通知方案" class="router-link-active router-link-exact-active toc-link level4">1.8. 最大努力通知方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-9-可靠消息最终一致性方案" class="router-link-active router-link-exact-active toc-link level4">1.9. 可靠消息最终一致性方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-10-总结" class="router-link-active router-link-exact-active toc-link level4">1.10. 总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-11-附言" class="router-link-active router-link-exact-active toc-link level4">1.11. 附言</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-seata的at、tcc、saga和xa事务模式" class="router-link-active router-link-exact-active toc-link level3">2. Seata的AT、TCC、SAGA和XA事务模式</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-分布式-id" class="router-link-active router-link-exact-active toc-link level2">4. 分布式 ID</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-主键id" class="router-link-active router-link-exact-active toc-link level3">1. 主键ID</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-方案1" class="router-link-active router-link-exact-active toc-link level3">2. 方案1</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-方案2" class="router-link-active router-link-exact-active toc-link level3">3. 方案2</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-方案3" class="router-link-active router-link-exact-active toc-link level3">4. 方案3</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-参考-1" class="router-link-active router-link-exact-active toc-link level3">5. 参考</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-分布式缓存" class="router-link-active router-link-exact-active toc-link level2">5. 分布式缓存</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-出现的背景" class="router-link-active router-link-exact-active toc-link level3">1. 出现的背景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分布式缓存特性" class="router-link-active router-link-exact-active toc-link level3">2. 分布式缓存特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-技术选型" class="router-link-active router-link-exact-active toc-link level3">3. 技术选型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-1-中间件选型" class="router-link-active router-link-exact-active toc-link level4">3.1. 中间件选型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-2-组件选型" class="router-link-active router-link-exact-active toc-link level4">3.2. 组件选型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-3-redis基本原理" class="router-link-active router-link-exact-active toc-link level4">3.3. redis基本原理</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-面试题" class="router-link-active router-link-exact-active toc-link level3">4. 面试题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-1-分布式系统中的多级缓存" class="router-link-active router-link-exact-active toc-link level4">4.1. 分布式系统中的多级缓存</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-2-redis如何调优" class="router-link-active router-link-exact-active toc-link level4">4.2. redis如何调优？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-3-七大经典缓存问题" class="router-link-active router-link-exact-active toc-link level4">4.3. 七大经典缓存问题</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-3-1-参考链接" class="router-link-active router-link-exact-active toc-link level5">4.3.1. 参考链接</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-分布式缓存与数据库一致性问题-应用场景" class="router-link-active router-link-exact-active toc-link level3">5. 分布式缓存与数据库一致性问题： 应用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-问题" class="router-link-active router-link-exact-active toc-link level3">6. 问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-设计实现方案" class="router-link-active router-link-exact-active toc-link level3">7. 设计实现方案</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-1-方案一-更新db时-连带更新cache" class="router-link-active router-link-exact-active toc-link level4">7.1. 方案一-更新DB时，连带更新Cache</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-2-方案二-先删除cache-再更新db" class="router-link-active router-link-exact-active toc-link level4">7.2. 方案二-先删除Cache，再更新DB</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-3-方案三-更新db后-删除cache【优选】" class="router-link-active router-link-exact-active toc-link level4">7.3. 方案三-更新DB后，删除Cache【优选】</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-4-方案四-延迟双删" class="router-link-active router-link-exact-active toc-link level4">7.4. 方案四-延迟双删</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-5-方案五-基于消息队列删除cache" class="router-link-active router-link-exact-active toc-link level4">7.5. 方案五-基于消息队列删除Cache</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-6-方案六-强一致性方案" class="router-link-active router-link-exact-active toc-link level4">7.6. 方案六-强一致性方案</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-方案七-read-write-through模式" class="router-link-active router-link-exact-active toc-link level3">8. 方案七-Read/Write Through模式</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-1-方案八-write-behind-模式" class="router-link-active router-link-exact-active toc-link level4">8.1. 方案八-Write Behind 模式</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-总结" class="router-link-active router-link-exact-active toc-link level3">9. 总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-实现过程" class="router-link-active router-link-exact-active toc-link level3">10. 实现过程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-分布式消息" class="router-link-active router-link-exact-active toc-link level2">6. 分布式消息</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-分布式消息常见问题" class="router-link-active router-link-exact-active toc-link level3">1. 分布式消息常见问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-企业级消息队列" class="router-link-active router-link-exact-active toc-link level3">2. 企业级消息队列</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-1-rabbitmq" class="router-link-active router-link-exact-active toc-link level4">2.1. rabbitmq</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-2-rocketmq" class="router-link-active router-link-exact-active toc-link level4">2.2. rocketmq</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-3-kafka" class="router-link-active router-link-exact-active toc-link level4">2.3. kafka</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-生产实践——设备云基于rabbit-mq的消息模型" class="router-link-active router-link-exact-active toc-link level3">3. 生产实践——设备云基于Rabbit MQ的消息模型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-1-消息处理流程" class="router-link-active router-link-exact-active toc-link level4">3.1. 消息处理流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-2-消息丢失" class="router-link-active router-link-exact-active toc-link level4">3.2. 消息丢失</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-3-消息重复消费" class="router-link-active router-link-exact-active toc-link level4">3.3. 消息重复消费</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-4-消息积压" class="router-link-active router-link-exact-active toc-link level4">3.4. 消息积压</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-5-实时命令时序图" class="router-link-active router-link-exact-active toc-link level4">3.5. 实时命令时序图</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-6-异步抄表时序图" class="router-link-active router-link-exact-active toc-link level4">3.6. 异步抄表时序图</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-分布式存储-分库分表" class="router-link-active router-link-exact-active toc-link level2">7. 分布式存储（分库分表）</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-实验" class="router-link-active router-link-exact-active toc-link level3">1. 实验</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_2-分库分表带来的问题及解决方案" class="router-link-active router-link-exact-active toc-link level3">2. 分库分表带来的问题及解决方案</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_3-id" class="router-link-active router-link-exact-active toc-link level3">3. id</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_4-分布式事务" class="router-link-active router-link-exact-active toc-link level3">4. 分布式事务</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_5-跨库查询和分页" class="router-link-active router-link-exact-active toc-link level3">5. 跨库查询和分页</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_6-为什么要分" class="router-link-active router-link-exact-active toc-link level3">6. 为什么要分</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_7-什么时候分" class="router-link-active router-link-exact-active toc-link level3">7. 什么时候分</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-理论基础" class="router-link-active router-link-exact-active toc-link level3">8. 理论基础</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-1-数据切分" class="router-link-active router-link-exact-active toc-link level4">8.1. 数据切分</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-2-分库分表带来的问题及解决方案" class="router-link-active router-link-exact-active toc-link level4">8.2. 分库分表带来的问题及解决方案</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-中间件" class="router-link-active router-link-exact-active toc-link level3">9. 中间件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-实践案例" class="router-link-active router-link-exact-active toc-link level3">10. 实践案例</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_11-分库分表演进过程" class="router-link-active router-link-exact-active toc-link level3">11. 分库分表演进过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_12-参考" class="router-link-active router-link-exact-active toc-link level3">12. 参考</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_8-布式会话" class="router-link-active router-link-exact-active toc-link level2">8. 布式会话</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_1-参考" class="router-link-active router-link-exact-active toc-link level3">1. 参考</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_9-分布式-job" class="router-link-active router-link-exact-active toc-link level2">9. 分布式 Job</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cs-tips/docs/05-distribution/distribution.html#_10-参考" class="router-link-active router-link-exact-active toc-link level2">10. 参考</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="分布式系统" tabindex="-1"><a class="header-anchor" href="#分布式系统" aria-hidden="true">#</a> 分布式系统</h1><ol><li>分布式系统的迭代过程（单体应用-分布式应用）</li><li>分布式系统的特点： 分布性、对等性、自治性、并发性；</li><li>分布式系统的挑战： <strong>由于已经有非常成熟的解决方案，这些成熟的方案已经帮我们屏蔽掉底层所遇到的核心问题，因此我们只需要解决应用层面上的问题即可。事实上，我们只需要解决我们自己项目应用层面的问题和使用这些已有成熟方案的使用上的问题即可。</strong><ol><li>两个讨论的方向： <ol><li>一个是应用层面考虑（功能适用性和经济适用性） <ol><li>功能适用性： 回答能不能满足需求的问题。 <ol><li>性能需求： 三高（高可用、高性能、高并发）、可扩展、易维护；相关衡量指标：QPS、TPS、SLA、资源使用情况（IO、CPU、内存、磁盘）、可监控、可观测、可追踪；</li><li>功能需求：缓存、事务、ID、锁……</li></ol></li><li>经济适用性： 回答花多少钱的问题；人力成本（人+时间）、资源成本；</li></ol></li><li>一个是底层核心层面（NPC）；</li><li>本质上讲是 NPC，具体表现（网络延迟、消息丢失与无序、三态、）；实际上由于我们多是应用层，所以我们要考虑的是 1. 解决应用层所遇到的问题（网络三态、延迟、消息丢失与无序、脑裂问题）；2. 了解中间件系统的解决方案；</li></ol></li><li>本质上讲是 NPC，具体表现（网络延迟、消息丢失与无序、三态、）；实际上由于我们多是应用层，所以我们要考虑的是应用层所遇到的问题（网络三态、延迟、消息丢失与无序、）</li></ol></li><li>分布式系统基本性能需求和相关指标 <ol><li>性能需求： 三高（高可用、高性能、高并发）、可扩展、易维护；</li><li>相关指标：QPS、TPS、SLA、资源使用情况（IO、CPU、内存、磁盘）、可扩展性、可维护性；</li></ol></li><li>分布式系统基础理论： <ol><li>CAP <ol><li>三特性的解决方案 <ol><li>一致性：XA方案、Paxos算法、ZAB算法、Raft算法、一致性 Hash 算法</li><li>可用性：评判标准、心跳检测、异地多活和同城双活、gossip、隔离、限流、负载均衡</li><li>分区容错：日志复制、主备、互备、集群</li></ol></li></ol></li><li>BASE</li></ol></li><li>分布式系统应解决的问题： <ol><li>应用层面（锁、缓存、事务、 消息、 ID、Job、会话）</li><li>治理层面（负载均衡、限流、注册与发现、RPC、监控和报警、链路追踪）</li></ol></li></ol><ul><li><code>分布式</code><ul><li><code>ZK相关内容</code>，数据存储、应用场景、与kafka的关系、相关面试题</li><li>分布式系统的问题</li><li>基本理论（CAP、Base）</li><li>一致性C，XA方案、Paxos算法、ZAB算法、Raft算法、一致性 Hash 算法</li><li>可用性A，评判标准、心跳检测、异地多活和同城双活、gossip、隔离、限流、负载均衡</li><li>容错性P，日志复制、主备、互备、集群</li><li>CP与AP权衡问题，WARO 机制、Quorum 机制</li><li>分布式缓存</li><li>分布式事务（背景、实现方式、优缺点分析、具体实现【seata原理】）</li><li>分布式锁（产生背景、实现方式、优缺点分析）</li><li>分布式ID</li><li>分布式消息</li><li>分布式调度</li><li>分布式服务</li><li>分布式搜索</li><li>分布式会话： 发展历程、各自过程中遇到的问题及解决方案、分布式会话实现方案</li><li>高可用的理解</li><li>高并发的理解</li><li>分库分表</li><li>集群： <ul><li>负载均衡</li><li>一致性Hash等</li></ul></li></ul></li></ul><p>两大块：</p><ol><li>我们自己写的代码，应该怎么实现我们的需求：应用层面（锁、缓存、事务、 消息、 ID、Job、会话）</li><li>我们用的中间件是怎么实现我们的需求的：治理层面（负载均衡、限流与熔断、注册与发现、RPC、监控和报警、链路追踪）</li></ol><h2 id="_1-基础理论" tabindex="-1"><a class="header-anchor" href="#_1-基础理论" aria-hidden="true">#</a> 1. 基础理论</h2><p><a href="https://dunwu.github.io/blog/pages/80055a/" target="_blank" rel="noopener noreferrer">https://dunwu.github.io/blog/pages/80055a/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ul><li>随机负载均衡 <ul><li>策略 - 将请求随机分发到候选服务器</li><li>特点 - 调用量越大，负载越均衡</li><li>适合场景 - 适合服务器硬件相同的场景</li></ul></li><li>轮询负载均衡 <ul><li>策略 - 将请求依次分发到候选服务器</li><li>特点 - 请求完全均匀分发</li><li>场景 - 适合服务器硬件相同的场景</li></ul></li><li>最小活跃数负载均衡 <ul><li>策略 - 将请求分发到连接数/请求数最少的候选服务器</li><li>特点 - 根据候选服务器当前的请求连接数，动态分配</li><li>适合场景 - 适用于对系统负载较为敏感或请求连接时长相差较大的场景</li></ul></li><li>哈希负载均衡 <ul><li>策略 - 根据一个 key （可以是唯一 ID、IP 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</li><li>特点 - 保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失</li><li>适合场景 - 可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</li></ul></li><li>一致性哈希负载均衡 <ul><li>策略 - 相同的请求尽可能落到同一个服务器上。尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</li><li>优点 - 加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</li><li>缺点 - 加减节点会造成哈希环中部分数据无法命中。当使用少量节点时，节点变化将大范围影响哈希环中数据映射，不适合少量数据节点的分布式方案。普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</li><li>适合场景 - 一致性哈希可以很好的解决稳定性问题，可以将所有的存储节点排列在首尾相接的 Hash 环上，每个 key 在计算 Hash 后会顺时针找到临接的存储节点存放。而当有节点加入或退出时，仅影响该节点在 Hash 环上顺时针相邻的后续节点。</li></ul></li></ul><p>nginx 的负载均衡配置项</p><p><a href="https://zhuanlan.zhihu.com/p/152398192" target="_blank" rel="noopener noreferrer">redis限流的3种实现方式<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_1-分布式应用的迭代过程" tabindex="-1"><a class="header-anchor" href="#_1-分布式应用的迭代过程" aria-hidden="true">#</a> 1. 分布式应用的迭代过程</h3><ol><li>软件早期是单体应用，就是把项目中所有涉及到的模块都放在一起；</li><li>但是后期由于业务量的增加，发现数据库先扛不住了，于是就把单体应用变成两层： <ol><li>用于计算的服务层；</li><li>用户存储的存储层；并且存储层逐渐由演化成分库分表的方式；</li></ol></li><li>后来又发现服务层也无法支撑业务需求了，于是就把单个服务变成集群，并且慢慢的把服务也进一步划分划分成小模块；</li></ol><blockquote><p>单体应用（巨石应用）到分布式应用的迭代思想无非就这么几种：</p><ol><li>拆分（垂直拆分+水平拆分）</li><li>冗余（集群、异地多活）</li></ol></blockquote><h3 id="_2-分布式应用的特点" tabindex="-1"><a class="header-anchor" href="#_2-分布式应用的特点" aria-hidden="true">#</a> 2. 分布式应用的特点</h3><ul><li><strong>分布性</strong>： <ul><li>部署随机分布，比如淘宝在北京和上海都部署有机房；</li><li>功能随机分布；比如淘宝的计算节点一部分在北京，一部分在上海；淘宝的存储节点部署在北京，而运算服务部署在上海；</li></ul></li><li><strong>自治性</strong>： 每个节点都包含独属于自己的资源，如 CPU、内存、IO、磁盘等，每个节点对自己的资源进行自行治理的权限。</li><li><strong>并发性</strong>： <ul><li>分布式系统可以支持并发的请求任务。如北京和上海的两个用户同时访问淘宝，淘宝系统会同时为这两个用户提供服务。</li><li>分布式系统内部之间的不同节点会并发的执行任务。如还是两个用户同时访问淘宝，淘宝的负责运算的节点进行运算的同时，可能另外一个存储节点正在执行读取数据的服务。</li></ul></li><li><strong>对等性</strong>： 分布式系统中完成不同功能的主机，在角色上并没有主从之分。例如，部署运算服务的主机和存储服务的主机并没有主从之分，但是在单个功能上有主从之分，如 Mysql 的主从复制部署模型；</li></ul><h3 id="_3-分布式应用遇到的挑战" tabindex="-1"><a class="header-anchor" href="#_3-分布式应用遇到的挑战" aria-hidden="true">#</a> 3. 分布式应用遇到的挑战</h3><blockquote><p>系统复杂度与可用性的非线性关系： 引入一个新的组件，意味着系统的复杂度增加，复杂度增加就意味着可用性降低。</p></blockquote><p><strong>作为 Java 程序员，在分布式应用场景下，已经有非常多的成熟方案，这些成熟的方案已经帮我们屏蔽掉底层所遇到的核心问题，因此我们的关注点就变成了“如何站在巨人肩膀上解决分布式应用的业务问题”。这要求我们不但对自己业务非常了解，同时也要求我们对中间件系统非常了解。</strong></p><p>所以，分布式应用所遇到的挑战主要有两个：</p><ol><li>如何在众多的中间件系统中找到能够满足自己需求的那一款。-&gt; 技术选型。</li><li>找到满足自己需求的那一款之后，如何更好的使用。 把业务系统和中间件系统分开看，中间件系统可以帮我们屏蔽分布式应用中遇到的问题，但是我们的业务系统本身也属于一个分布式应用，同样也会遇到分布式应用中所遇到的各种各样的问题，因此我们就要在实现业务系统考虑并解决这些问题。</li></ol><p>事实上，分布式应用中遇到的问题，本质上可以分成三种：NPC。</p><ul><li><strong>N</strong>etwork Delay：网络延迟。网络延迟、网络三态（超时、失败、成功）</li><li><strong>P</strong>rocess Pause：进程暂停。如 JVM 的 STW。</li><li><strong>C</strong>lock Drift：时钟漂移。如极端情况下，运维人员暴力修改系统时钟时间等。</li></ul><h3 id="_4-如何做技术选型" tabindex="-1"><a class="header-anchor" href="#_4-如何做技术选型" aria-hidden="true">#</a> 4. 如何做技术选型？</h3><p>主要包括以下几个方面：</p><ol><li>经济上：时间成本（学习、开发、运维）、资源成本（服务器资源、运营商的经济成本（机房、网络、电力等资源））</li><li>功能上： <ol><li>性能需求： 最大 TPS、QPS、SLA、网络延迟、占用的服务器资源（包括 CPU、内存、磁盘存储、IO ）等、是否可观测、可维护性、伸缩性、可追踪性、是否支持三高等</li><li>功能需求： 是否满足业务需要</li></ol></li><li>社区活跃度上：越活跃越好，意味着遇到问题可以直接解决；</li><li>已有经验上：是否经历了生产环境验证、经历了怎么样的生产环境的验证等；</li></ol><h3 id="_5-如何更好的使用" tabindex="-1"><a class="header-anchor" href="#_5-如何更好的使用" aria-hidden="true">#</a> 5. 如何更好的使用？</h3><p>主要考虑两方面：</p><ol><li>自己的业务代码中如何更好的使用中间件？</li><li>中间件解决这些业务场景时的原理、优缺点？</li></ol><p><strong>下面问题，可以帮助我们在进行架构设计的时候，考虑的全面些</strong>：</p><ol><li>网络可靠。考虑网络三态的备用方案；</li><li>延迟为零。</li><li>带宽是无限的。</li><li>网络是安全的。</li><li>拓扑不会改变。</li><li>有一个管理员。</li><li>运输成本为零。</li><li>网络是同质的。</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/29433025/1712635691591-bc28c078-6bd7-47a7-8990-509e5d2794b4.png#averageHue=%23e2cc84&amp;clientId=u2a961fab-61bc-4&amp;from=paste&amp;id=EiLc1&amp;originHeight=2667&amp;originWidth=3825&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=1594583&amp;status=done&amp;style=stroke&amp;taskId=ud7098dad-91d1-499f-ab1b-0e6dbc4964c&amp;title=图源：https%3A%2F%2Fdeniseyu.io%2Fart%2F" alt="图源：https://deniseyu.io/art/" tabindex="0" loading="lazy"><figcaption>图源：<a href="https://deniseyu.io/art/" target="_blank" rel="noopener noreferrer">https://deniseyu.io/art/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></figcaption></figure><blockquote><p>✔<a href="https://www.youtube.com/watch?v=uTJvMRR40Ag" target="_blank" rel="noopener noreferrer">视频讲解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>地址在此</p></blockquote><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/29433025/1712758671690-91a6d288-475d-41a4-b871-803a20574c17.png#averageHue=%23fdfef9&amp;clientId=uf420fc0b-5cf9-4&amp;from=paste&amp;id=uab61435d&amp;originHeight=1414&amp;originWidth=2000&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=2009154&amp;status=done&amp;style=stroke&amp;taskId=u139d446d-e9d0-4b46-b5aa-b3aa8374fb4&amp;title=图源：https%3A%2F%2Farchitecturenotes.co%2Ffallacies-of-distributed-systems%2F" alt="图源：https://architecturenotes.co/fallacies-of-distributed-systems/" tabindex="0" loading="lazy"><figcaption>图源：<a href="https://architecturenotes.co/fallacies-of-distributed-systems/" target="_blank" rel="noopener noreferrer">https://architecturenotes.co/fallacies-of-distributed-systems/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></figcaption></figure><h3 id="_6-总结" tabindex="-1"><a class="header-anchor" href="#_6-总结" aria-hidden="true">#</a> 6. 总结</h3><p>分布式应用遇到的挑战就是：</p><ol><li>业务系统在分布式场景下的挑战；【技术选型】</li><li>基础设施系统在分布式场景下的挑战；【选好了如何用】</li></ol><h3 id="_7-理论基础" tabindex="-1"><a class="header-anchor" href="#_7-理论基础" aria-hidden="true">#</a> 7. 理论基础</h3><h3 id="_8-cap-理论" tabindex="-1"><a class="header-anchor" href="#_8-cap-理论" aria-hidden="true">#</a> 8. CAP 理论</h3><h3 id="_9-内容" tabindex="-1"><a class="header-anchor" href="#_9-内容" aria-hidden="true">#</a> 9. 内容：</h3><ol><li><strong>C</strong>onsistency： <strong>一致性</strong>。在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）; XA方案、Paxos算法、ZAB算法、Raft算法、一致性 Hash 算法</li><li><strong>A</strong>vailability： <strong>可用性</strong>。在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）；评判标准、心跳检测、异地多活和同城双活、gossip、隔离、限流、负载均衡</li><li><strong>P</strong>artition tolerance： <strong>分区容错性</strong>。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性， 就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。日志复制、主备、互备、集群</li></ol><figure><img src="https://cdn.nlark.com/yuque/0/2024/png/29433025/1712742108673-5aeffeb2-9b76-4868-9c4b-6e1268cbc9e0.png#averageHue=%237c877d&amp;clientId=u206671b6-84b6-4&amp;from=paste&amp;height=296&amp;id=u84a27650&amp;originHeight=296&amp;originWidth=309&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25716&amp;status=done&amp;style=stroke&amp;taskId=uafedde33-9562-4ed7-a195-6a7a746fff7&amp;title=&amp;width=309" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><strong>一致性</strong>是指“所有节点同时看到相同的数据”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，等同于所有节点拥有数据的最新版本。 <strong>可用性</strong>是指“任何时候，读写都是成功的”，即服务一直可用，而且是正常响应时间。我们平时会看到一些 IT 公司的对外宣传，比如系统稳定性已经做到 3 个 9、4 个 9，即 99.9%、99.99%，这里的 N 个 9 就是对可用性的一个描述，叫做 SLA，即服务水平协议。比如我们说月度 99.95% 的 SLA，则意味着每个月服务出现故障的时间只能占总时间的 0.05%，如果这个月是 30 天，那么就是 21.6 分钟。 <strong>分区容忍性</strong>具体是指“当部分节点出现消息丢失或者分区故障的时候，分布式系统仍然能够继续运行”，即系统容忍网络出现分区，并且在遇到某节点或网络分区之间网络不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。</p><blockquote><p>分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p></blockquote><h3 id="_10-三者之间的关系" tabindex="-1"><a class="header-anchor" href="#_10-三者之间的关系" aria-hidden="true">#</a> 10. 三者之间的关系：</h3><p>在分布式系统中，由于系统的各层拆分，P 是确定的，CAP 的应用模型就是 CP 架构和 AP 架构。分布式系统所关注的，就是在 Partition Tolerance 的前提下，如何实现更好的 A 和更稳定的 C。</p><h3 id="_11-应用" tabindex="-1"><a class="header-anchor" href="#_11-应用" aria-hidden="true">#</a> 11. 应用</h3><p>比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。<strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p><ul><li><strong>ZooKeeper 保证的是 CP。 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</strong></li><li><strong>Eureka 保证的则是 AP。 Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</strong></li><li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li></ul><h3 id="_12-base-理论" tabindex="-1"><a class="header-anchor" href="#_12-base-理论" aria-hidden="true">#</a> 12. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#base-%E7%90%86%E8%AE%BA" target="_blank" rel="noopener noreferrer">BASE 理论<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><a href="https://dl.acm.org/doi/10.1145/1394127.1394128" target="_blank" rel="noopener noreferrer">BASE 理论open in new window<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。</p><h3 id="_13-简介" tabindex="-1"><a class="header-anchor" href="#_13-简介" aria-hidden="true">#</a> 13. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#%E7%AE%80%E4%BB%8B-1" target="_blank" rel="noopener noreferrer">简介<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h3 id="_14-base-理论的核心思想" tabindex="-1"><a class="header-anchor" href="#_14-base-理论的核心思想" aria-hidden="true">#</a> 14. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#base-%E7%90%86%E8%AE%BA%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" target="_blank" rel="noopener noreferrer">BASE 理论的核心思想<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote><p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong><strong>为什么这样说呢？</strong> CAP 理论这节我们也说过了：</p><blockquote><p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p></blockquote><p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p><h3 id="_15-base-理论三要素" tabindex="-1"><a class="header-anchor" href="#_15-base-理论三要素" aria-hidden="true">#</a> 15. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#base-%E7%90%86%E8%AE%BA%E4%B8%89%E8%A6%81%E7%B4%A0" target="_blank" rel="noopener noreferrer">BASE 理论三要素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/29433025/1712760006423-d7f03699-efe2-4a14-bbff-5a280017c618.png#averageHue=%23e9dc7a&amp;clientId=ube629158-9f6e-4&amp;from=paste&amp;id=u3c8ee799&amp;originHeight=461&amp;originWidth=612&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=45153&amp;status=done&amp;style=none&amp;taskId=u5463478c-b567-459c-ad8a-37ff26a021f&amp;title=" alt="image.jpg" loading="lazy"> BASE理论三要素</p><h4 id="_15-1-基本可用" tabindex="-1"><a class="header-anchor" href="#_15-1-基本可用" aria-hidden="true">#</a> 15.1. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%94%A8" target="_blank" rel="noopener noreferrer">基本可用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 <strong>什么叫允许损失部分可用性呢？</strong></p><ul><li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h4 id="_15-2-软状态" tabindex="-1"><a class="header-anchor" href="#_15-2-软状态" aria-hidden="true">#</a> 15.2. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#%E8%BD%AF%E7%8A%B6%E6%80%81" target="_blank" rel="noopener noreferrer">软状态<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h4 id="_15-3-最终一致性" tabindex="-1"><a class="header-anchor" href="#_15-3-最终一致性" aria-hidden="true">#</a> 15.3. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="noopener noreferrer">最终一致性<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><blockquote><p>分布式一致性的 3 种级别：</p><ol><li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ol></blockquote><p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p><p>那实现最终一致性的具体方式是什么呢? <a href="http://gk.link/a/10rZM" target="_blank" rel="noopener noreferrer">《分布式协议与算法实战》open in new window<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 中是这样介绍：</p><blockquote><ul><li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li><li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li><li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul></blockquote><p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p><h3 id="_16-总结" tabindex="-1"><a class="header-anchor" href="#_16-总结" aria-hidden="true">#</a> 16. <a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#%E6%80%BB%E7%BB%93-1" target="_blank" rel="noopener noreferrer">总结<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p><h3 id="_17-常用算法" tabindex="-1"><a class="header-anchor" href="#_17-常用算法" aria-hidden="true">#</a> 17. 常用算法</h3><h4 id="_17-1-paxos" tabindex="-1"><a class="header-anchor" href="#_17-1-paxos" aria-hidden="true">#</a> 17.1. Paxos</h4><ul><li><p>WARO 机制 （Write All Read One）</p><ul><li>更新数据时，需要对集群内所有节点进行更新，所有节点更新完后，读数据时只需要读取其中一个节点就能保证读到最新数据；</li><li>但是这种机制只是保证了读操作的可用性，更新操作的可用性较低，因为只要有一个副本没有更新成功，此次更新操作就失败了；</li></ul></li><li><p>Quorum 机制</p><ul><li>是 WARO 机制在寻求 更新操作 和 读操作 可用性的一种平衡；</li><li>一个集群中具有N个数据副本，如果写操作时，至少要写w个副本，那么读操作时，至少要读取N-W+1个副本，才保证能读到最新的数据；</li></ul></li><li><p>WARO 与 Quorum 区别</p><ul><li>CAP中P是客观存在的，那就需要对C和A进行取舍，多发生在更新所有副本数据的业务场景下；</li><li>WARO 保证了系统具有强一致性（所有的副本数据相同），但是牺牲了可用性（只有所有副本写成功后才算成功，否则就是失败）；</li><li>Quorum 保证了系统具有一致性（但不需要所有的副本数据相同），又兼顾了可用性（只写n个副本，读m-n+1个副本就可以读出更新后的新数据）；</li></ul></li><li><p>Paxos 解决了什么问题？</p><ul><li>解决了分布式系统中数据一致性问题；</li></ul></li><li><p>Paxos 三种角色的各自作用</p><ul><li>Proposer 提案者： 负责提出议案；</li><li>Acceptor 批准者： 负责批准或否决议案；</li><li>Learner 学习者： 负责对外提供读写能力；</li></ul></li><li><p>Paxos 算法过程</p><ul><li>准备阶段 <ul><li>Proposer 带着 生成的全局唯一的提案ID（ ProposalID ） 发送给所有的 Acceptor ；</li><li>Acceptor 收到请求后，判断 ProposalID 是否与之前响应过的所有提案的ID还要大： <ul><li>是： <ul><li>持久化 ProposalID ，并记录为 最大ID（ Max_N ）；</li><li>回复请求，并带上 ProposalID 对应的 value ；</li><li>承诺不会接受 ID值 比 ProposalID 还要小的提案，</li></ul></li><li>否： <ul><li>不回复或回复error</li></ul></li></ul></li></ul></li><li>选举阶段 <ul><li>Proposer 判断 Acceptor 的回复情况： <ul><li>if （（ 回复数量 &gt; 一半的 Acceptor 数量 ） &amp;&amp; （ 所有回复的 value 都为空【这种情况，表明还没有被Accept的提案】 ））： Proposer 带着自己指定的 value 发给 Acceptor ；</li><li>if （（ 回复数量 &gt; 一半的 Acceptor 数量 ） &amp;&amp; （ 有的value不为空 ）） ： Proposer 带上上一步回复的 value 发给 Acceptor；</li><li>if （ 回复数量 &lt; 一半的 Acceptor 数量 ） ： 尝试生成更大的 ProposalID ；</li></ul></li><li>Acceptor 判断收到的 ProposalID 与本地存储的 Max_N 的大小关系： <ul><li>if（ ProposalID &gt;= Max_N） ： 回复提交成功，并持久化 value；</li><li>else ： 不回复或回复失败；</li></ul></li><li>Proposer 统计提交回复结果 ： <ul><li>if （ 回复数量 &gt; 一半的 Acceptor 数量 ） ： 表示提交 value 成功，此时回发送广播给所有的 Proposer 、 learner ，通知它们已提交的 value；</li><li>if （（ 回复数量 &lt;= 一半的 Acceptor 数量 ） || （ 收到一条失败回复 ）） ：  尝试生成更大的 ProposalID ，并转到【准备阶段】；</li></ul></li></ul></li></ul></li><li><p>举例说明</p></li><li><p>Paxos 面试题</p><ul><li>半数以内Acceptor失效怎么办？两种情况 <ul><li>如果失效前还没有确定最终的 value，那就重新竞争提案；</li><li>如果失效前已经确定了最终的 value，说明已经达到共识，那么所有的 Proposer 都以这个 value 作为最终值；</li></ul></li><li>Acceptor 需要接受更大的ProposalID的意义是什么？ <ul><li>有点类似于 DB 中的版本号，数值大的才可以获得权限；目的在于减少阻塞问题的发生；</li></ul></li><li>如何产生唯一的 ProposalID？ <ul><li>只要所有的 ProposalID 是从不相交的数据集中获取即可；</li><li>可以使用机器号+步差，如五个主机，每次递增 1，那么就用主机 id+1 的方式表示；也可以使用 ServerID+时间戳；</li></ul></li></ul></li><li><p>选举阶段： Proposer 发送 （ProposalID，null）给所有的 Acceptor</p><ul><li>Acceptor 判断 ProposalID &gt; 本地已经保存的最大的 ProposalID ：</li><li>是： 返回响应信息，响应信息格式为： （ProposalID，null)</li><li>拿到“所有的请求+本地已保存的ProposalID”中最大的 ProposalID ，并带上这个ProposalID 对应的 value 作为响应信息进行返回；</li></ul></li></ul><h4 id="_17-2-一致性-hash" tabindex="-1"><a class="header-anchor" href="#_17-2-一致性-hash" aria-hidden="true">#</a> 17.2. 一致性 Hash</h4><h5 id="_17-2-1-出现的背景" tabindex="-1"><a class="header-anchor" href="#_17-2-1-出现的背景" aria-hidden="true">#</a> 17.2.1. 出现的背景</h5><p>以redis集群分片为导语，引入集群扩展性问题，引入hash的缺点，继而引入一致性hash。</p><ol><li><a href="https://www.jianshu.com/p/27578e130525" target="_blank" rel="noopener noreferrer">一致性哈希算法(Java实现)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://xiaoflyfish.cn/2022/02/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7Hash/" target="_blank" rel="noopener noreferrer">一致性hash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ol><h3 id="_18-分布式应用的性能指标" tabindex="-1"><a class="header-anchor" href="#_18-分布式应用的性能指标" aria-hidden="true">#</a> 18. 分布式应用的性能指标</h3><p>高可用</p><p>高性能 购买电脑的时候，我们会问这台电脑的性能怎么样，意思就是在问这台电脑用的体验怎么样、硬件设备的支持的特性和能力到底怎么样？ 高性能就是指把整个分布式系统作为一个整体来看，它对外提供给用户的使用体验到底是怎样的。你做一套淘宝系统，我做一套淘宝系统，如果你的系统用户体验比我好，那就可以说你的性能比我的要好。同样的，如果同样的硬件资源，你的也比我的好，那照样可以说你的性能比我的好。主要的衡量指标：同样的业务目标下，资源使用率越小，性能越高。</p><h4 id="_18-1-简介" tabindex="-1"><a class="header-anchor" href="#_18-1-简介" aria-hidden="true">#</a> 18.1. 简介</h4><ol><li>简单的说，高性能（High Performance）就是指<strong>程序处理速度快，所占内存少，cpu占用率低</strong>。</li><li>高并发和高性能是紧密相关的，提高应用的性能，是肯定可以提高系统的并发能力的。</li><li>应用性能优化的时候，对于<strong>计算密集型</strong>和<strong>IO密集型</strong>还是有很大差别，需要分开来考虑。</li><li>增加服务器资源（CPU、内存、服务器数量），绝大部分时候是可以提高应用的并发能力和性能 （前提是应用能够支持多任务并行计算，多服务器分布式计算才行），但也是要避免其中的一些问题，才可以更好的更有效率的利用服务器资源。</li></ol><h4 id="_18-2-提高性能的注意事项" tabindex="-1"><a class="header-anchor" href="#_18-2-提高性能的注意事项" aria-hidden="true">#</a> 18.2. 提高性能的注意事项</h4><ol><li>避免因为<strong>IO阻塞</strong>让CPU闲置，导致CPU的浪费。</li><li>避免<strong>多线程间增加锁</strong>来保证同步，导致并行系统串行化。</li><li>免创建、销毁、维护太多进程、线程，导致操作系统浪费资源在调度上。</li><li>避免分布式系统中多服务器的关联，比如：依赖同一个mysql，程序逻辑中使用<strong>分布式锁</strong>，导致瓶颈在mysql，分布式又变成串行化运算。</li></ol><p>作者：黑爪猫 链接：<a href="https://juejin.cn/post/6844903944955625479" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903944955625479<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>高并发</p><h3 id="_19-参考" tabindex="-1"><a class="header-anchor" href="#_19-参考" aria-hidden="true">#</a> 19. 参考</h3><ol><li><p><a href="https://pdai.tech/md/arch/arch-z-theory.html" target="_blank" rel="noopener noreferrer">分布式系统 - 理论基础,理论及一致性算法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1370391" target="_blank" rel="noopener noreferrer">理解分布式系统的8个谬误<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html" target="_blank" rel="noopener noreferrer">CAP &amp; BASE理论详解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li></li><li></li><li><p><a href="https://www.51cto.com/article/716232.html" target="_blank" rel="noopener noreferrer">分布式系统遇到的十个问题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://www.cnblogs.com/xybaby/p/7787034.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/xybaby/p/7787034.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://juejin.cn/post/6844903944955625479" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903944955625479<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://bbs.huaweicloud.com/blogs/194361" target="_blank" rel="noopener noreferrer">https://bbs.huaweicloud.com/blogs/194361<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p><a href="https://developer.aliyun.com/article/979134" target="_blank" rel="noopener noreferrer">https://developer.aliyun.com/article/979134<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li></ol><h2 id="_2-分布式锁" tabindex="-1"><a class="header-anchor" href="#_2-分布式锁" aria-hidden="true">#</a> 2. 分布式锁</h2><h3 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景" aria-hidden="true">#</a> 1. 背景</h3><p>由于分布式系统中，服务往往是部署到多台服务器上的，这就有可能会产生多台服务器上的服务同时处理一段代码的并发场景；</p><p>此外，在一些特殊的业务场景，如秒杀商品、抢票等高并发业务场景下，同一台服务器上的单个服务实例也有可能要在同一时刻处理多个请求，这也可能会造成同一段代码的并发执行；</p><p>即：</p><ul><li><code>服务多实例并发执行同一段代码；</code></li><li><code>单实例上并发执行同一段代码；</code></li></ul><p>总之，分布式锁产生的背景就是<code>分布式系统中同一段代码被并发执行时会发生不一致性的问题</code>，正是由于要解决这个问题，才出现了分布式锁的解决方案。</p><h3 id="_2-分布式锁具有的特点" tabindex="-1"><a class="header-anchor" href="#_2-分布式锁具有的特点" aria-hidden="true">#</a> 2. 分布式锁具有的特点</h3><ul><li><code>高性能</code>： 要满足高并发的处理场景，不能加了分布式锁之后让系统的并发执行能力下降了；</li><li><code>互斥性</code>： 高并发执行时，同一时刻只能由一个线程来执行加锁的代码，这是最基本的要求；</li><li><code>可重入</code>： 即当一个线程获得分布式锁之后，想要再次获得锁的时候，要还能够再次获得；【只有特殊应用场景中才会遇到】</li><li><code>自动超时释放</code>： 这是为了防止有些线程获得锁之后发生故障没有释放锁，导致其他线程一直拿不到锁，导致死锁的情况；</li><li><code>支持阻塞场景和非阻塞场景</code>： 优秀的分布式锁是支持选择阻塞场景和非阻塞场景的；也就是说，如果选择阻塞场景时，没有获得锁的线程会进行阻塞等待锁的释放；如果选择非阻塞场景，那么没有获得锁的线程会执行其他任务，直到锁释放后以某种机制通知到没有获得锁的线程（zookeeper可以通知没有获得锁的线程来争锁）；</li></ul><h3 id="_3-实现方案" tabindex="-1"><a class="header-anchor" href="#_3-实现方案" aria-hidden="true">#</a> 3. 实现方案</h3><h4 id="_3-1-关系型数据库实现方案" tabindex="-1"><a class="header-anchor" href="#_3-1-关系型数据库实现方案" aria-hidden="true">#</a> 3.1. 关系型数据库实现方案</h4><ul><li>基本原理： <strong>利用数据库的唯一性进行资源锁定</strong>，例如：主键天然具有唯一性，再比如在某一字段上添加索引，并添加unique约束；</li><li>实现：【以唯一索引为例】 1. 创建一个具有 id 、资源名称或方法名称、 失效时间等字段的数据库表； 2. 加锁时，就往这张表中添加一条数据，如果添加成功表示加锁成功，否则加锁不成功； 3. 释放锁时，直接删除这条数据即可</li><li>过程分析 <ul><li>当然如果有可重入场景，那就在数据库的表中多加一个计数字段，用来标识锁被加了几次；这又会导致两次加锁的代码不一样（第一次是insert，后面的都是update计数器）</li><li>如果服务宕机没有释放，可以再额外添加定时器定时删除锁；如果定时器服务发生异常，照样会出现死锁的问题；</li></ul></li><li>优缺点 <ul><li>很难支持高性能（数据库本身吞吐量小、连接池资源也有限）</li><li>需要额外的定时器代码，给系统增加了复杂度；如果定时器服务发生异常，照样会出现死锁的问题；</li><li>需要较为复杂的代码来控制可重入性，即便是添加一个计数器字段，但是加锁代码就不一样了；</li></ul></li><li>总结 <ul><li><code>生产环境下不会使用这种方式</code></li></ul></li></ul><h4 id="_3-2-redis实现方案" tabindex="-1"><a class="header-anchor" href="#_3-2-redis实现方案" aria-hidden="true">#</a> 3.2. redis实现方案</h4><ul><li>演进过程 <ul><li>setnx <ul><li>原理： 早期版本，只有setnx可以使用，利用set如果存在就set不成功的原理，加锁时，setnx一个key，释放锁时，把key删除即可；</li><li>问题： 没有加过期时间，如果某一个获得锁的线程执行任务过程中突然宕机，那这个key可能就永远不能被删除了，也就是分布式锁无法被释放；</li></ul></li><li>setnx key value px X nx <ul><li>原理： 利用setnx的原子性，加锁时同时给key设置一个过期时间，这样可以解决分布式锁无法被释放的问题了；</li><li>问题： <ul><li>释放锁时使用del命令删除，但是无法确定删除的锁是否是自己上的锁；</li></ul></li></ul></li><li>释放锁时比对key-value是否是自己设置的 <ul><li>原理： 比对key和value是否是自己设置的，如果是就进行删除，否则不能删除；</li><li>问题： 获取key的过程、比对key和删除key的过程不具有原子性，可能导致误删</li></ul></li><li>Lua脚本比对+删除 <ul><li>原理： 利用lua脚本把多个命令合并执行的原理；</li><li>问题： 过期时间设置可能不够合理，假如一个线程执行任务时间超过设置的过期时间，就会产生任务还没有执行完，锁就被释放的问题；</li></ul></li></ul></li><li>总结 <ul><li><code>在早期分布式锁的版本中会使用这种方案</code></li></ul></li></ul><h4 id="_3-3-redlock实现" tabindex="-1"><a class="header-anchor" href="#_3-3-redlock实现" aria-hidden="true">#</a> 3.3. redlock实现</h4><ul><li>环境： <strong>多台独立部署的redis</strong>（如果使用集群方式，整个redis就相当于一个redis实例，因为其数据是均匀分布的；如果采用哨兵模式，这种方式只是为了提高系统的可用性）</li><li>原理 <ul><li>当且仅当半数以上节点加锁成功 &amp;&amp; 每一个节点加锁使用的时间都小于锁失效的时间 ： 加锁成功</li><li>否则： 依次删除所有节点上的锁</li><li>放锁： 依次删除所有节点上的锁</li></ul></li><li>缺点 <ul><li>理论性的内容，没有具体实现的框架，</li><li>手动实现时，需要有独立部署的redis集群，部署环境要求过高；</li><li>网络延迟对锁的超时释放时间影响过大；</li><li>实现起来有点复杂；</li><li><code>不能解决可重入性问题；</code></li></ul></li><li>总结 <ul><li><code>生产环境下也不会使用这种方式</code></li></ul></li></ul><p>伪代码实现</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int count;
for(int i=0; i&lt;nodeNum; i++){
  if(
    set(key, value, expireTime, nx, node[i]) == 1
    &amp;&amp; expireTime &gt; (getLockEndTime-getLockStartTime)
  ){
    count++; // 统计加锁成功的节点个数
  } else
}

if(count &gt; 0.5*nodeNum){
  // 表明加锁成功
  // 执行业务操作
  
}

// 业务执行完成 或 没有加锁成功，就删除所有key
for(int i=0; i&lt;nodeNum; i++){
  del(key, node[i]);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-4-zk实现方案" tabindex="-1"><a class="header-anchor" href="#_3-4-zk实现方案" aria-hidden="true">#</a> 3.4. zk实现方案</h4><ul><li>基本原理 <ul><li>利用 ZooKeeper 支持临时顺序节点的特性</li><li>利用 watch 事件监听变更消息，可以实现非阻塞式分布式锁</li></ul></li><li>实现过程 <ul><li>客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；</li><li>其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</li><li>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</li><li>完成业务流程后，删除对应的子节点，释放分布式锁。</li></ul></li></ul><p>首先添加Maven依赖：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
    &lt;version&gt;4.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
    &lt;version&gt;4.3.0&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还是一样在需要加锁的地方进行加锁：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@PostMapping(&quot;/purchase&quot;)
    public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId,
                                         @RequestParam(name = &quot;number&quot;) Integer number) throws Exception {
        boolean bool = false;
        //设置重试策略
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);
        // 启动客户端
        client.start();
        InterProcessMutex mutex = new InterProcessMutex(client, &quot;/locks&quot;);
        try {
            //加锁
            if (mutex.acquire(3, TimeUnit.SECONDS)) {
                //调用抢购秒杀service方法
                bool = commodityInfoService.purchaseCommodityInfo(commodityId, number);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //解锁
            mutex.release();
            client.close();
        }
        return bool;
    }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>// todo需要完善</p><h4 id="_3-5-memercached实现方案" tabindex="-1"><a class="header-anchor" href="#_3-5-memercached实现方案" aria-hidden="true">#</a> 3.5. memercached实现方案</h4><p>// todo</p><h4 id="_3-6-生产环境实现方案-小公司" tabindex="-1"><a class="header-anchor" href="#_3-6-生产环境实现方案-小公司" aria-hidden="true">#</a> 3.6. 生产环境实现方案（小公司）</h4><p>小公司由于资金问题，不能像财大气粗的大公司一样部署redis的物理集群，有时候可能就只是一台简单的redis实例，那么这时我们应该怎么使用redis完成分布式锁呢？</p><p>这种方案默认redis不会出现问题。</p><p>解决方案： redis单机+jedis</p><ul><li>加锁时： 使用setnx命令，要同时满足以下几点： <ul><li>一个业务场景使用一个key，换句话来说就是不同的应用场景要用不同的key，这样是为了避免在并发时，不同业务场景的锁误删；</li><li>value最好是唯一的随机数，这样在删除锁的时候可以进行比对，防止误删；</li><li>还要设置过期时间，过期时间要设置的比业务执行时间要稍长，这样防止业务还没有执行完就释放锁的情况发生；</li><li>业务执行时还需要对异常情况进行处理，即便是发生异常，也要对锁进行释放；</li></ul></li><li>释放锁时： <ul><li>释放锁时要使用lua脚本进行释放，在lua脚本中要对key和value进行比对，比对成功才能删除，lua脚本是为了保证比对操作和删除操作是原子性；</li></ul></li></ul><p>那这种情况有没有问题呢？当然是有问题的。因为redis是单机的，所以当redis发生故障无法对外提供服务时，在系统中所有用到分布式锁的场景就都失效了。</p><h4 id="_3-7-生产环境实现方案-大公司" tabindex="-1"><a class="header-anchor" href="#_3-7-生产环境实现方案-大公司" aria-hidden="true">#</a> 3.7. 生产环境实现方案（大公司）</h4><ul><li>基本思路： redisson+集群部署方式（最经济实惠，3主3从，满足高可用、高性能）</li><li>redisson的加锁方式（2种） <ul><li>阻塞式分布式锁： <ul><li>使用方式： lock()，失效时间为30s；</li><li>加锁原理 <ul><li>首次加锁过程（lua加锁+watchdog机制），并在加锁成功之后，开启一个定时任务，这个定时任务默认每隔10s去刷新锁的过期时间，这样防止业务时间执行过长而释放锁的情况，这个定时任务就是watchdog机制</li><li>其他线程加锁（循环等待）</li><li>加过锁的再次加锁（加锁次数加1）【可重入原理】</li></ul></li><li>释放锁原理 <ul><li>正常情况下：加锁次数减1，直到为0时删除改key</li><li>客户端宕机时： watchdog与客户端绑定的，客户端宕机，watchdog也会停止给key自动续期，key就会到时间自动失效；</li></ul></li><li>使用的redis的哪个对象？ <ul><li>hash</li></ul></li></ul></li><li>非阻塞式分布锁锁： <ul><li>使用方式： tryLock()</li><li>加锁原理 <ul><li>lua加锁 +</li></ul></li><li>释放锁原理 <ul><li>超时自动释放</li></ul></li></ul></li></ul></li><li>redisson的其他内容 <ul><li>读写锁</li><li>原子长整型</li><li>信号量和可过期性信号量</li><li>闭锁</li><li>联锁</li><li>红锁</li><li>公平锁</li></ul></li></ul><h3 id="_4-总结-面试题" tabindex="-1"><a class="header-anchor" href="#_4-总结-面试题" aria-hidden="true">#</a> 4. 总结（面试题）</h3><ul><li>分布式锁产生的原因或背景</li><li>分布式锁有哪些实现方案</li><li>redis实现分布式锁的演进过程</li><li>redis使用setnx实现分布式锁时，如果出现锁的假死状况应该如何处理？ <ul><li>所谓假死状态是指业务处理时出现中断，导致获得锁的线程没有自动释放锁，而是因为锁过期自动失效了；</li><li>这种情况本质上还是由于没有估算好业务处理时间与锁失效时间的大小关系 <ul><li>可以让锁失效时间稍微长一些；</li><li>其实，不做任何操作也可以，因为业务执行完成之后反正是要释放锁的</li><li>如果业务处理完成之后还需要获取锁，也是没有关系的，再次申请一下锁即可</li></ul></li></ul></li><li>redlock算法</li><li>redisson分布式锁的基本原理</li><li>redisson的其他应用场景</li><li>什么时候可以选择zk作为分布式锁？</li><li>【开放题】你们项目中分布式锁的技术选型是怎样的？ <ul><li>整个问题可以从几种分布式实现方式的区别、各自的特殊应用场景、团队的学习成本、项目的经济成本与运维成本、社区活跃度等角度回答；</li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。

这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：NPC。

N：Network Delay，网络延迟
P：Process Pause，进程暂停（GC）
C：Clock Drift，时钟漂移

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-参考" tabindex="-1"><a class="header-anchor" href="#_5-参考" aria-hidden="true">#</a> 5. 参考</h3><ul><li></li></ul><p><img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/2b50.svg#height=18&amp;id=qXb33&amp;originHeight=150&amp;originWidth=150&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=18" alt="" loading="lazy"><a href="https://blog.51cto.com/u_15949251/6215363" target="_blank" rel="noopener noreferrer">Spring Boot中使用Redis实现分布式锁 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ul><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/11%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">11 分布式锁有哪些应用场景和实现？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/12%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Redis%20%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">12 如何使用 Redis 快速实现分布式锁？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://my.oschina.net/u/4499317/blog/5039486" target="_blank" rel="noopener noreferrer">Redis 分布式锁｜从青铜到钻石的五种演进方案<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/jackson0714/p/redisson.html" target="_blank" rel="noopener noreferrer">分布式锁中的王者方案-Redisson<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li></li></ul><p><img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/2b50.svg#height=18&amp;id=Mjb6V&amp;originHeight=150&amp;originWidth=150&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=18" alt="" loading="lazy"><a href="https://blog.51cto.com/u_15949251/6215363" target="_blank" rel="noopener noreferrer">Redis分布式锁到底安全吗？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 注意里面关于分布式锁可能失效的场景。</p><hr><p>单机锁： 分布式锁：</p><p>分布式锁核心： 借助一个外部系统，让所有线程都去这个外部系统中获取锁。</p><p>done.</p><h2 id="_3-分布式事务" tabindex="-1"><a class="header-anchor" href="#_3-分布式事务" aria-hidden="true">#</a> 3. 分布式事务</h2><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 需要按照提纲再次整理</label></li></ul><blockquote><p>提纲</p><ol><li>本地事务、全局事务、分布式事务；</li><li>事务特性</li><li>出现分布式事务的业务架构；</li><li>CAP 和 BASE 理论</li><li>为什么分布式事务难？【从技术架构上讲、团队学习成本、性能上（包括吞吐量和运行时间上、给数据库本身造成的影响上）、系统复杂性和可用性上取舍】</li><li>分布式事务理论及实践（2PC、3PC、Seaga、XA、本地事务消息、TCC、AT）</li></ol></blockquote><h3 id="_1-分布式事务" tabindex="-1"><a class="header-anchor" href="#_1-分布式事务" aria-hidden="true">#</a> 1. 分布式事务</h3><p>本文主要从以下几个方面来讲述分布式事务的相关内容：</p><ol><li>分布式事务的背景</li><li>七种分布式方案（<code>XA规范</code>、<code>2PC理论</code>、<code>SAGAS方案</code>、<code>3PC</code>、<code>TCC方案（异步确保型、补偿型）</code>、<code>本地消息表方案</code>、<code>最大努力通知方案</code>、<code>可靠消息最终一致性方案</code>）的原理、优缺点、所出现的问题、适用的场景、技术的细节</li><li>分布式事务Seata的使用</li></ol><p>学习的主要方法是<code>带着问题去学习</code>，具体步骤如下：</p><ol><li>先了解分布式事务出现的背景，要知道一种新的技术或者新的理论的出现，一定是为了解决某个问题而产生的，不可能平白无故产生；</li><li>了解人们在解决分布式事务这个问题的过程中都提出了哪些解决方案，每个解决方案的具体原理是怎样的，这每一个解决方案是否又引入了新的问题，这些新的问题是什么，为了解决这些引入的新的问题，人们又提出了哪些解决方案；</li><li>在实际的生产环境下如何实践分布式事务，不同方案之间的适用场景有哪些；</li></ol><h4 id="_1-1-背景" tabindex="-1"><a class="header-anchor" href="#_1-1-背景" aria-hidden="true">#</a> 1.1. 背景</h4><p>我们先来解释三个名词：</p><ul><li><strong>数据库事务</strong>： 是从数据库层面来解决事务的，它是由实现数据库的具体技术来保证的，比如MySQL的innodb引擎中的事务实现；</li><li><strong>本地事务</strong>： 是由应用程序来保证的。比如一个应用场景中要往A表中插入一条数据，然后再从B表中删除一条数据，此时插入和删除是两条SQL，并且这两条数据都是由应用程序分别发起的，因此要跟数据库交互至少两次，这就没有办法使用数据库事务机制来保证事务了，因此就需要由应用程序来保证事务，于是在Spring中我们可以使用事务注解的形式来保证事务；</li><li><strong>分布式事务</strong>： 则是由更高一层次的事务框架协议来保证；</li></ul><p>为什么会出现分布式事务？分布式事务是出现在分布式系统中的。</p><p>假设有一个业务场景，如<code>流量充值业务</code>，我们系统中有这么几个模块：转账模块、流量管理模块、积分模块，主要的业务场景是：转账成功后，需要修改用户的流量，并修改用户的积分。那在这个流量充值业务中，我们就需要做到这几个操作全部成功，如果遇到异常也要全部失败，不能出现转账成功了，但是流量没有充值成功，也不能出现流量充值成功了，但是积分没有成功，也就是说<strong>要保证这三个操作，要么全部成功，要么全部失败</strong>。那么，这样一个针对不同的数据源的组合操作，就是分布式事务。</p><p>本质上，分布式事务有一个特点： <strong>跨应用程序执行事务操作</strong>。</p><h4 id="_1-2-xa理论" tabindex="-1"><a class="header-anchor" href="#_1-2-xa理论" aria-hidden="true">#</a> 1.2. XA理论</h4><p>起先X/Open组织提出了<strong>一种XA规范，就是一套务虚的理论</strong>。在这个理论中定义了几个角色，</p><ul><li>AP，就是我们的应用；</li><li>TM，就是事务管理器；</li><li>RM，就是资源管理器；</li><li>CRM，就是通信资源管理器，可以理解为消息中间件，但是可以没有。</li></ul><p>其原理基本就是：</p><ol><li>AP告诉TM，说我要发起一个全局事务了；</li><li>然后TM就会往RM中分别发送一条消息，然后RM就进行事务的提交或回滚；</li></ol><p>说白了就是TM定义了一套跟RM进行通信和交互的接口规范，然后通过接口来通知RM，来一块做一下提交或回滚。</p><p>XA理论只是一种务虚的理论，意思就是它提出了一个实现分布式的一个标准而已。</p><h4 id="_1-3-2pc" tabindex="-1"><a class="header-anchor" href="#_1-3-2pc" aria-hidden="true">#</a> 1.3. 2PC</h4><p><strong>2PC理论，就是基于XA规范做的一种具体的实践</strong>，说白了就是两阶段提交，先有一个准备阶段，然后告诉所有的RM，先准备一下，要开始做事务了；然后TM收到消息后开始发起提交阶段的请求，告诉所有的RM，开始提交。但是如果TM在发送准备阶段的提交请求时，收到了某一个RM的异常响应，那么整个事务就立马失败了；如果在提交阶段也收到了RM的异常响应，也会立马失败，然后回滚已经执行的事务。准备阶段实际上是利用了commit和rollback机制，即TM直接发送给所有的RM，让RM执行操作，这个时候可以认为数据库中是已经有数据变更的；在提交阶段，TM根据收到的上一阶段的消息汇总后得出是否允许提交的结论，再去告诉所有的RM执行commit或rollback操作。</p><p>2PC是有问题的，在准备阶段RM收到消息后，会对资源进行锁定，如果下一次收到提交的消息中间有很长时间，这就造成了数据库系统的<code>并发量下降</code>；此外还会出现<code>单点故障</code>的问题，TM是一个单点，如果出现单点故障问题，就完了；此外也会出现<code>状态丢失</code>的情况，如对TM做了备份，在主TM宕机后，重新选举从TM时，之前TM发送的状态，新的TM是不知道的；还会<code>发生脑裂</code>的问题，如果在TM切换过程中，有些RM收到了提交消息，有些没有收到提交消息，这也是不行的。基于这些问题的考量，又引入了3PC理论。</p><p>2PC比较适合单体应用中跨多个库的分布式事务，而且这种方式是严重依赖数据库层面来搞定分布式事务的，并发度很低。但微服务中，我们是不允许微服务交叉访问数据库的，我们一般要求必须通过调用对应的服务来操作服务底层的数据库。</p><h4 id="_1-4-sagas方案" tabindex="-1"><a class="header-anchor" href="#_1-4-sagas方案" aria-hidden="true">#</a> 1.4. SAGAS方案</h4><p>由于2PC阶段中，最后TM通知每一个RM进行提交事务时，如果涉及到很多的操作，那么这个TM的执行操作会很长，因此基于这个问题的解决，又提出了SAGAS方案，其核心思想就是把长事务拆分成短事务。</p><p>这种方案并发度较高，但是需要定义补偿操作，开发量较大，此外次方案一致性较弱，可能会出现一个事务执行成功，另外一个事务执行失败的问题。</p><h4 id="_1-5-3pc" tabindex="-1"><a class="header-anchor" href="#_1-5-3pc" aria-hidden="true">#</a> 1.5. 3PC</h4><p>三阶段提交方案：</p><ul><li>一阶段：TM给RM发送cancommit消息，根据响应消息判断各RM是否正常；</li><li>二阶段：TM给RM发送precommit消息，告知各RM准备相关的sql及请求链接等；</li><li>三阶段：TM给RM发送docommit消息，通知各RM进行提交；</li></ul><p>这个方案解决了2PC方案中的TM异常时会导致整个事务不成功的问题，同时也不会锁定资源很久导致并发度下降的问题。此外，如果TM在第三阶段中发生了异常，事务也是有可能成功的，因为RM会在收到precommit消息后，一段时间后如果TM宕机，RM也会自动提交，因为收到的precommit的消息的响应是正常的。</p><p>但是这种方案也还是有问题的，如果发生脑裂问题进行TM的切换过程中，RM根据超时机制判定TM不可用，自己提交了事务，但是事实上TM切换后是要发送cancel消息的，因此这也是一种问题。</p><h4 id="_1-6-tcc" tabindex="-1"><a class="header-anchor" href="#_1-6-tcc" aria-hidden="true">#</a> 1.6. TCC</h4><p>就是try-confirm-cancel事务机制，在try阶段对转账金额进行锁定，confirm阶段先往本地数据库中插入要锁定的金额的记录，然后调用b银行的扣减金额的接口，再调用c银行的增加金额的接口；cancel阶段就先把c的金额给减掉，然后把b的金额再加回去。通俗一点讲就是try阶段准备各服务所需要的资源或对某些资源进行锁定，confirm就是进行各服务的提交，cancel阶段就是进行补偿，把原来成功的事务进行回滚。</p><p>TCC就是针对要求数据强一致性时才会使用到这种方案，因为这种方案要求写额外的补偿事务的代码，这不利于代码的维护。一般情况下，只有在要求转账这些涉及到钱的一些业务操作时才会使用这种方案，否则，不会采用这种方案的，因为补偿的业务代码非常复杂，也不利于系统的维护。</p><h4 id="_1-7-本地消息表方案" tabindex="-1"><a class="header-anchor" href="#_1-7-本地消息表方案" aria-hidden="true">#</a> 1.7. 本地消息表方案</h4><p>本地消息表方案是国外ebay搞的一套方案，其原理大概是这样的： 1.服务a先往自己本地表中插入一条消息数据，然后执行业务操作，再往mq中发送事务消息； 2.服务b接收到消息后，先去查一下本地消息表中是否有改消息id，如果有就丢弃，如果没有就往自己本地表中插入一条消息数据，然后执行业务操作，完成后更新消息数据，再调用a接口更新a的消息数据状态；</p><figure><img src="/cs-tips/assets/1699929311125-e7b887db.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>假设b没有接收到数据，a也会有一个定时任务，去查自己本地消息表中未处理过的消息数据，然后再发送给mq中让b去处理，重复这个过程直到b调用a的接口完成了a的消息状态的更新。</p><p>但是这种方案严重依赖本地消息表，如果碰到高并发的场景，那应该怎么处理呢？这种场景下肯定是不行的。</p><h4 id="_1-8-最大努力通知方案" tabindex="-1"><a class="header-anchor" href="#_1-8-最大努力通知方案" aria-hidden="true">#</a> 1.8. 最大努力通知方案</h4><p>这种方案是基于本地消息表方案的一种延伸，把写本地消息表的过程也通过mq或内存队列的方式进行削峰，它中间多了一个尽最大努力通知的服务。基本过程是：a服务执行完业务操作后，往mq中发送一条消息，尽最大努力通知服务接收到这条消息后，往本地消息表中添加一条数据，然后调用b服务接口以求完成业务操作，b完成业务操作之后调用尽最大努力通知服务的接口修改本地消息记录的状态。此外，尽最大努力通知服务也会有一个定时任务，会定时查询本地消息表中的消息状态，如果查到未结束的消息，就接着调用b服务接口以完成业务操作，重复n次后就结束。</p><p>这种方式通过引入尽最大努力通知的服务来避免了本地消息表高并发场景下流量高峰的情况，让这个服务单独处理本地事务消息，并通过定时任务的方式尽最大努力通知到另外的服务进行业务动作。</p><h4 id="_1-9-可靠消息最终一致性方案" tabindex="-1"><a class="header-anchor" href="#_1-9-可靠消息最终一致性方案" aria-hidden="true">#</a> 1.9. 可靠消息最终一致性方案</h4><p>这种方式直接把弃用本地消息表，直接使用mq组件的消息事务机制。其基本原理大概是： 1.a服务先发一个prepare消息给mq，如果失败，就直接放弃操作； 2.如果成功，a服务就会进行业务操作，操作完成后，如果操作状态为成功，往mq中发送confirm消息；如果操作状态为失败，就回滚mq中的消息； 3.此时b服务收到mq的confirm消息，然后执行本地业务操作；</p><p>这个过程中有几个问题： 1.如果a服务发了prepare消息给mq，但是没有发送confirm消息，那么mq会轮训prepare消息，然后回调a服务的接口，询问a的业务操作是否成功，a再去查自己的表看业务操作是否成功，如果成功mq自动生成confirm消息，如果失败就回滚消息； 2.如果b服务对同一个confirm消息接收到了多次，那么此时b服务就需要做接口幂等性保证，可以每次执行一个confirm消息就创建一个zk的node节点，消费同一个消息，创建node节点会失败；也可以在每消费一个confirm消息就在redis中添加一个key，每次消费前先去查一下这个key是否存在这两种方案来保证接口幂等性； 3.如果b服务接收到confirm消息后执行失败了，那应该怎么办呢，这需要b服务一直重试，直到成功；或者是通知a进行回滚，再或者是事后通过报警信息、日志信息等进行手动业务补偿。</p><p>这种方式是国内通用的处理方案。或者是基于rocketmq实现，或者是自己基于这种思想实现。</p><h4 id="_1-10-总结" tabindex="-1"><a class="header-anchor" href="#_1-10-总结" aria-hidden="true">#</a> 1.10. 总结</h4><p>不建议在系统中过多使用分布式事务的。因为在真正的业务系统中代码层面造成的bug问题是少之又少的，我们可以采用报警机制、日志记录、快速定位、排查和解决问题、处理数据的方式进行处理这些因为分布式事务造成的问题。因为如果采用分布式事务的方式，代码复杂度肯定会增加，并且由于引入分布式事务造成的代码bug可能会比没有采用分布事务产生的bug还要多。</p><p>我们只需要定期的对出错的数据进行代码人工补偿即可。采用的方式就是写一个补偿程序，对错误数据进行回滚、修复等。</p><p>这种事后人工补偿的方式所花费的成本要少的多得多。</p><figure><img src="/cs-tips/assets/1699929333868-0fbccde3.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h4 id="_1-11-附言" tabindex="-1"><a class="header-anchor" href="#_1-11-附言" aria-hidden="true">#</a> 1.11. 附言</h4><p>分布式事务中除了上述所涉及到的分布式事务以外，还有另外一种不一致的问题：就是当做一些涉及到多个服务模块的组合操作时，我们可以通过上述方式进行分布式事务的控制，分布式事务解决了动作发生时刻所产生的不一致性问题，但是分布式系统中还有一种原因也会造成分布式系统中数据不一致性的问题。那就是，如果a系统和b系统中都存了一些公共信息，而b系统中又是以a系统中的为主，那如果a系统修改了b系统，如果不做任何动作，那么就会造成a系统和b系统的数据不一致性。</p><p>此时的方式大概有三种：</p><blockquote><p>前提：我们在设计分布式系统时，要求每一个微服务只能对应一个数据库，如果一个微服务要修改不属于自己的数据库中的数据，要通过调用其他微服务接口的方式进行修改，坚决不允许直连数据库进行修改。</p></blockquote><ol><li>如果对一致性要求不那么严格，可以使用定时任务的方式：即b系统中设置一个定时任务，通过不断轮询的方式来获取更新，就是通过拿着b系统中的关键信息去a系统中获取数据后再更新到b系统中，但是这种方式需要轮询所有数据（因为不确定那些数据做了修改），再加上如果多个系统都依赖a系统的数据，那么每个依赖系统中都需要设置定时任务，对于开发人员来说补偿的工作量不小。除此以外，在a系统修改数据之后与定时任务执行之前之间数据肯定是不一致的。</li><li>如果对一致性比较严格，还可以采用关键系统异步通知的方式，即a系统修改关键数据时，同时调用b系统接口，通知b系统更新数据。但是这种涉及到a系统的改造工作。当然也可以采用异步通知的方式，即系统中引入消息机制，a系统修改数据时，往消息队列中放松一条消息，然后b系统消费数据即可，但是这种方案由于引入了消息机制，导致系统的复杂度升高，相对应的可用性降低。</li><li>如果对一致性要求非常严格，可以采用只在b系统中保存关键数据的id信息，b系统每次使用a系统中的数据时，就采用调用接口的方式即可。但是这种方式也有问题，即a系统如果出现异常情况，这会造成b系统无法获取到关键数据的其他信息。</li><li>如果是早期系统，在设计时，大多情况都采用第二种方式，异步调用的方式。</li></ol><p>选取准则： 根据不同方式的特点，看业务情况进行选择。</p><h3 id="_2-seata的at、tcc、saga和xa事务模式" tabindex="-1"><a class="header-anchor" href="#_2-seata的at、tcc、saga和xa事务模式" aria-hidden="true">#</a> 2. Seata的AT、TCC、SAGA和XA事务模式</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247494827&amp;idx=1&amp;sn=aa5d7401d53b1ca61b5e49462262bd22&amp;chksm=cea1a360f9d62a761dff15a682f69fcacdd5b70a8afc4e1114cc7f6704b31d9aa3ad82ae5233&amp;token=2092405348&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">阿里终面：分布式事务原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;mid=2247544315&amp;idx=1&amp;sn=1918fe3e5435e2ffd88aa29b76c2e35b&amp;source=41#wechat_redirect" target="_blank" rel="noopener noreferrer">聊一聊分布式事务<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://juejin.cn/post/6867040340797292558" target="_blank" rel="noopener noreferrer">消息队列之事务消息，RocketMQ 和 Kafka 是如何做的？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://jeremyxu2010.github.io/2020/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/#heading-3" target="_blank" rel="noopener noreferrer">微服务中的分布式事务方案<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li></li></ul><p>本地事务： 全局事务： 分支事务：</p><figure><img src="/cs-tips/assets/1699778573935-2df6dc11.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>一个服务操作同一个数据库不同表中的数据；</li><li>一个服务操作不同数据库的不同表中的数据；</li><li></li></ol><p>分布式事务实现时应该关注的要点有哪些？</p><ol><li>应用程序层面： <ol><li>最终功能的完成度。考虑是否允许有一定的延时性；</li><li>架构和代码的侵入性。考虑是否需要引入新的组件、组件是否需要额外的服务器资源、引入新组件后对已有业务的影响；</li><li>性能。 <ol><li>吞吐量。原则上是要求分布式事务的实现不能降低系统的吞吐量，不能说同一个系统的接口的 QPS 相差过多，比如使用了分布式事务之后不能和之前没有使用分布式事务的接口的 QPS 相差一个量级，如果差了一个量级，就要考虑引入分布式事务的必要性；这个考虑点主要是看分布式事务中各个事务分支是否能够支持异步等。</li><li>耗时时间。同样，也不能过多的增加耗时时间，这个指标要根据软件质量要求标准可适当取舍。</li><li>并发性能。同样，也需要根据软件质量要求，适当取舍。这个考虑点主要是看分布式事务中各个事务分支是否能够支持异步等。</li></ol></li></ol></li><li>数据库层面： <ol><li>是否支持异构的数据库存储技术；</li><li>数据库并发性能；</li></ol></li><li>整体架构层面： <ol><li>引入组件带来的复杂性提升、可用性降低、需要额外的维护成本；</li><li>技术人员的学习成本等；</li></ol></li></ol><p>事务性提交 系统高可用 数据最终一致性 支持服务独立演化和部署 支持服务使用异构的数据存储技术 架构侵入性低，易于采用 支持同步和异步流程 支持事务步骤依赖</p><p>done.</p><h2 id="_4-分布式-id" tabindex="-1"><a class="header-anchor" href="#_4-分布式-id" aria-hidden="true">#</a> 4. 分布式 ID</h2><h3 id="_1-主键id" tabindex="-1"><a class="header-anchor" href="#_1-主键id" aria-hidden="true">#</a> 1. 主键ID</h3><p>分库分表后原有主键ID失效，需要改造主键ID。</p><h3 id="_2-方案1" tabindex="-1"><a class="header-anchor" href="#_2-方案1" aria-hidden="true">#</a> 2. 方案1</h3><p>jdk中自带的UUID</p><ul><li>好处： <ul><li>不用引入额外的jar</li></ul></li><li>坏处： <ul><li>更占用内存。</li><li>不适合作为mysql的主键。 <ul><li>无序性会导致磁盘随机IO、数据叶分裂；</li><li>普通索引需要存储主键值，会导致B+树增高，IO次数变多；</li></ul></li><li>基于mac的地址算法会导致mac地址泄漏。</li></ul></li></ul><h3 id="_3-方案2" tabindex="-1"><a class="header-anchor" href="#_3-方案2" aria-hidden="true">#</a> 3. 方案2</h3><p>雪花算法</p><ul><li><h2 id="好处" tabindex="-1"><a class="header-anchor" href="#好处" aria-hidden="true">#</a> 好处</h2></li><li><h2 id="坏处" tabindex="-1"><a class="header-anchor" href="#坏处" aria-hidden="true">#</a> 坏处</h2></li></ul><h3 id="_4-方案3" tabindex="-1"><a class="header-anchor" href="#_4-方案3" aria-hidden="true">#</a> 4. 方案3</h3><p>号段模式——美团的Leaf</p><h3 id="_5-参考-1" tabindex="-1"><a class="header-anchor" href="#_5-参考-1" aria-hidden="true">#</a> 5. 参考</h3><ul><li><a href="https://chenjiabing666.github.io/2021/08/15/5%E7%A7%8D%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F/" target="_blank" rel="noopener noreferrer">5种全局ID生成方式、优缺点及改进方案，你知道哪几种？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p><a href="https://mp.weixin.qq.com/s/XJbWqSMloUXOl0DGbHw_og" target="_blank" rel="noopener noreferrer">集群高并发环境下，如何保证分布式唯一全局ID生成？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_5-分布式缓存" tabindex="-1"><a class="header-anchor" href="#_5-分布式缓存" aria-hidden="true">#</a> 5. 分布式缓存</h2><p>// TODO： 与Redis章节中的生产问题重复，考虑此篇文章的处理方式。</p><h3 id="_1-出现的背景" tabindex="-1"><a class="header-anchor" href="#_1-出现的背景" aria-hidden="true">#</a> 1. 出现的背景</h3><p>进程内缓存 -&gt; 单实例的进程间缓存（本地缓存） -&gt; 分布式缓存</p><p>关于 本地缓存 ： 请参考笔者的另外一篇文章： Java中的本地缓存。获取更多内容可以关注笔者微信公众号：天晴小猪（WeChatID： zeanzai-me），也可以扫描文章底部的二维码进行关注。</p><h3 id="_2-分布式缓存特性" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存特性" aria-hidden="true">#</a> 2. 分布式缓存特性</h3><ul><li>高性能</li><li>高可扩展</li><li>高可用</li><li>高并发</li><li>故障自动转移</li><li>负载均衡</li><li>[optional]支持事务和持久化</li></ul><h3 id="_3-技术选型" tabindex="-1"><a class="header-anchor" href="#_3-技术选型" aria-hidden="true">#</a> 3. 技术选型</h3><p>关于 <code>如何进行技术选型</code> 请参考笔者的另外一篇文章： 技术选型。获取更多内容可以关注笔者微信公众号：天晴小猪（WeChatID： <code>zeanzai-me</code>），也可以扫描文章底部的二维码进行关注。</p><h4 id="_3-1-中间件选型" tabindex="-1"><a class="header-anchor" href="#_3-1-中间件选型" aria-hidden="true">#</a> 3.1. 中间件选型</h4><p>redis memecached</p><h4 id="_3-2-组件选型" tabindex="-1"><a class="header-anchor" href="#_3-2-组件选型" aria-hidden="true">#</a> 3.2. 组件选型</h4><p>jedis RedisTemplate lettuce Redisson</p><h4 id="_3-3-redis基本原理" tabindex="-1"><a class="header-anchor" href="#_3-3-redis基本原理" aria-hidden="true">#</a> 3.3. redis基本原理</h4><p>请参考笔者的另外一篇文章： <a href="/cs-tips/docs/05-distribution/distribution/middleware/redis.html" class="">Redis基本原理</a>。获取更多内容可以关注笔者微信公众号：天晴小猪（WeChatID： <code>zeanzai-me</code>），也可以扫描文章底部的二维码进行关注。</p><h3 id="_4-面试题" tabindex="-1"><a class="header-anchor" href="#_4-面试题" aria-hidden="true">#</a> 4. 面试题</h3><h4 id="_4-1-分布式系统中的多级缓存" tabindex="-1"><a class="header-anchor" href="#_4-1-分布式系统中的多级缓存" aria-hidden="true">#</a> 4.1. 分布式系统中的多级缓存</h4><h4 id="_4-2-redis如何调优" tabindex="-1"><a class="header-anchor" href="#_4-2-redis如何调优" aria-hidden="true">#</a> 4.2. redis如何调优？</h4><p>这个问题的另一个问法： 在不增加机器和不淘汰key的情况下，如何优化redis的存储空间？</p><h4 id="_4-3-七大经典缓存问题" tabindex="-1"><a class="header-anchor" href="#_4-3-七大经典缓存问题" aria-hidden="true">#</a> 4.3. 七大经典缓存问题</h4><ul><li><code>缓存失效</code><ul><li>解释： 系统由于预热，把一批数据加载到缓存中，但是由于对缓存时间考虑不周，导致后期缓存在某一个时间节点突然集体失效，系统大量请求全部打在数据库上，造成数据库压力过大甚至宕机；</li><li>解决方案： 既然缓存实效是因为key的失效时间设置的不合理，那么解决这个问题也要从key的失效时间下手，我们可以让key的失效时间=原定的失效时间+随机时间，这样的话，key就不会集中失效了。</li></ul></li><li><code>缓存雪崩</code><ul><li>解释： 就是由于突然缓存所在机器出现问题（可能是大流量打死其中的n个节点、大流量导致网卡异常），导致所有的请求直接打到了mysql库上去，造成mysql也被瞬间打死。（所谓雪崩就是服务与服务之间造成了级联故障，换句话就是一个服务死机导致了另外一个服务扛不住压力也死机了。）</li><li>处理方案： 中心思想就是防止redis被打死+应用程序限流熔断+应用程序提高响应能力，可分为两部分。在缓存部分，redis需要配置高可用+持久化+告警机制，高可用可以采用主从、哨兵、集群、异地多活等方式，持久化机制可以开启AOF、RDB、混合模式以便于在故障恢复后快速加载数据，告警机制可以人工提前介入进行动态扩容等；在应用程序部分，可以采用限流+熔断+本地缓存的方案；</li></ul></li><li><code>缓存穿透</code><ul><li>解释： 就是多次请求缓存中没有的数据，导致直接查询数据库，导致数据库被打死；</li><li>解决方案： <ul><li>方案一： 如果从数据库中查询的结果为空，就在缓存中set一个值，再加上一个过期时间，这样就可以把请求拦截到缓存上，从而避免数据库被打死；但这种方式也有另外一个问题就是key如果很多，就会造成缓存的命中率下降，这时我们要定期清理key，或者将这些非法的key存入一个独立的公共缓存中，每次查询时先查询主缓存，如果不存在就查询独立缓存，再不存在就查询数据库，如果mysql返回结果为空，就把kv设置到独立缓存中，否则就放到主缓存中；</li><li>方案二： 使用 Bloomfilter 来缓存全量的key，利用了 Bloomfilter 的位图数据结构特性，如果为ture，就一定存在，如果为false，不一定存在的特性；不过key的数量级要控制在10亿以内，大概占用1.2g缓存，又因为key越多误判率越高，因此还要定期清理key；</li></ul></li></ul></li><li><code>缓存击穿</code><ul><li>解释： 击穿的意思有点像在一道屏障上穿了一个孔。就是某一个key的访问非常频繁，但是某一个时刻，这个key突然失效，导致获取这个key的请求直接穿过缓存请求到数据库。</li><li>处理方案： 中心思想是对热点key的处理。 针对基本不会发生更新的场景，可以把key设置为永不过期，让key常驻缓存；针对偶尔需要更新的场景，可以对请求代码使用分布式互斥锁，是的少部分直接请求请求数据库后更新缓存，而剩余的其他请求直接使用新缓存即可，或者采用本地互斥锁保证仅有少量请求能够更新缓存，其余请求访问新缓存； 针对需要频繁更新的场景，可以使用额外的补偿程序来定时刷新缓存或者延长key的实效时间；</li></ul></li><li><code>如何保证缓存与数据库双写一致性？</code><ul><li>解释： 在使用缓存时，往往是数据库中保存着一份数据，而缓存中也保存着一份数据，这就涉及到数据库与缓存中数据的一致性问题</li><li>处理方案： <ul><li>方案一： 使用 Cache Aside 模式，就是在读缓存的时候，先读缓存，如果缓存中没有读到，那就读数据库，然后把读到的数据再放入缓存中，最后返回响应；更新操作时，就先更新数据库，然后再删除缓存；【更新操作是有问题的，下面会讲到】； <ul><li>优缺点： 这种方案使用了懒加载的思想，适用于数据一致性要求较高的业务场景，或者缓存更新较为复杂的业务场景； 但是这种方案需要同时关注cache和db的数据变更，有些繁琐；</li><li>更新操作为什么是删除缓存而不是更新缓存？ <ul><li>这里涉及到懒加载的思想，事实上，更新缓存的性能损耗要大于删除缓存的性能损耗，如果读操作不多，那每次都要更新缓存所带来的性能损耗一定大于删除缓存的性能损耗，让第一次读操作从数据库中获取数据后更新缓存，之后所有的读操作直接请求缓存，性能损耗就会大幅度下降；</li></ul></li><li>如果更新操作时，先更新数据库，然后删除缓存，如果缓存删除失败呢？ <ul><li>这同样会造成缓存与数据库不一致。解决办法就是先删除缓存，然后更新数据库。这样读操作时，如果缓存为空，就去读数据库，然后更新缓存，虽然读到的数据是旧数据，但是缓存更新后也是旧数据，就保证缓存与数据库一致了。</li></ul></li><li>如果更新操作时，瞬间有大量请求发送过来，会造成什么情况？仍然会造成缓存与数据库不一致问题。 <ul><li>因为一个更新请求过来，我们先执行删除缓存，然后更新数据库，但是在删除缓存之后还没有来得及更新数据库，另一个读请求也过来了，然后它发现缓存中没有数据，它就先去数据库中读取数据然后再更新到缓存，这时之前的更新请求再更新数据库，此时缓存和数据库不一致了【这个问题的本质原因是高并发请求和更新单个key】。解决方案是： 可以根据key的唯一性标识把相同参数的请求路由到同一台机器上，然后创建JVM内部队列，使更新操作放入一个队列，读操作也放入一个队列。目的是hang住读操作一些时间，等更新操作完成之后再进行读操作。但这种方式有可能会造成读操作的时间过长并且还有可能会造成某个单台机器负载过高的情况，这个时候要严格执行性能测试，一方面要看一下这种方式下读操作请求时长是否是可以忍受的，如果不可忍受，那就只能加机器；但单台机器负载过高的情况不可避免；</li></ul></li></ul></li><li>方案二： 使用 Read/Write Through 模式，就是提供一个存储服务，查询数据和修改数据都通过这个服务来完成，这样可以屏蔽对数据的访问细节，在存储服务内部，针对查询数据的操作，可以直接去cache中查询，如果不存在就去db中查询，然后回种到cache中后返回，针对写数据的操作，先去查询cache，如果key存在，就更新缓存再更新db，如果缓存中key不存在就只更新db； <ul><li>优缺点： 这种方案使用起来更加方便，因为它提供了一套操作cache和db的API，等同于封装了cache和db的操作细节，使业务系统不必关注cache和db的读写操作实现；此外，由于同样适用了懒加载方式，使得这种方式也适用于数据有冷热区分的业务场景；</li><li>更新操作是怎么实现的？ <ul><li>是通过cas算法实现的，这样利用了算法锁的方式避免了高并发带来的问题；</li></ul></li></ul></li><li>方案三： 使用 Write Behind Caching 模式，这种模式跟 方案二 模式差不多，都是提供了一个存储服务，封装对cache和db的操作细节，让外部业务系统无感知的访问缓存。在其内部，读操作的实现原理与 方案二 是一样的，同样是先去cache中读，如果cache中不存在，就去db中读取，然后回种到cache后返回；与方案二不同的是更新操作的实现原理， 这种方案的更新操作是只更新cache，并提供异步批量的方案来根据cache来更新db； <ul><li>优缺点： 这种方案的写性能是最大的，但是数据不一致性发生的几率最大，极端场景下可能会丢失数据，因此这种方案适合写合并的场景，比如微博的点赞数量，如果采用方案二，那势必是点赞一次就需要写db一次，这对db是很大压力的，在方案三中，可以点赞到1w后再写db，这样db压力就大大减小了；</li></ul></li></ul></li><li>如何选择？ <ul><li>高性能与强一致性本来就不可兼得，不同模式的选择就是针对高并发与强一致性的取舍；</li><li>不存在最佳方案，只有最符合业务场景的方案；</li></ul></li></ul></li><li><code>热点key</code><ul><li>解释： 某些业务在某一瞬间或某一时间段内可能会成为热点业务，热点业务的数据可能会产生热点key，比如微博上热榜数据；</li><li>方案： 先找出哪些key是热点key，可以通过spark的流计算或Hadoop的批处理来得出热点key，然后中心思想就是把这些热点key打散到不同的节点中以应付高并发请求；总的实现方案有加入二级缓存和加冗余节点，这个问题的关键在于如何发现热点key，4.0之后，可以使用 redis-cli --hotkeys 命令获取；业内著名处理方案有<a href="https://tech.youzan.com/tmc/" target="_blank" rel="noopener noreferrer">有赞透明多级缓存解决方案（TMC）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></li><li><code>大key</code><ul><li>解释： 缓存中某些key的value的值过大，导致写操作超时、加载速度缓慢等问题；</li><li>方案： 主要的处理思路是先找出哪些key是大key，然后再对大key进行操作； <ul><li>如何找到大key？ <ul><li>使用报警机制可以查看带宽与qps的关系，来判断是否有大key产生；</li><li>利用 redis-cli --bigkeys 命令可以异步获取大key</li><li>使用 redis-rdb-tools 离线分析工具来扫描RDB持久化文件</li></ul></li><li>找到大key后如何处理大key？ <ul><li>可删除： <ul><li>小于4.0， 使用 scan 命令扫描出key后进行删除</li><li>大于4.0， 使用 UNLINK 命令异步删除</li></ul></li><li>不可删除： <ul><li>value 是 string，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗； 如果压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取；</li><li>value 是 list/set 等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片；</li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="_4-3-1-参考链接" tabindex="-1"><a class="header-anchor" href="#_4-3-1-参考链接" aria-hidden="true">#</a> 4.3.1. 参考链接</h5><ul><li><a href="https://www.jianshu.com/p/50c0894c0a19" target="_blank" rel="noopener noreferrer">如何解决Redis大key问题，看这一篇就够了!<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/473930220" target="_blank" rel="noopener noreferrer">解决了Redis大key问题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C/06%20Hot%20Key%E5%92%8CBig%20Key%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%BA%94%E5%AF%B9%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">06 Hot Key和Big Key引发的问题怎么应对？.md<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li>13的面试突击课程</li></ul><h3 id="_5-分布式缓存与数据库一致性问题-应用场景" tabindex="-1"><a class="header-anchor" href="#_5-分布式缓存与数据库一致性问题-应用场景" aria-hidden="true">#</a> 5. 分布式缓存与数据库一致性问题： 应用场景</h3><p>企业网银中，在客户管理等公共模块中，客户等热点信息需要被多个微服务模块所使用，如果直接从MySQL中读取，有点浪费MySQL服务器性能。于是放入缓存，但是客户信息也会被客户修改，这就造成了其他微服务读取到的数据与实际的数据不一致。</p><p>其他微服务使用时，通过调用客户管理模块中的接口进行获取，先读缓存，缓存中不存在就读db。</p><h3 id="_6-问题" tabindex="-1"><a class="header-anchor" href="#_6-问题" aria-hidden="true">#</a> 6. 问题</h3><p>为什么会出现双写不一致问题？本质是在并发读写过程中，操作DB的动作与操作Cache的动作不具有原子性。换句话来说，就是在高并发场景下，无法保证操作DB的动作与操作Cache的动作同时成功或同时失败，也就是说可能会有中间状态。因此，只要使用缓存，就会涉及到缓存中数据与数据库中实际数据的一致性问题。 实际业务中，写操作和读操作是两套不相关的代码逻辑。因此我们分别讨论读操作和写操作的代码逻辑。</p><p>读操作，分为两种，延迟加载和预加载。</p><ol><li>延迟加载，即用到数据时，才从DB中加载到缓存中。这种方式是我们常用的方式。</li><li>预加载，即应用程序启动时，就把数据加载到缓存中。这种场景适用于变更极少的数据，如配置项、数据字典等。</li></ol><p>写操作，主要是更新数据和删除数据。更新数据时，为保证DB和Cache的数据一致性，既需要更新DB，又需要更新Cache；删除数据时，则需要删除DB和删除Cache。因此我们可以知道，写操作无论如何都需要同时操作DB和Cache，但是代码实现时，操作DB和操作Cache并不具备原子性，即<strong>无法同时保证DB的操作和Cache的操作同时成功或同时失败</strong>。不具备原子性，就意味着会造成DB和Cache数据不一致性问题。因此为了解决数据不一致性问题，我们首先想到的是让两个操作具备原子性，那么此时我们可以采用分布式锁的方式，让操作DB的动作和操作Cache的动作组合成一个原子操作，可是采用分布式锁，势必会降低缓存的性能，而我们之所以使用Cache的原因就是想利用Cache的高性能特性。因此我们首先排除分布式锁的方案。 根据操作DB和操作Cache的时机不同，我们把这个更新数据类型的写操作划分为这么几种：</p><ol><li>先更新Cache，后更新DB；</li><li>先删除Cache，后更新DB；</li><li>先更新DB，后更新Cache；</li><li>先更新DB，后删除Cache；</li></ol><p>我们把删除数据类型的写操作划分为这么几种：</p><ol><li>先删除Cache，再删除DB；</li><li>先删除DB，再删除Cache；</li></ol><p>我们把写操作中的操作DB部分进行合并，则写操作可以分为以下几种：</p><ol><li>先更新Cache（不包括删除），后更新DB（包括删除）。</li><li>先删除Cache，后更新DB（包括删除）。</li><li>先更新DB（包括删除），后更新Cache（不包括删除）。</li><li>先更新DB（包括删除），后删除Cache。</li></ol><p>再从性能的角度分析，如果更新Cache，那么写多读少的场景下，就会出现一个缓存写了好多次才被读到一次，因此更新Cache的方式不可取，所以写操作可以分为两种：</p><ol><li>（<strong>第一种写操作方式</strong>）先删除Cache，后更新DB（包括删除）。</li><li>（<strong>第二种写操作方式</strong>）先更新DB（包括删除），后删除Cache。</li></ol><p>我们<strong>再来研究一下并发读写过程中可能会出现的问题</strong>，并发读写过程可以分为这么几种：</p><ol><li>读-读。即多个线程同时读取。在预加载模式下，读-读操作是不会出现问题的。但是在延迟加载过程中，可能会出现线程A没有在Cache中读到数据，此时，线程B也去Cache中读取数据，也发现没有命中，所以直接去DB中查询，之后放入Cache中。在这个过程中，有可能是线程A写了Cache，紧接着线程B又写一遍Cache，也有可能是线程B先写，紧接着线程A写。但是不管怎样，读取到的数据都是以DB为主的。因此不管是预加载还是延迟加载，数据都是准确的。所以在读-读这种场景下，是不会出现问题的。</li><li>读-写。即线程A进行读操作，而线程B进行写操作，且线程a先于线程b发生，这种场景下也不会出现问题。因为线程A读Cache时，Cache中的数据与DB中的数据一致，线程B进行写操作晚于线程A读操作发生，之后的数据变更与线程A读操作已经无关了，因此这种场景下也不会出现问题。</li><li>写-读。即写操作线程早于读线程发生。这种场景下，结合上面写操作的四种流程进行区分： <ol><li>先删除Cache，后更新DB（包括删除），这种方式在写-读并发操作中会出现DB与Cache不一致问题，写线程早于读线程发生，就意味着先删除Cache后，读线程发现Cache没有命中，就会从DB中获取并放入Cache，之后写线程再执行更新DB（包括删除）操作，此时DB和Cache中的数据就不一致了，如果后续再也没有写操作（包括删除），则有可能不一致性持续到Cache失效，直到再次读缓存才能变得一致；并且写多读少的场景下，可能会涉及到多次删除同一个缓存的情况，这也造成了Cache性能浪费的问题；</li><li>先更新DB（包括删除），后删除Cache，这种场景下，加入读线程发生在更新DB（包括删除）后删除Cache前，由于读取的是Cache，而DB中数据已经更新，如果此时有多个读线程同时发生，那么这些读操作读取的都是老旧数据，因此也会发生短暂不一致问题；这种场景出现的问题与c中出现的问题一致；</li></ol></li><li>写-写。即同时操作同一个数据的多个写操作线程同时发生。这种场景下，也结合上面写操作的四种流程进行区分： <ol><li>先删除Cache，后更新DB（包括删除），也会出现线程A先删除Cache，之后线程B再删除Cache并更新DB（包括删除），最后线程A才更新DB（包括删除），假设线程A是要删除数据，线程B是要修改数据，那么就会造成线程B的更新丢失问题；</li><li>先更新DB（包括删除），后删除Cache，如果线程A先更新DB（包括删除），之后线程B更新DB（包括删除）并删除Cache，最后线程A删除Cache，那么会同样会导致线程A丢失更新问题；</li></ol></li></ol><p>所以总结一下在并发读写过程中出现的问题：</p><ol><li>写-读并发场景下，两种写操作方式都会存在数据不一致现象，极端情况下，第一种写操作方式不一致现象持续的时间可能会比第二种写操作方式持续的时间长；</li><li>写-写并发场景下，两种方式都会出现丢失更新的问题；并且第二种写操作方式还会出现数据不一致现象；</li></ol><p>在实际开发过程中，如果我们能够忍受较短时间的不一致现象，可以直接采用第二种写操作方式（先更新DB，再删除Cache）。</p><h3 id="_7-设计实现方案" tabindex="-1"><a class="header-anchor" href="#_7-设计实现方案" aria-hidden="true">#</a> 7. 设计实现方案</h3><p>根据上面的分析，我们可以知道读操作在并发场景下并不会出现问题。因此我们的主要专注点转为写操作。</p><h4 id="_7-1-方案一-更新db时-连带更新cache" tabindex="-1"><a class="header-anchor" href="#_7-1-方案一-更新db时-连带更新cache" aria-hidden="true">#</a> 7.1. 方案一-更新DB时，连带更新Cache</h4><p>会产生问题：</p><ol><li>**并发写数据时，会出现丢失更新。**在并发场景下，a更新数据后，此时b也要更新同一个值，就会出现a更新db后，b紧接着也要更新db，之后a在更新缓存，在之后b更新缓存。缓存中的数据就不是我们期望的值了。</li><li>**写多读少的情况下，会浪费缓存的性能。**会出现很多缓存刚被更新完还没有被读到一次，就又被更新了。这严重浪费了缓存的性能。</li></ol><figure><img src="/cs-tips/assets/1681882786531-fdee469e.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_7-2-方案二-先删除cache-再更新db" tabindex="-1"><a class="header-anchor" href="#_7-2-方案二-先删除cache-再更新db" aria-hidden="true">#</a> 7.2. 方案二-先删除Cache，再更新DB</h4><p>会产生问题：</p><ol><li>会出现数据不一致问题，甚至会出现较长时间的数据不一致问题。a删除Cache后，b需要读取缓存，此时b发现Cache中没有数据，就会从数据库中读取数据，放入缓存，之后才执行a的更新db的操作，此时缓存中数据就与db中数据不一致了。如果a更新db后，很长一段时间内没有更新操作，不一致性可能会持续到缓存失效。</li></ol><figure><img src="/cs-tips/assets/1681883099946-8f84e5f5.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_7-3-方案三-更新db后-删除cache【优选】" tabindex="-1"><a class="header-anchor" href="#_7-3-方案三-更新db后-删除cache【优选】" aria-hidden="true">#</a> 7.3. 方案三-<strong>更新DB后，删除Cache【优选】</strong></h4><p>会产生问题：</p><ol><li>会出现短暂不一致问题。在a更新db后，删除Cache前，在此期间的所有读操作的数据都是不一致的。</li><li>也可能会出现很长时间的不一致问题。如a更新完db后，删除Cache操作失败了，那么可能需要等到缓存过期，DB和Cache才能保持一致。</li></ol><figure><img src="/cs-tips/assets/1681883351232-b011acd6.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_7-4-方案四-延迟双删" tabindex="-1"><a class="header-anchor" href="#_7-4-方案四-延迟双删" aria-hidden="true">#</a> 7.4. 方案四-延迟双删</h4><p>先删除Cache，再更新DB，之后延迟一段时间后再删除一遍Cache。</p><figure><img src="/cs-tips/assets/1681883336833-ec166581.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>解决了方案二中可能会导致的长时间数据不一致性问题。</p><p>会产生问题：</p><ol><li>读少写多的场景下，会造成性能的浪费。因为每一次写操作，都会操作两次Cache。</li><li>也可能会出现双写不一致问题。极端场景下，第二遍删除Cache时失败，操作效果就退化成方案二了。可以通过多次重试的方式解决这个问题。</li></ol><h4 id="_7-5-方案五-基于消息队列删除cache" tabindex="-1"><a class="header-anchor" href="#_7-5-方案五-基于消息队列删除cache" aria-hidden="true">#</a> 7.5. 方案五-基于消息队列删除Cache</h4><p>先更新DB，再基于队列方式，更新db时构造一个消息，由额外的监听任务更新缓存。但这种方式在更新DB之后和消费消息之前同样会产生短暂不一致现象。</p><p>分为三种方式：</p><ol><li>基于内存队列</li><li>基于消息队列</li><li>基于binlog+消息队列</li></ol><p>基于内存队列的方式，就是把删除操作转化成消息，加入任务队列，之后由异步线程去消费任务，这种方式可以在删除失败时进行多次重试，确保删除成功。这种方式多是采用基于阻塞队列的方式。同时，这种方式也有问题：</p><ol><li>读少写多的场景下，阻塞队列中的任务较多，可能会产生积压，此时可以通过引入多线程机制，加快消费；</li><li>应用的复杂性增高，可用性降低；</li><li>阻塞队列的不可靠造成数据不一致。基于JVM的阻塞队列会随着JVM崩溃而不可用，造成删除操作失败，也会产生数据不一致性；</li></ol><p>基于消息队列的方式，把删除操作转化成消息队列里面的消息，引入高可靠的消息组件，如RocketMQ，这种方式解决了基于内存队列中的JVM崩溃造成的问题。但是：</p><ol><li>要求<strong>使用高可靠的消息组件</strong>，并<strong>开启投递确认机制和消费确认机制</strong>。目的是确保消息不会丢失和消息被正确消费；</li><li>这种方式<strong>增加了写操作的代码复杂度</strong>。虽然让写操作程序不用直接删除Cache，但是需要在更新DB后，需要增加投递删除消息的逻辑，并且还需要额外的消费消息的逻辑；</li></ol><p>基于Binlog+消息队列的方式，这种方式相当于把<strong>删除Cache的操作</strong>委托给<strong>监听Binlog变更程序</strong>、<strong>消息组件</strong>及<strong>消费者监听程序</strong>了。原理是在写入DB后，根据Binlog变更日志，生产消息，再由专门的消费者消费消息。这种方式：</p><ol><li>需要引入额外的逻辑，如解析Binlog变更日志的逻辑，当然可以使用Canal中间件等；</li><li>同样<strong>需要引入高可靠的消息组件</strong>，也同样需要<strong>开启投递确认机制和消费确认机制</strong>；</li></ol><p>优缺点分析：</p><ol><li>这种方式降低了写操作的代码复杂度。让写操作只需要关注更新DB的逻辑；</li><li>引入额外的组件，增加了整个系统的复杂度，降低了整个系统的可用性；</li></ol><h4 id="_7-6-方案六-强一致性方案" tabindex="-1"><a class="header-anchor" href="#_7-6-方案六-强一致性方案" aria-hidden="true">#</a> 7.6. 方案六-强一致性方案</h4><p>中心思想是把写DB和删除Cache这两个原子操作合并成一个原子操作。此过程可以采用具有CP性能的ZK作为分布式锁。也可以使用RedLock作为分布式锁的实现。</p><h3 id="_8-方案七-read-write-through模式" tabindex="-1"><a class="header-anchor" href="#_8-方案七-read-write-through模式" aria-hidden="true">#</a> 8. 方案七-Read/Write Through模式</h3><p>这种方式的使用原理是，提供一个专门用来操作缓存的服务，使用对外提供API接口的方式屏蔽对缓存的操作细节。</p><ol><li>读操作时，先去Cache中查询一下，如果命中就直接返回；如果没有命中，就去DB中查询，之后回种到Cache后返回；</li><li>写操作时，先去Cache中查询一下，如果命中，就先更新Cache，之后再通过CAS并发锁更新DB；如果没有命中，就只通过CAS并发锁更新DB；</li></ol><p>这种方案，屏蔽了Cache和DB读写操作的实现细节。但这种方案依赖一个专门的服务，如果节点发生故障，就会导致读写失败，因此需要集群方式部署才能保证高可用。</p><h4 id="_8-1-方案八-write-behind-模式" tabindex="-1"><a class="header-anchor" href="#_8-1-方案八-write-behind-模式" aria-hidden="true">#</a> 8.1. 方案八-Write Behind 模式</h4><p>这种方式的实现原理是，同样提供一个专门用来操作缓存的服务，使用对外提供API接口的方式屏蔽对缓存的操作细节。</p><ol><li>读操作时，先去Cache中查询一下，如果命中就直接返回；如果没有命中，就去DB中查询，之后回种到Cache后返回；</li><li>写操作时，也需要先去Cache中查询一下： <ol><li>方式一：如果命中，就直接更新；如果没有命中就先去DB中查询，然后根据业务逻辑组装数据并回种到Cache。然后，再利用一个异步周期任务，把Cache数据同步到DB中。这种方式写操作性能最高，相当于数据以Cache为准，适合写合并的业务场景，如点赞数放入Cache，后续定期写DB。</li><li>方式二：如果命中，就直接更新Cache，之后发送更新DB的消息；如果没有命中就先去DB中查询，然后根据业务逻辑组装数据并回种到Cache，最后发送更新DB的消息。然后再利用消息队列的方式，把更新DB的消息解析出来之后变更到DB中。这种方式写性能也还行，但是需要保证消息组件高可用（高可用部署+持久化），还需要开启投递消息的确认机制和消费消息的确认机制。</li></ol></li></ol><h3 id="_9-总结" tabindex="-1"><a class="header-anchor" href="#_9-总结" aria-hidden="true">#</a> 9. 总结</h3><p>不管使用上面的哪一种方案，其实都会出现数据不一致性问题，只不过是数据不一致性问题持续的时间长短问题。结合性能需求和业务场景需要，我们总结出以下生产最佳实践：</p><ol><li><strong>如果数据不一致性问题在可忍受范围内，优先考虑【方案三-更新DB后，删除Cache】；</strong></li><li>考虑其他方案时，要考虑高性能与高可用之间的平衡，因为引入程序的复杂度越高，可用性就越低；</li></ol><h3 id="_10-实现过程" tabindex="-1"><a class="header-anchor" href="#_10-实现过程" aria-hidden="true">#</a> 10. 实现过程</h3><p><a href="https://zeanzai.me/java/distribute/cache.html" target="_blank" rel="noopener noreferrer">13的面试突击课<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://mp.weixin.qq.com/s/8R1zwmH97lOWPwNal-X2XQ" target="_blank" rel="noopener noreferrer">美团2面：如何保障 MySQL 和 Redis 数据一致性？这样答，让面试官爱到 死去活来<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://juejin.cn/post/6945784603508637709" target="_blank" rel="noopener noreferrer">Canal 解决 MySQL 和 Redis 数据同步问题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://www.51cto.com/article/713035.html" target="_blank" rel="noopener noreferrer">不知道这四种缓存模式，敢说懂缓存吗？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://blog.csdn.net/z69183787/article/details/112308815" target="_blank" rel="noopener noreferrer">缓存模式（Cache Aside、Read Through、Write Through、Write Behind）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_6-分布式消息" tabindex="-1"><a class="header-anchor" href="#_6-分布式消息" aria-hidden="true">#</a> 6. 分布式消息</h2><h3 id="_1-分布式消息常见问题" tabindex="-1"><a class="header-anchor" href="#_1-分布式消息常见问题" aria-hidden="true">#</a> 1. 分布式消息常见问题</h3><blockquote><p>互联网技术的产生无非就是系统中遇到了某种问题，而针对这些问题需要得到处理，应运而生就产生了一系列的技术。</p><p>因此，我们在研究一种技术的时候，就要先研究在现有系统中到底遇到了什么问题？解决问题的办法就是这种技术的重要关注点。即问题和解决方案。</p><p>这就是我们学习技术的方法论。下面的学习内容，也是围绕着“问题+解决方案”这个观点去布局和构思的，以后我会不断重申这种观点，以加强记忆和理解。</p></blockquote><ul><li>目前软件系统中遇到了什么困难？</li><li>引入消息中间件后解决了什么问题？ <ul><li>解耦</li><li>异步</li><li>削峰</li></ul></li><li>引入消息中间件之后同时引入了哪些问题？ <ul><li>增加了系统的复杂度</li><li>如果消息中间件整体宕机？</li><li>如果消息重复发送？</li><li>如果消息顺序不对？</li><li>如果结果不一致？（服务a调用b、c、d，依次处理后才算整个操作成功，但是引入消息中间件之后，发现b和c成功了，但是d没有成功，那整个操作应该算是成功能还是失败呢？怎么解决可能出现的这种情况呢？）</li></ul></li><li>消息中间件的选型标准？ <ul><li>吞吐量和topic数量</li><li>开源社区活跃度</li><li>消息的实效性、分布式可用性、消息可靠性（不会丢失消息）</li><li>功能支持是否齐全</li><li>结论总结：rabbitmq和kafka</li></ul></li><li>rabbitmq和kafka <ul><li>Rabbitmq的高可用实现方式？三种方式的区别？</li><li>Kafka的高可用原理？</li></ul></li></ul><hr><ul><li>生产者消费者模型</li></ul><hr><ul><li>消息中间件的使用示例 <ul><li>rabbitmq+SpringBoot使用案例 <ul><li>相关概念</li><li>部署过程</li><li>生产者代码</li><li>消费者代码</li></ul></li><li>kafka+SpringBoot使用案例 <ul><li>相关概念</li><li>部署过程</li><li>生产者代码</li><li>消费者代码</li></ul></li></ul></li></ul><hr><ul><li>MQ中如何保证消息不被重复消费？（如何保证消息的幂等性） <ul><li>问题的描述 <ul><li><code>生产者</code>生产了多条消息，导致消息有多条</li><li><code>消息中间件</code>直接断电了，导致offset没有来得及提交，没有提交但是已经被消费的消息就可能再次被消费</li><li><code>消费者</code>中间的多台主机可能会取到同一条数据，单个消息被多个消费者消费</li></ul></li><li>解决方案 <ul><li>视业务而定，如果业务是写redis，使用set，天然幂等性</li><li>如果是常规业务操作，可以在生产消息时使用全局唯一id，使用这个id作为消息的标识，每次消费时，先去redis中查一下是否有这个id，如果有就说明已经被消费过了，直接丢弃，如果没有，就说明没有被消费过</li></ul></li></ul></li></ul><hr><ul><li>MQ中如何保证消息的可靠性？（如何保证消息不丢失） <ul><li>问题描述 <ul><li><code>生产者导致消息丢失</code>：生产者组装完消息，发送给MQ，紧接着就去处理其他事物了，发送给MQ没有，具体不知道，但是生产者并接着去处理其他事物了，这就造成了到底发送消息了没有这个问题不清楚。这其中可能有网络抖动？生产者处组装完消息正要发送消息时突然宕机？</li><li><code>消息中间件导致消息丢失</code>： <ul><li>针对rabbitmq来说，可能的原因是消息中间件没有开启持久化机制，或者是开启持久化了，但是在开始持久化时，消息中间件宕机了，导致部分消息没有被消费，也没有持久化到磁盘中，那消息中间件再次启动时，就会导致部分消息丢失；此外，如果开启了消息的过期时间，这也会造成消息没有来得及消费，就被废弃，导致消息丢失</li><li>针对kafka来说，可能的原因是某一个broker宕机，重新选举partition的leader时，其他follower还有些数据没有完成同步，此时leader挂掉，在某一个follower成为leader后，就会发现消息丢失</li></ul></li><li><code>消费者导致消息丢失</code>：消费者刚取到消息正准备消费时，还没来得及处理消息，突然进程挂掉了或者重启了，这就导致这条消息丢失了（对于kafka来说，具体的表现就是取到消息后自动提交了offset，kafka认为消费者已经消费过这个消息，但是消费者正要消费时，此时消费者自己挂了，这就会导致这条消息丢失）</li></ul></li><li>解决方案 <ul><li><code>生产者导致消息丢失</code><ul><li>针对rabbitmq，可以使用<code>事务机制</code>和<code>确认机制</code>，区别就是<code>事务机制</code>是同步处理的，这就会导致rabbitmq的吞吐量的下降；<code>确认机制</code>是异步处理的，所以优先选择，确保消息一定会发送给rabbitmq</li><li>针对kafka，同样<code>开启确认机制</code>，当leader收到消息，并把消息同步到所有的follower中后，才认为消息写入成功，否则就进行无限重试</li></ul></li><li><code>消息中间件导致消息丢失</code><ul><li>针对rabbitmq，需要开<code>启持久化机</code>制。除了需要<code>关闭过期时间</code>外，还需要两步走，<code>第一步开启queue的持久化</code>，这样可以保证rabbitmq持久化queue的元数据，当重启时，可以根据持久化文件自动创建queue；<code>第二步开启消息的持久化</code>，消息发送到queue中之后自动会定期持久化到本地磁盘中。这还需要结合确认机制，即当消息确定持久化到本地硬盘后才进行生产者的确认。</li><li></li></ul></li></ul></li></ul></li></ul><p><img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/2b50.svg#height=18&amp;id=Ptc8x&amp;originHeight=150&amp;originWidth=150&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=18" alt="" loading="lazy"><img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/2b50.svg#height=18&amp;id=b03Aa&amp;originHeight=150&amp;originWidth=150&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=18" alt="" loading="lazy"><img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/2b50.svg#height=18&amp;id=YEEr5&amp;originHeight=150&amp;originWidth=150&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=&amp;width=18" alt="" loading="lazy">针对kafka，第一步设置topic的参数<code>replication.factor</code>参数的值大于1，要求每一个partition必须有至少2个副本；第二步设置<code>min.insync.replicas</code>参数，即要求leader感知到至少一个follower还跟自己保持联系，这样才能确保leader挂掉之后还有至少一个follower；第三步设置<code>acks=all</code>，即要求每条消息，必须在写入所有的replicas后才能认为写入成功；第四步设置<code>retries=MAX</code>，即一旦写入失败，就进行无限重试（此时可能会造成阻塞）；<code>（这也是kafka消息零丢失的实现原理）</code> - <code>消费者导致消息丢失</code> - 针对rabbitmq，就是<code>采取确认机制</code>，即消费完消息后调用rabbitmq的确认接口，手动确认消息消费完成，rabbitmq才会把这条消息标记为已消费； - 针对kafka，就是<code>关闭自动提交offset的开关</code>，在处理完消息后<code>手动提交offset</code></p><hr><ul><li>如何保证消息的顺序性？ <ul><li>问题描述 <ul><li>以消息能可靠传入MQ中，并且生产者生产的消息是有序的为前提；又由于存储消息的queue本身就具有先进先出的特性；因此问题主要出现在消费者身上，多是因为：多个消费者同时消费同一个queue，或者是一个消费者多线程消费同一个queue</li></ul></li><li>解决方案 <ul><li>rabbitmq：一个消费者对应一个queue</li><li>kafka： 内部单线程消费</li></ul></li></ul></li></ul><hr><ul><li>如何解决消息积压？ <ul><li>问题描述 <ul><li><code>消息积压</code>：由于消费者故障或者由于消费者调用的外围组件异常（如某一消息要求消费者更新数据库，但是此时数据库发生宕机事故）导致消费者消费消息特别慢，而生产者那边却是按照正常速度进行生产，这就会导致MQ中积压很多的消息；</li><li><code>消息丢失</code>：由于消息积压过多，但是又没有来得及处理，并且消息中间件还设置了过期时间，这还会造成消息丢失的问题；</li></ul></li><li>解决方案 <ul><li>中心思想是分三步走 <ul><li>第一步，要求<code>快速把生产机器上的空间腾出来</code>。可以先临时征用10倍机器，然后写一个用来分发数据的消费者程序，一边接生产环境，一边接临时机器，消费者程序只做消息换手，即从生产环境接到消息，立马放入临时机器；</li><li>第二步，要求<code>快速把腾出来的消息消费掉</code>。可以临时征用其他机器，写一些专门用来消费这些消息的消费者程序，再接上上一步的临时机器进行实打实的消费；</li><li>第三步，<code>进行补偿</code>。如果遇到消息丢失的问题，就要写一个补偿程序，在业务量少的时间（如凌晨三四点时）针对白天的业务数据，重新生成消息</li></ul></li></ul></li></ul></li></ul><hr><ul><li>（开放题）如何设计一个MQ？ <ul><li>考官目的 <ul><li>主要考察候选人的架构设计能力</li></ul></li><li>回答提示 <ul><li>需要考虑MQ得支持可伸缩</li><li>需要考虑MQ得支持可持久化</li><li>需要考虑MQ得支持高可用</li><li>需要考虑MQ消息零丢失</li></ul></li></ul></li></ul><hr><ul><li>总结-方法论 <ul><li>考虑问题可能出现的地方时，主要从生产者消费模型的三个角色来考虑：<code>生产者</code>、<code>消息中间件</code>、<code>消费者</code></li><li>各个角色可能出现的问题无非就是下面的几种情况的组合： <ul><li>软件非正常中断，比如：程序突然卡死、应用程序重启、超过超时时间</li><li>网络不稳定，比如：网络抖动</li><li>硬件设备非正常中断，比如：硬盘突然失效、服务器设备突然断电、网卡设备损坏</li></ul></li><li>考虑解决方案时，就可以从以上各角色可能出现的问题分别考虑</li></ul></li></ul><h3 id="_2-企业级消息队列" tabindex="-1"><a class="header-anchor" href="#_2-企业级消息队列" aria-hidden="true">#</a> 2. 企业级消息队列</h3><h4 id="_2-1-rabbitmq" tabindex="-1"><a class="header-anchor" href="#_2-1-rabbitmq" aria-hidden="true">#</a> 2.1. rabbitmq</h4><blockquote><p>来自: <a href="https://mp.weixin.qq.com/s/KGCER3TWLT6Yk_UwsYJZyA" target="_blank" rel="noopener noreferrer">详细讲解！RabbitMQ防止数据丢失<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 来自: <a href="https://mp.weixin.qq.com/s/RhXe3cF_B3p78I2mEXY9EQ" target="_blank" rel="noopener noreferrer">超详细的RabbitMQ入门<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h4 id="_2-2-rocketmq" tabindex="-1"><a class="header-anchor" href="#_2-2-rocketmq" aria-hidden="true">#</a> 2.2. rocketmq</h4><h4 id="_2-3-kafka" tabindex="-1"><a class="header-anchor" href="#_2-3-kafka" aria-hidden="true">#</a> 2.3. kafka</h4><h3 id="_3-生产实践——设备云基于rabbit-mq的消息模型" tabindex="-1"><a class="header-anchor" href="#_3-生产实践——设备云基于rabbit-mq的消息模型" aria-hidden="true">#</a> 3. 生产实践——设备云基于Rabbit MQ的消息模型</h3><h4 id="_3-1-消息处理流程" tabindex="-1"><a class="header-anchor" href="#_3-1-消息处理流程" aria-hidden="true">#</a> 3.1. 消息处理流程</h4><figure><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29433025/1681705506216-047835a4-66c2-485b-b80e-3bc2b26170d0.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29433025/1681705689399-d00fef9d-5602-405a-9b86-66df9c716e1d.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-2-消息丢失" tabindex="-1"><a class="header-anchor" href="#_3-2-消息丢失" aria-hidden="true">#</a> 3.2. 消息丢失</h4><ol><li>后端没有发送成功： 开启生产者确认机制，当MQ接收到消息后，给后端一个确认信息；</li><li>MQ丢失消息： 开启队列的持久化机制</li><li>主站接收到消息后还没来得及处理消息就宕机了，导致丢失消息： 开启消费者确认机制，后端处理接收到消息，完成业务逻辑处理之后，发送确认信息给MQ，MQ移除消息；</li></ol><h4 id="_3-3-消息重复消费" tabindex="-1"><a class="header-anchor" href="#_3-3-消息重复消费" aria-hidden="true">#</a> 3.3. 消息重复消费</h4><ol><li>在消费消息时，先去db或redis中查询一下是否存在这个消息的id： <ol><li>如果存在则证明已经消费过了，之后直接抛弃这条消息，并发确认信息给MQ，让MQ移除这条消息；</li><li>如果不存在，就处理这条消息，之后发送确认信息给MQ，让MQ移除这条消息，再之后把这条消息的id记录到db或redis中；</li></ol></li></ol><h4 id="_3-4-消息积压" tabindex="-1"><a class="header-anchor" href="#_3-4-消息积压" aria-hidden="true">#</a> 3.4. 消息积压</h4><ol><li>事前，预估系统消息容量，架设足够服务器资源，尽量避免消息积压情况的发生；</li><li>事中，紧急扩容后端服务器资源，让后端尽快处理掉积压的消息；</li><li>事后，反思总结经验教训； <ol><li>定位消息积压问题，查看是否是业务正常逻辑导致；若是，则需要再次评估后端服务器资源与MQ服务器资源是否需要扩容；若不是，则需要定位消息积压原因，并进行修复；</li></ol></li></ol><h4 id="_3-5-实时命令时序图" tabindex="-1"><a class="header-anchor" href="#_3-5-实时命令时序图" aria-hidden="true">#</a> 3.5. 实时命令时序图</h4><figure><img src="https://cdn.nlark.com/yuque/__puml/f037c59bd9e2b978827bd3e0de6c1f80.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYXV0b251bWJlclxuXG5hY3RvciBcIueUqOaIt1wiIGFzIFVzZXJcbnBhcnRpY2lwYW50IFwiYmFja2VuZFwiIGFzIGJhY2tlbmQgI3JlZFxucGFydGljaXBhbnQgXCJyZWRpc1wiIGFzIHJlZGlzICN5ZWxsb3dcbnBhcnRpY2lwYW50IFwiZGJcIiBhcyBkYiAjZ3JlZW5cbnBhcnRpY2lwYW50IFwicmFiYml0bXFcIiBhcyByYWJiaXRtcSAjcGlua1xucGFydGljaXBhbnQgXCJpcGNcIiBhcyBpcGMgI29yYW5nZVxucGFydGljaXBhbnQgXCJtYWNoaW5lXCIgYXMgbWFjaGluZSAjb2xpdmVcblxuYWN0aXZhdGUgVXNlclxuXG5Vc2VyIC0-IGJhY2tlbmQ6IOS4i-WPkeaKhOihqOWRveS7pFxuXG5hY3RpdmF0ZSBiYWNrZW5kXG5hY3RpdmF0ZSBkYlxuYmFja2VuZCAtPiBkYjog6I635Y-W6K6-5aSH5L-h5oGvXG5kZWFjdGl2YXRlIGRiXG5iYWNrZW5kIC0-IGJhY2tlbmQ6IOe7hOijheWRveS7pOS_oeaBr1xuXG5hY3RpdmF0ZSByYWJiaXRtcVxuYmFja2VuZCAtPiByYWJiaXRtcTog5Y-R6YCB5oqE6KGo5ZG95Luk5raI5oGv5Yiw6Zif5YiXXG5kZWFjdGl2YXRlIHJhYmJpdG1xXG5cbmFjdGl2YXRlIHJlZGlzXG5iYWNrZW5kIC0-IHJlZGlzOiDnlJ_miJDlkb3ku6RrZXlcbmFjdGl2YXRlIGRiXG5iYWNrZW5kIC0-IGRiOiDlubborrDlvZXmioTooajmk43kvZzkv6Hmga_liLBkYlxuZGVhY3RpdmF0ZSBkYlxuXG5ub3RlIHJpZ2h0IG9mIHJlZGlzOiDku6VoYXNo57uT5p6E77yM6K6-5aSHaWTkvZzkuLrlgLzlr7nosaHnmoRrZXnlrZjlhaVyZWRpc1xuZGVhY3RpdmF0ZSByZWRpc1xuYmFja2VuZCAtPiBVc2VyOiDlj5HpgIHlm57osIPmjqXlj6PvvIzov5vooYzph43lrprkvY1cbmRlYWN0aXZhdGUgYmFja2VuZFxuZGVhY3RpdmF0ZSBVc2VyXG5cblxuYWN0aXZhdGUgcmFiYml0bXFcbmFjdGl2YXRlIGlwY1xuaXBjIC0-IHJhYmJpdG1xOiDnm5HlkKznm7jlhbPpmJ_liJdcbmlwYyAtPiBpcGM6IOino-aekOa2iOaBr-W5tuino-aekOivt-axgumTvui3r1xuYWN0aXZhdGUgbWFjaGluZVxuaXBjIC0-IG1hY2hpbmU6IOWPkemAgeaKhOihqOWRveS7pFxubWFjaGluZSAtPiBpcGM6IOaOpeaUtuaKhOihqOe7k-aenFxuXG5kZWFjdGl2YXRlIG1hY2hpbmVcblxuaXBjIC0-IHJhYmJpdG1xOiDlj5HpgIHmioTooajnu5Pmnpzmtojmga9cbmRlYWN0aXZhdGUgaXBjXG5cblxuXG5hY3RpdmF0ZSBiYWNrZW5kXG5cbmJhY2tlbmQgLT4gcmFiYml0bXE6IOebkeWQrOWIsOaKhOihqOe7k-aenOS_oeaBr1xuXG5kZWFjdGl2YXRlIHJhYmJpdG1xXG5cbmFjdGl2YXRlIHJlZGlzXG5cbmJhY2tlbmQgLT4gcmVkaXM6IOWbnuafpeiuvuWkh-S_oeaBr--8jOW5tuWwhuiuvuWkh-S_oeaBr-S4juaKhOihqOS_oeaBr-S4gOS4gOe7hOijhVxuYWN0aXZhdGUgZGJcbmJhY2tlbmQgLT4gZGI6IOW5tuiusOW9leaKhOihqOiusOW9lee7k-aenOS_oeaBr1xuZGVhY3RpdmF0ZSBkYlxuZGVhY3RpdmF0ZSByZWRpc1xuZGVhY3RpdmF0ZSBiYWNrZW5kXG5cbmFjdGl2YXRlIFVzZXJcblVzZXIgLT4gYmFja2VuZDog6L2u6K6t5Zue6LCD5o6l5Y-jXG5cbmFjdGl2YXRlIGJhY2tlbmRcbmJhY2tlbmQgLT4gcmVkaXM6IOafpeivouaKhOihqOe7k-aenFxuXG5iYWNrZW5kIC0-IFVzZXI6IOWPkemAgeWTjeW6lOe7k-aenFxuZGVhY3RpdmF0ZSBiYWNrZW5kXG5kZWFjdGl2YXRlIFVzZXJcblxuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvZjAzN2M1OWJkOWUyYjk3ODgyN2JkM2UwZGU2YzFmODAuc3ZnIiwiaWQiOiJKZ2thQyIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>redis的存在的目的在于把抄表结果与设备信息对应起来，所以使用hash的数据结构更为妥当，让设备id作为值对象的key</li><li>第12步之后，由后端监听程序获取抄表结果，并把抄表结果存入redis，之后把抄表动作信息记录到db中</li><li>轮训频率为1s一次</li></ol><h4 id="_3-6-异步抄表时序图" tabindex="-1"><a class="header-anchor" href="#_3-6-异步抄表时序图" aria-hidden="true">#</a> 3.6. 异步抄表时序图</h4><figure><img src="https://cdn.nlark.com/yuque/__puml/dda8c4bbdc1959a30934dd2a9cabee10.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYXV0b251bWJlclxuXG5hY3RvciBcIueUqOaIt1wiIGFzIFVzZXJcbnBhcnRpY2lwYW50IFwiYmFja2VuZFwiIGFzIGJhY2tlbmQgI2dvbGRcbnBhcnRpY2lwYW50IFwicmVkaXNcIiBhcyByZWRpcyAjb3JhbmdlXG5wYXJ0aWNpcGFudCBcInJhYmJpdG1xXCIgYXMgcmFiYml0bXEgI3llbGxvd1xuXG5hY3RpdmF0ZSBVc2VyXG5cblVzZXIgLT4gYmFja2VuZDog5Y-R6YCB5oqE6KGo5ZG95LukXG5cbmFjdGl2YXRlIGJhY2tlbmQgXG5iYWNrZW5kIC0-IGJhY2tlbmQ6IOafpeivouaVsOaNruW6k-iuvuWkh-S_oeaBr1xuYmFja2VuZCAtPiBiYWNrZW5kOiDnu4Too4Xlkb3ku6Tkv6Hmga9cblxuYWN0aXZhdGUgcmFiYml0bXFcbmJhY2tlbmQgLT4gcmFiYml0bXE6IOWPkemAgeWRveS7pOa2iOaBr1xuZGVhY3RpdmF0ZSByYWJiaXRtcVxuXG5hY3RpdmF0ZSByZWRpc1xuYmFja2VuZCAtPiByZWRpczog57yT5a2Y6K6-5aSH5L-h5oGv77yM562J5b6F57uT5p6cXG5ub3RlIHJpZ2h0IG9mIHJlZGlzOiDkvb_nlKhoYXNo77yM5Lul6K6-5aSHaWTkvZzkuLrlgLzlr7nosaFrZXlcbmRlYWN0aXZhdGUgcmVkaXNcblxuYmFja2VuZCAtPiBVc2VyOiDov5Tlm57lk43lupTkv6Hmga9cbmRlYWN0aXZhdGUgYmFja2VuZFxuXG5cbmRlYWN0aXZhdGUgVXNlclxuXG5cblxuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvZGRhOGM0YmJkYzE5NTlhMzA5MzRkZDJhOWNhYmVlMTAuc3ZnIiwiaWQiOiJyeW81QyIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>这里的响应结果为操作成功，只是代表发送抄表命令的动作是成功的，并不代表抄表结果成功返回；</li><li>要想查询抄表动作是否成功，需要去操作中心再次调用接口去查询；</li></ol><h2 id="_7-分布式存储-分库分表" tabindex="-1"><a class="header-anchor" href="#_7-分布式存储-分库分表" aria-hidden="true">#</a> 7. 分布式存储（分库分表）</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1819045" target="_blank" rel="noopener noreferrer">实战彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p>源码地址： <a href="https://github.com/x-cpa/ShardingSphereDemo" target="_blank" rel="noopener noreferrer">https://github.com/x-cpa/ShardingSphereDemo<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><figure><img src="/cs-tips/assets/1677578774614-383a2cf0.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/cs-tips/assets/1677580943824-73a3bc52.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/cs-tips/assets/1690857435685-e14428c8.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/cs-tips/assets/1678154013813-ac9e2066.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-实验" tabindex="-1"><a class="header-anchor" href="#_1-实验" aria-hidden="true">#</a> 1. 实验</h3><ol><li>构建千万级别数据库表；</li><li>对比下面三种情况的响应速度 <ol><li>使用索引的方式查询</li><li>不使用索引的方式查询</li><li>使用索引失效的方式查询</li></ol></li><li>加缓存的方案： 首次查询从数据库中查询，之后放入缓存中，第二次及以后的查询全部走缓存</li><li>读写分离的方案：</li><li>多数据源读写的方案：</li><li>分库分表的方案：创建多个库多个表，并从表中读取数据『目的是为了验证读写多个库里面的多张表』 <ol><li>C端用户订单表</li><li>B端用户订单表</li></ol></li><li>单库亿级数据分库分表『实现数据迁移』 <ol><li>全量同步 <ol><li>断点续传</li><li>数据一致性问题</li><li></li></ol></li></ol></li></ol><figure><img src="/cs-tips/assets/1704544808652-ac9dc5cd.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/cs-tips/assets/1704544808661-a9fe34ad.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-分库分表带来的问题及解决方案" tabindex="-1"><a class="header-anchor" href="#_2-分库分表带来的问题及解决方案" aria-hidden="true">#</a> 2. 分库分表带来的问题及解决方案</h3><p>参考： <a href="https://www.bilibili.com/video/BV1aY411K7qy/" target="_blank" rel="noopener noreferrer">如何解决分库分表带来的问题？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><figure><img src="/cs-tips/assets/1690858778564-376f7971.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-id" tabindex="-1"><a class="header-anchor" href="#_3-id" aria-hidden="true">#</a> 3. id</h3><h3 id="_4-分布式事务" tabindex="-1"><a class="header-anchor" href="#_4-分布式事务" aria-hidden="true">#</a> 4. 分布式事务</h3><p>一般情况下是两阶段提交和TCC。但是多数实际应用场景中，并不直接使用分布式事务，因为分布式事务：</p><ul><li>会带来严重的性能损耗</li><li>会引入额外的系统复杂度</li><li>分布式事务出现的几率很低</li></ul><p>一般采用柔性事务，即保证最终一致性。可以采用下面多种措施配合使用来保证最终一致性：</p><ul><li>回滚</li><li>重试</li><li>监控</li><li>告警</li><li>幂等</li><li>对账</li><li>人工介入</li></ul><p>如果非要使用分布式事务，可以使用阿里开源的Seata框架。</p><h3 id="_5-跨库查询和分页" tabindex="-1"><a class="header-anchor" href="#_5-跨库查询和分页" aria-hidden="true">#</a> 5. 跨库查询和分页</h3><p>方案1 选择合适的分库分表字段 方案2 引入搜索引擎ES 方案3 分开查询，内存聚合</p><hr><h3 id="_6-为什么要分" tabindex="-1"><a class="header-anchor" href="#_6-为什么要分" aria-hidden="true">#</a> 6. 为什么要分</h3><ul><li>软件系统也不是一上来就进行分库分表的，而是有一个演进过程： <ul><li>先是试着优化sql，提高单条sql的执行效率；</li><li>接着是加缓存、多租户、多数据源、读写分离；</li><li>最后才是分库分表；</li><li>但随着微服务领域的技术的发展，分库分表已经不重要了；</li></ul></li><li>RDBMS受单机存储容量、连接数、CPU处理能力、网络带宽等因素影响，容易成为系统瓶颈；</li></ul><h3 id="_7-什么时候分" tabindex="-1"><a class="header-anchor" href="#_7-什么时候分" aria-hidden="true">#</a> 7. 什么时候分</h3><ol><li>能不分就不分</li></ol><p>秉持的原则是： 能不分就不分，分库分表是迫不得已的选择，并不是一开始就使用的。这样做的原因是： 过度设计和过早优化会导致系统复杂性增高，可用性降低。因此在分之前要先考虑，机器性能是否已经被压榨到了极限？</p><p>因此在系统设计初期，就需要尽早考虑如何压榨RDBMS的机器的性能。一般情况下从下面几个角度去考虑：</p><ul><li>表设计，基本原则是根据业务进行解耦、创建一些索引用来提高查询效率</li><li>业务实现上面，基本原则，sql优化、使用缓存、</li></ul><p>如： 从sql优化、读写分离、使用缓存、多数据源等方面先进行优化，</p><ol><li></li></ol><h3 id="_8-理论基础" tabindex="-1"><a class="header-anchor" href="#_8-理论基础" aria-hidden="true">#</a> 8. 理论基础</h3><h4 id="_8-1-数据切分" tabindex="-1"><a class="header-anchor" href="#_8-1-数据切分" aria-hidden="true">#</a> 8.1. 数据切分</h4><ul><li>垂直切分 <ul><li>垂直分库： 如何分、优缺点</li><li>垂直分表： 如何分、优缺点</li></ul></li><li>水平切分 <ul><li>水平分库： 如何分、优缺点</li><li>水平分表： 如何分、优缺点</li></ul></li></ul><h4 id="_8-2-分库分表带来的问题及解决方案" tabindex="-1"><a class="header-anchor" href="#_8-2-分库分表带来的问题及解决方案" aria-hidden="true">#</a> 8.2. 分库分表带来的问题及解决方案</h4><ul><li>事务一致性问题</li><li>跨节点关联查询问题</li><li>跨节点分页、排序、函数执行问题</li><li>全局主键避重问题</li><li>数据迁移、扩容、校验 <ul><li>分为停机迁移、不停机迁移</li><li>迁移后需要对迁移后的数据进行校验</li></ul></li></ul><h3 id="_9-中间件" tabindex="-1"><a class="header-anchor" href="#_9-中间件" aria-hidden="true">#</a> 9. 中间件</h3><h3 id="_10-实践案例" tabindex="-1"><a class="header-anchor" href="#_10-实践案例" aria-hidden="true">#</a> 10. 实践案例</h3><h3 id="_11-分库分表演进过程" tabindex="-1"><a class="header-anchor" href="#_11-分库分表演进过程" aria-hidden="true">#</a> 11. 分库分表演进过程</h3><ul><li>优化SQL</li><li>加缓存</li><li>多租户</li><li>多数据源</li><li>读写分离</li><li>分库分表</li></ul><h3 id="_12-参考" tabindex="-1"><a class="header-anchor" href="#_12-参考" aria-hidden="true">#</a> 12. 参考</h3><ul><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=2389616635193393153&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">ShardingSphere进阶<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://github.com/zuihou/lamp-cloud" target="_blank" rel="noopener noreferrer">lamp-cloud : saas 平台<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.bilibili.com/video/BV1aY411K7qy/" target="_blank" rel="noopener noreferrer">如何解决分库分表带来的问题？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://cloud.tencent.com/developer/article/1819045" target="_blank" rel="noopener noreferrer">实战彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="_8-布式会话" tabindex="-1"><a class="header-anchor" href="#_8-布式会话" aria-hidden="true">#</a> 8. 布式会话</h2><h3 id="_1-参考" tabindex="-1"><a class="header-anchor" href="#_1-参考" aria-hidden="true">#</a> 1. 参考</h3><p><a href="https://mp.weixin.qq.com/s/hMr4E9xmcsw7RZ8Io50NUA" target="_blank" rel="noopener noreferrer">聊聊 分布式 Session<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener noreferrer">彻底理解cookie、session、token<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_9-分布式-job" tabindex="-1"><a class="header-anchor" href="#_9-分布式-job" aria-hidden="true">#</a> 9. 分布式 Job</h2><h2 id="_10-参考" tabindex="-1"><a class="header-anchor" href="#_10-参考" aria-hidden="true">#</a> 10. 参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/365986593" target="_blank" rel="noopener noreferrer">24.分布式系统的困境与NPC性别研究<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.codedump.info/post/20190405-ddia-chapter08-the-trouble-with-distributed-system/" target="_blank" rel="noopener noreferrer">《数据密集型应用系统设计》第八章《分布式系统的挑战》笔记 - codedump的网络日志<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.jianshu.com/p/e17c3738cca5" target="_blank" rel="noopener noreferrer">分布式系统的4种典型问题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.jianshu.com/p/f1daddc6bb13" target="_blank" rel="noopener noreferrer">分布式系统的5大特征<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.51cto.com/article/716232.html" target="_blank" rel="noopener noreferrer">分布式系统遇到的十个问题-分布式系统的定义<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/365986593" target="_blank" rel="noopener noreferrer">24.分布式系统的困境与NPC性别研究<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li></li></ol></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zeanzai/cs-tips/edit/main/demo/theme-docs/src/docs/05-distribution/distribution.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="page-nav"><a href="/cs-tips/docs/05-distribution/api.html" class="nav-link prev" aria-label="API（接口）"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->API（接口）</div></a><!----></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">浪漫骑士的二流键盘</div><div class="copyright">Copyright © 2024 zeanzai</div></footer></div><!--]--><!----><!----><!----><!--]--></div>
    <script type="module" src="/cs-tips/assets/app-fa4d50d2.js" defer></script>
  </body>
</html>
